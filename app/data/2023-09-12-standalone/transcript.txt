 Aplicaciones sin módulos es lo que está proponiendo Angular en las siguientes versiones. Empezar a quitar todos los módulos que tenemos y desarrollar aplicaciones de una forma más moderna y sin este concepto de módulos. Así que en este video vamos a hacer toda la migración de una aplicación que tiene módulos, módulos a nivel de Routing, módulos para encapsular, y vamos a ver precisamente cómo hacer esta migración. Así que, no siendo más, empecemos. La aplicación que vamos a migrar es esta, que realmente está modularizada. ¿Qué quiere decir? Que esto, por ejemplo, que es una protección del sistema de autentificación, está en un módulo. Nos loguea el módulo de Dashboard, es un módulo, de por sí todo el administrador como tal es un módulo, que luego despliega otros módulos como el de Dashboard, el de productos, el de categorías, el de usuarios, y finalmente un Logout. Al final, cada uno de estos es un módulo porque en el futuro, pues básicamente, Users, por ejemplo, acá tenemos la tabla, pero podríamos tener los formularios relacionados a crear un usuario, servicios, componentes, específicamente para nuestro módulo de usuarios, asimismo para categorías, productos. En ese momento, este código lo puedes encontrar en esta parte y como puedes ver, está encapsulado en módulos. Entonces, si vamos acá, es más, literalmente hay una carpeta llamada Modules, aparte del componente normal, que es el app module, esto se iría, todo lo que sea app module o lo que termine en module.ts, pues precisamente desaparecería, como por ejemplo el Routing, estos Routings ya no estarían. Y vamos a ver precisamente cómo serían aplicaciones y módulos. Y precisamente aquí tenemos los módulos de administración, el de notificación, categorías, Dashboard, productos y usuarios. Cada uno tiene sus componentes, su layout, su routing y pues su módulo, porque así lo hemos hecho por mucho tiempo en Angular. Básicamente, siempre empezamos a crear nuestros módulos y empezar allí a poner componentes, páginas, formularios, servicios, directivas, etc. Pero sin módulos, ¿cómo quedaría una aplicación? Pues precisamente vamos a llevar esta aplicación, que trabaja en la versión 16, a esta migración como tal. Angular, en su página, si buscas Standalone, vas a ver que por acá sale un resultado de cómo migrar una aplicación existente. Y él ya nos adelanta un poco de trabajo. Sin embargo, va a haber una parte que sí nos toca hacer manual, y faltaría ver si de pronto en la versión futura, en la siguiente versiones, nos facilitan aún más el trabajo con algunas tareas que nos toca hacer manualmente. Finalmente, él nos da este comando para hacer toda la migración, y él lo divide en tres pasos. Es decir, primero va a convertir todos los componentes, directivas y bytes a Standalone, porque esto es necesario para que una aplicación funcione sin módulos. Luego, él va a remover todos los ngModules innecesarios, porque pues si ya todos los componentes son Standalone, no necesitan el módulo. Y finalmente, también va a cambiar el bootstrap de la aplicación. Entonces va a dividir eso en tres pasos, y nosotros vamos a hacer uno manualmente. Y te va a enseñar precisamente cuál sería ese paso manual, y cómo llevar tus aplicaciones. Así que vamos al código. Si navegas en el código, te vas a dar cuenta que esta aplicación está en la versión 16. Sin embargo, las aplicaciones sin módulos ya se podían probar más o menos desde la 15 o 14. Pero desde la 15 es que nos dan este comando para hacer la migración automática. Recuerda que aquí esta aplicación literalmente está basada en módulos, y tenemos módulos muy famosos como el MaterialModule. Normalmente este MaterialModule nos sirve para saber qué es lo que vamos a utilizar de AngularMaterial, si es que en tu aplicación utilizas AngularMaterial. Por ejemplo, todo esto es lo que yo utilizo de AngularMaterial. Y a medida que yo quiera utilizarlo en módulos, como el AdminModule, lo importo. Entonces aquí, por ejemplo, si sé que el AdminModule va a manejar ciertos componentes de AngularMaterial, entonces me importa el MaterialModule, que es una clase de módulo compartido. También está el RoutingModule y el CommonModule. Todo este tipo de cosas desaparecerían. Literalmente, este archivo de RoutingModule o el archivo de AdminModule desaparecería. Y los componentes ahora ya no necesitan encapsularse en un módulo. Si no sientes tan alentos, ellos saben e importan solo lo que necesitan. Es decir, es un poco más granular o ya como que no se encapsula en un módulo, sino si este componente, el LayoutComponent, necesita algo del MaterialModule, solo se trae esa parte que lo necesita. Y no digamos que se incorpora todo el MaterialModule. Eso puede tener beneficios en el bundle site, es decir, el peso de nuestra aplicación, porque ahora cada componente es específico. Es más, no sé si sabías, pero el CommonModule es donde vienen directivas como el ng-if, el ng-of, el ng-for, están los pipes. Pero si un componente en específico no utiliza un ng-for o no utiliza un pipe en específico, pues básicamente podríamos decirle y ser tan granulares que no me puedo traer el CommonModule, pero podría decirme, mira, este componente solo utiliza ng-if y solo me traigo esa directiva. Entonces eso hace que en el momento de compilación se puedan quitar varios bytes, porque básicamente no estás trayendo cosas que no se usen. Aunque realmente también por detrás Angular siempre hace optimizaciones y si ve igual cosas que no estás usando, normalmente lo remueve. Pero si somos más granulares, pues igual dejamos más fácil el trabajo de los transpiladores o pues toda la parte que compila y analiza el código. Bien, entonces vamos a empezar a hacer la migración. Entonces lo primero y lo más recomendado es hacer una rama aparte. Yo ya tengo mi rama aparte por acá, la llame v16-install-addon, y vamos a correr el primer comando. De por sí solo es un comando y él lo va a dividir en tres pasos. Entonces vamos a ver. Entonces vamos a ejecutar ese comando. Ahí está, vamos a correr el comando y vamos a ver. Precisamente él me dice que puedo dividirlo en tres pasos, convertir todos los componentes, directivas y pipes a standalone. Entonces vamos a correr ese primero. Él puede hacer la migración de forma selectiva, es decir, en una carpeta en específico. Si yo quiero primero migrar y tengo muchos módulos o muchas cosas en mi aplicación, en mi software, pues puedo migrar por módulo literalmente. O sea, por ejemplo, tengo el módulo de ventas y quiero migrar solo el módulo de ventas a standalone. Pues entonces puedo decirle, mira, este es mi módulo de ventas y solo quiero migrar esta partecita a ver cómo me va. Y lo bueno es que Angular soporta todavía híbrido, es decir, aplicaciones con módulos. Utilizando standalone, por ejemplo, entonces lo podrías ir probando. En este caso voy a decirle que quiero migrar todo. Entonces, pues simplemente le digo que todo. Entonces él va a transformar todos mis componentes. Y fíjate que realmente no tengo muchos componentes en esta aplicación. Apenas están como las tablas. Luego vamos a ir creando formularios y más cosas a esta aplicación. Pero por ahora, fíjate que los componentes que están, él los cambió. Los cambió aquí a standalone components y me dice cuáles archivos actualizó. Veamos alguno de ellos, por ejemplo, el login component. Entonces vamos a ir a nuestra aplicación. Aquí vamos a ir al módulo de autentificación. Al de autentificación, acá está la página de login. Y fíjate que por acá hizo algo muy, muy interesante. Él cambió y le puso automáticamente standalone. Y como te mencionaba, este login component, de por sí teníamos por acá el módulo. Que es el módulo de autentificación. Y el módulo de autentificación traía, ¿qué traía? Traía el common module, el routing, el material module y los formularios reactivos. Pero como ya no vamos a tener, ahorita vamos a eliminar estos archivos. Como ya no vamos a tener un módulo, ¿qué pasa? Que el login component, al ser standalone, él mismo se trae lo que él necesita. Fíjate, por ejemplo, que no hay el common module. Él automáticamente detectó lo que este componente está utilizando. Que si miramos es un for builder, un router, esta partecita del snatbar para mostrar como notificaciones. Y si miramos en el HTML, pues hay un ng-if, ng-summit, etc. Él mismo va a analizar cada componente. Y va a saber realmente lo que necesita ese componente. Acá es el import. Entonces dice, mira, tú aquí en login component traes o usas las cards de material. Entonces sólo trae esa parte en particular. Utilizas formularios reactivos, entonces lo habilita. Utiliza, fíjate que acá ya no tenemos el common module. Sino directamente sólo lo que utilizamos, literalmente la directiva ng-if. Y pues aquí un progress, el icon. Quiere decir que esto cambia. Ya precisamente cada componente se trae lo que él necesita de otros elementos. En este caso de material o si tenemos formularios reactivos. Entonces ese fue el primer cambio. Vamos al segundo cambio. Una vez él haya transformado todos los componentes, directivas y pipes hasta Anadol. Él dice, ok, si ya cada componente sólo va a utilizar e importa lo que necesita. Pues precisamente es donde ya puede remover todos esos archivos modules. Que ya no serían necesarios porque cada componente ahora se está en Anadol. Entonces vamos a hacer ese siguiente paso. Aquí algo que él te va a pedir es que hagas un commit por cada paso. Entonces aquí voy a hacer un jdd y un commit. Y aquí, migrate to standalone. Listo. Ok, entonces vamos a de nuevo correr exactamente el mismo comando. Pero ahora nos vamos a ir por el paso 2. Remover todos los ng-module clases innecesarios. Entonces él me vuelve a decir si en algún pattern específico. Le digo que igual es en toda mi aplicación. Y fíjate que realmente eliminó sólo un archivo. Eliminó material module. Entonces ya no tendríamos este material module o este componente. Este módulo compartido que utilizábamos. Porque al final ya cada módulo se trae sólo lo que él necesita. Y hizo algunas actualizaciones en el dashboard module, en el project module. Vamos a ver cuáles fueron esos ajustes. Por ejemplo aquí voy a entrar al dashboard module. Y vamos a ver cuáles fueron los ajustes que hizo. Entonces vamos a ir por acá. Y fíjate que lo que hizo fue remover el material module. Y ya solamente como ese material module ya no lo usamos. Porque cada componente importa lo que necesita. Pues ya no sería necesario invocarlo. Simplemente pues eliminó ese material module. Y como lo eliminó también lo eliminó de todas las importaciones en donde se llamaba. Vamos por nuestro tercer paso. Así que voy a hacer un commit. Entonces vamos a hacer nuestro commit. Y vamos a decirle remove modules. Digamos que este fue el paso. Ok, vamos a limpiar la terminal. Y vamos a volver a correr el comando. Y finalmente va a cambiar el bootstrap de la aplicación. Entonces vamos a ir por ese tercer paso. Le decimos que en toda la carpeta. Y vamos a ver qué ajustes hace. Ok, eliminó el archivo app module. Cambió el main y el app component. Pues vamos a ver precisamente cuáles fueron esos ajustes. Si utilizamos aquí la herramienta de JIT. JIT precisamente nos dice por ejemplo que el app component lo volvió standalone. Fíjate que ese también lo volvió standalone. Y aquí le puso standalone. Y que el rover outlet ahora también lo importa. Ese fue el cambio que hizo en el app component. Pero miremos qué cambios hizo por ejemplo. El archivo app module sí lo eliminó. Fíjense que el app module es el que traía el interceptor, el bootstrap. Fíjense que aquí traíamos todos estos módulos. Vamos a ver qué hizo con él. Y acá básicamente sí hizo varios ajustes. Y cambió nuestra aplicación. Fíjate que por si este método cambia. Este se llamaba platform browser dynamic. Y utilizaba un método llamado bootstrap module. Aquí se cambia y utiliza directamente algo llamado bootstrap application. Y empieza a cambiar la forma de proveer precisamente providers. HTTP, client, etc. Vamos a verlo un poquito más a detalle. Y sin los cambios. Ahí está. Y aquí vemos un poco más los cambios que hizo. Pues cambió el bootstrap de la aplicación. Directamente ya no como que no lanza un módulo. Sino lanza un componente. Y ese componente va a ir llamando a otros. Pero fíjate que él ya sabe que utilizamos por ejemplo el HTTP. Para hacer peticiones. Y conectarnos a la recipia que trae los datos. Aquí también un provider animation. En fin, él hizo aquí algunos ajustes. Pero si te fijas. Seguimos teniendo archivos con el auto module. Tenemos aquí un app routing module. Precisamente estos son los pasos que faltan en ese comando de migración. Llega hasta el tercer paso. Pero hay un paso que toca hacer manual. Que es hacer la migración de las rutas. Posiblemente luego también lo hagan automático. Pero hasta el día de hoy este proceso toca hacerlo manual. Entonces vamos a remover estos archivos. Nosotros mismos. Yo mismo voy a remover estos archivos. Todos los puntos module que hay. Los vamos a remover. Y vamos a ver cuál sería la adaptación de ese routing. Utilizando pues una aplicación sin módulos. Como primer paso. Lo que vamos a hacer es dejar el main un poco más liviano. Porque de por sí Angular está probando precisamente cuál va a ser la arquitectura. O el bootstrapping de esta aplicación. Es decir, como el formato de archivos. Y lo que he visto en aplicaciones nuevas. Es que ellos manejan dos archivos. Que es el app config. config.ts Y uno que se llama el app routes. Entonces vamos a crear esos dos archivos. Y ya. Ok. Realmente este es muy parecido. El app routes es muy parecido a lo que teníamos como routing.module. Pero pues al final no es una clase. No es un export o no es un ng module. Ya no se utilizaría este decorator. Simplemente es un archivo con las rutas como tal. Entonces es más. Podríamos literalmente poner o cortar esta constante. Traernos lo que necesitemos. En este caso vamos a traer estos dos imports. Ya no necesitaríamos el ng module. Entonces nos traemos esos dos imports. Tampoco necesitaríamos el router module. Simplemente necesitaríamos la interfaz. Y ya. Ahora esto debería ser exportable. Porque en algún momento lo voy a necesitar. Pero hasta ahí vamos bien. Es decir, ese archivo es lo que necesitaríamos. Y también nos va a tocar hacer lo mismo con los demás. Y aquí es donde yo ya puedo eliminar este app routing. Literalmente lo podría eliminar. Vamos a hacerle que sí. Y listo. Ahora, ¿qué va en el app config? Realmente esto es para dejar el main un poco más sencillo. Si quieren ese paso lo dejo un poco al final. Porque básicamente lo que vamos a hacer es realmente proveer ahora como lo está haciendo. Utilizando el main.ts de esta manera. Pero luego les digo qué iría en el app config. Simplemente hagámoslo de una manera un poquito más soft. Entonces aquí básicamente lo que vamos a hacer. Fíjate que seguía utilizando este módulo. Ahora vamos a utilizar un nuevo método para proveer esas rutas. Ese nuevo método. Entonces vamos a quitar ese módulo que ya no existiría. Es más, este dynamic import tampoco va. Vamos a ir arreglando cositas. Vamos a ver que normalmente todos los paquetes de angular deberían ir por aquí arribita. Esto lo dejamos por acá. Esto solo es como para que angular esté por aquí arriba. Y lo propio pues esté acá. Listo. Entonces, del routing. Vamos a ver si por acá tiene el routing. No lo tiene. Entonces simplemente vamos a decirle que de el router. Vamos a traernos un método llamado provide router. Ok. Y de ahí vamos a decirle provide router. Y le vamos a dar las rutas. ¿De dónde sacamos esas rutas? Precisamente sería la importación. De el archivo app routes. Y recuerda que lo pusimos exportable. Entonces pues ahí están. Entonces se podemos llamar a las rutas. Aquí. Routes. Y pasarlas aquí. Listo. Ok. Hasta ahí vamos bien. De por sí esta línea de acá en algún momento deberíamos removerla. ¿Por qué? Porque esto básicamente lo que está haciendo es inyectar de forma como global al browser module, a los formularios reactivos y a esta imagen o a este componente de optimización de imágenes. Pero si nuestra aplicación ya utiliza 100% esta análoga en components, pues cada componente que utilice o quiera utilizar una imagen o formularios reactivos, pues debería simplemente importarlo. Así que esta es más, la voy a comentar. Y esta en su momento deberíamos eliminarla y ya. Los demás si se siguen manteniendo, entonces ese va a ser el ajuste por ahora. Ok. Entonces ahí tenemos eso. Pero nos falta migrar todas las demás. Entonces pues simplemente vamos a ir a los modules. Y fíjate que tenemos el, pues aquí tenemos las rutas del admin y tenemos el admin.module. Estos dos archivos ya los podríamos borrar y solo nos quedaríamos con uno. Es más, siguiendo la nomenclatura de app.roads, entonces voy a decirle que estas son las rutas admin. admin.roads.tips. Entonces ahí está. Que es un poco siguiendo esta nomenclatura de app.roads. Aquí sería admin.roads. ¿Qué hacemos? Pues migramos las rutas. Entonces solo, al final la constante y ya. Entonces vamos a seleccionar. Vamos a ponerlos acá. Ahí estarían. Ya no necesitamos el ng-module. Y tampoco el router.module. Listo. Esa sería la migración y pondríamos esta ruta como exportable. Luego vamos a ver cómo deberíamos usarla. Hasta ahí está bien. Entonces ya podría eliminar estos dos archivos. Vamos a eliminar los demás. Entonces los voy a eliminar. Y nos queda de esta manera. Ese mismo ejercicio vamos a hacer con todos los otros módulos. Entonces vamos a ir por acá. Vamos a ir a roads. Entonces nos traemos solo la constante. Ahí está. Exportamos las rutas. Export. Y listo. Aquí ya no utilizaríamos esto. Fíjate que este trabajo es el que se vuelve un poco tedioso. Y posiblemente Angular lo ponga como dentro de uno de esos pasos. De pronto un paso 4 en donde nos diga Ah, ahora voy a automáticamente emigrar de las rutas. Por ahora no está. Pero es bueno ir sabiendo qué es lo que va a ser por nosotros. Entonces simplemente vamos, en este momento lo estamos haciendo de forma manual. Entonces por acá está. Categories.roads. Entonces solo me copio la constante. Tan tan tan, tararán. Ya entonces no necesito este ngModule y tampoco este listo. Ahí estamos bien. Ya eliminó estos dos archivos. Listo, ahí estamos bien. Por acá ya empiezan a romperse algunas cosas. Ya vamos a ir viendo cómo arreglarlas. Primero vamos a hacer esa migración de las rutas. Entonces aquí estamos. Dashboard.roads.tisa. Perfecto, copiamos aquí. Fíjate que por ejemplo el dashboard no tiene ninguna. Pues tiene una declaración de rutas que luego vamos a utilizar como para mostrar gráficas y cosas de ese estilo. Que es lo que después quiero implementarle a este proyecto. Por ahora todo simplemente queda como una definición de rutas. Lo eliminamos, le decimos que sí. Falta el de productos. Products.roads.ts. Vamos a ir aquí al routing. De por sí fíjate que por acá tenemos, teníamos comentado algunos componentes que ya estaba empezando a trabajar para la parte de edición o del formulario. Pero pues vamos a ir agregándole cosas. Pero a medida vamos a ir utilizando pues estas nuevas API y esta nueva forma de desarrollar aplicaciones. Que sería sin módulos. Entonces aquí ya quitamos. Perfecto. Y nos falta el último. Y obviamente pues para un proyecto que tiene no sé, unas 200, bueno realmente sí pueden haber aplicaciones con 200 módulos, 50 módulos. Pues sí, ya se vuelve un trabajo un poco más agobiante. Y esperemos que Angular pues en su momento también nos aborde ese trabajo. Y nos permita pues también con un comando hacer la migración. Listo. Y además no se ve como, pues básicamente se vuelve una tarea muy manual. Estoy copiando algo y simplemente le estoy quitando pues el ng-module y el router y pues se le va a esta parte. Entonces posiblemente si lo pueda leer, con base a los archivos, hacer y pues quitar. Listo. Entonces ahí ya terminamos. Y ahora pasa algo interesante. Vamos a ver aquí qué pasó. En las rutas precisamente llamábamos a módulos. ¿Ves? Admin.y el módulo. Y internamente por si el módulo de administración también llamaba a los otros módulos. Entonces ahora cómo sería esto. Cómo podríamos nosotros hacer esta importación. Realmente no cambia mucho. Aquí en las rutas. Entonces vamos a ir a admin. Pero ahora vamos a tener el archivo admin.roads. Y pues allí vamos a decirle cuáles son las rutas. Esa sería la migración. Entonces aquí vamos a ir al módulo de out. Él debe tener sus rutas. Y en vez de hacerle un m.out.module, pues le definimos las rutas. Esa sería la migración. Entonces aquí también estamos utilizando pues ya el lazy o la importación de módulos. Entonces aquí nos traemos a las rutas. Y pues la ruta ya de cada módulo en específico. Vamos a ver. Roads. Ahí está. Punto roads. A ver, ayúdame autocompletador. Ahí está. A ver, este no está autocompletando. O de pronto no lo exporte. Ah, ahí está. No está exportado. Entonces por ende no lo consigue. Ahí está. Roads. Listo. Entonces vamos a cambiar por acá. Vamos a cambiar. Creo que voy a copiar y pegar. Al parecer este tampoco lo importe. Entonces vamos a exportar. Y ahí ya estaría. Y acá vamos a ver si este está. Ese sí estaba. Listo. Entonces ya tendríamos ese ajuste. Ahora fíjate que ya no tenemos ningún archivo .module. Y realmente la aplicación ya debería funcionar tal cual de esta manera. Pero voy a finalmente trabajar en el archivo config. Y lo que propone Angular como configuración de archivos es tener una app config para que el main.ts esté como lo más limpio posible básicamente. Entonces vamos a ver de qué trata ese application config. Entonces vamos a importarnos por acá. Import. Y vamos a traernos desde el Angular Core. Angular Core. Ahí está. Fíjate que por sí tiene un typing para application config. Ahí está. Entonces vamos a decirle que la, pues esa configuración va a ser una constante. Ahí está. Por si me faltó completo. Y pues esta va a ser el app config. Y aquí básicamente es lo que le pasaríamos. Esto es providers. Entonces lo vamos a pasar por allá. Y lo que tendríamos que hacer en este caso es pues importar lo que necesitemos. Entonces teníamos el provider routes. Ahí está. Vamos a exportar aquí las rutas. Aquí ya las tenemos desde app routes. Las tenemos ahí mismo. Ahí están. Acá tendríamos el interceptor. Entonces aquí si necesitamos como esta línea para lo de los interceptores. Y aquí por si tenemos nuestro token interceptor. Entonces vamos a ver de dónde se trae token interceptor. Aquí. Lo ponemos por acá. Entonces ahí están los interceptores. Y falta provide animations. Ahí está. Provide animations. Listo. Entonces este sería y de nuevo este ya no sería necesario. Podríamos dejarlo de esta manera y debería funcionar a menos que se me haya ido algún bug. Debería funcionar. Pero aquí ya nos ahorraríamos como tal esa como toda esta importación. Y aquí llamaríamos al app config. Entonces básicamente lo que tenemos es que quitamos todas estas importaciones. Eso. Y vamos a importar. Bueno, ya por si ya me lo puso por ahí el app config. Ahí está. Y se lo mandamos aquí. Exactamente no cambia mucho. Pues simplemente estamos poniendo este app config en un archivo como aislado. Pero pues eso que hace que pues cada archivo sea más fácil como de manipular. Como que este main se mantiene lo más simple posible. Y ya en nuestras configuraciones de la aplicación pues es donde tenemos toda la inyección de providers, etc. Y en app routes pues la definición de rutas. Finalmente entonces esa sería la migración. No hay nada más que utilizar modules literalmente. Quitamos todos los modules pero no significa que el concepto que aprendimos de módulos se pierda. Es decir tú sigues trabajando con base a un dominio. Es decir el admin module sigue estando como carpeta. Y aquí puedes poner los componentes que hagan referencia al admin module o al de out. Sigues manteniendo como esa capacidad o esa lógica de pensamiento para poder organizar tu aplicación. Pero a nivel técnico ya no se encapsula en un ng module. Y como ves cada componente lo que hace es importar lo que él necesita con el standalone. Entonces pues ya terminaríamos. Vamos a ver si la aplicación funciona. Entonces vamos a hacer un ng serve y ver cómo va todo. Ok, vamos a ver si desde aquí desde la terminal levanta nuestra aplicación y ver que todo funciona como debería. Obviamente deberíamos para que una aplicación de un gran tamaño podamos asegurar que todo funcione como debería. Pues deberíamos tener un set de pruebas unitarias. En este caso no las tengo. Luego podríamos trabajar en ello. Pero por ahora nos toca hacer pruebas manuales y ver que todo funcione. Por ejemplo aquí ya no funciona. Vamos a ver qué book tenemos por ahí. Hay algo por acá. Hay algo que dice que no está como que no le llegó este mat snack bar. No le llegó algún componente al login component no le está llegando. Entonces ahí por ejemplo hubo algún error en la migración y vamos a corregir ese error. Ese error posiblemente fue de Angular. Es decir ya te digo cuál es el error aquí en el módulo de login. Dónde está el módulo de out la página de login. Fíjate que él utiliza este mat snack bar que es como lo que yo utilizo para las notificaciones. Es más lo podemos ver un poquito en vivo. Recuerda que esto tiene un website. Entonces por ejemplo cuando yo le doy una interfaz o una contraseña inválida. Entonces sale como este mensajito y ese es algo que viene de ese módulo del mat snack bar. Es el que lo muestra. Y lo que me está diciendo aquí es que no le llegó. Y vamos a ver por qué no le llegó. Vamos a ver. Fíjate que él no importó aquí en los no como que no identificó que estábamos utilizando este módulo. Parece que identificó lo que había en el HTML pero no identificó lo que estaba utilizando aquí a nivel de componente. Entonces aquí voy a hacer la importación manual a ese módulo. Entonces vamos a ir a material. Vamos a ir a mat snack bar. A ver. Snack bar. Y mat snack bar. Acá hay algo curioso y es que desaparecimos los módulos de nuestra aplicación. Pero hay ciertas cositas por legacy precisamente por seguir manteniendo algunas cosas. Que van a seguir teniendo el nombre module y simplemente las importamos en nuestra aplicación. Entonces si este necesita de ese módulo porque utiliza uno de sus servicios y luego utilizará componentes. Pues precisamente allí lo importamos. Entonces le faltó eso a Angular cuando hizo la migración a standalone. No detectó este inject, su módulo y no me lo incorporó. Al parecer hizo un análisis más extensivo de lo que estaba utilizando en el HTML. Pero no detectó lo que estaba utilizando en el componente como tal o en el archivo de la lógica de negocio que sería la de TypeScript. Entonces vamos a ver y fíjate que ahora sí ya funciona. Entonces vamos a decirle una contraseña incorrecta. Y me dice que está incorrecta. Voy a volver a cargar para que me dé la contraseña correcta. Vamos a darle login. Y por aquí tenemos otro error al parecer. Bueno hay un toggle por ahí. Vamos a ver cuál es la falla. Pero vamos a ver productos. Vamos a detectar de pronto algunos errores más. Bueno este no es error como tal. Es simplemente pues que la imagen no está. Recuerden que esta API es abierta. Entonces como que todo el mundo puede hacer una modificación, subir, editar imágenes. Recuerden que esa es la fake API de Platzi. Es esta. Entonces como todos tenemos permiso de agregar, editar. Pues precisamente ahorita habrán estudiantes haciendo sus prácticas. Y pues nos están editando acá. Normalmente se hace un reset cada cierto tiempo para volver al estado natural de la API. Pero pues acá tenemos usuarios, dashboards. Creo que el único book así que tenemos es ese del dashboard. De resto carga. Pues que no estén las imágenes ya es un error más de backend. Pero aquí tenemos el estado. Por ejemplo si yo hago logout. Como no tengo sesión voy a tratar de ingresar a una ruta que no exista. Fíjate que como no existe debería redirigirme. Ah claro, aquí nos falta nuestro 404. Podríamos desarrollar esa página. Que es cuando no tenemos una ruta que existe. Pero si yo trato de ingresar a una ruta que existe como admin products. Pero no tengo sesión. Pues debería redirigirme a autologin. Entonces vamos a ver cuál es este book primero. Lo vamos a solucionar. Veamos bien el error que está pasando. De por si dicen en línea 47. Aquí vamos a ver un momento. Acá. Vamos a ver acá. Esta función está haciendo referencia a toggle. Y toggle no existe en ese momento. De por si por eso está dando undefined. Y vamos a ver cómo solucionarlo. Entonces déjame lo inspecciono por acá. Ahí está. Y vamos a ver que en nuestro código lo único que tenemos que hacer. Es que este componente como hace referencia. De por si acá tenemos este mat-side-nat. Side-nat. Básicamente tenemos una referencia a este drawer. Y con este abrimos y cerramos nuestro menú. Pero aquí lo hacemos con referencia a un viewchild. Y este viewchild tendríamos que decirle. De por si esto también es un book como heredado. Vamos a darle static igual a true. Bien. Y vamos a decirle. Ahora sí ahí ya está la aplicación. Y no tenemos ese como errorcito. Es más si recargamos de nuevo. Vamos a ver si funciona. Ahí está nuestra aplicación. Funcionando sin problema. Nos faltaba migrar este static a true. Si quieren en el comentario o en un video específico. Les puedo explicar un poco más que significa este static true. Pero simplemente en el viewchild. Ahora tenemos este static true. Que eso viene casi desde la versión 9. Para no tener errores. Precisamente el momento de saber y especificar. Cuando cambiar este estado que viene desde el HTML. Ok. Pero entonces nuestra aplicación ya quedó totalmente migrada. Funcional. Utilizando standalone components. Y no tiene absolutamente ningún módulo. En este momento la aplicación ya era migrada a la versión 16. Recuerda que aquí estoy dejando por ramas el proyecto. Entonces aquí en la rama B16. Está la aplicación en la versión 16 con módulos. Luego también tenemos la rama de la versión 15. Que es donde inicie. Pero tenemos la rama de la versión 16 con standalone. Y esta rama de por sí ya la incluí a la rama main. Que es la rama principal. Por ende se está haciendo deployment a Fiber Hosting. Entonces si quieres igual mirar los cambios de la versión 15 a la 16. De la 16 pues ya está en standalone. Y aquí en donde ya finalmente migramos hacia la rama main. Que es la que va a quedar desplegada a producción. Aquí por ejemplo ya hizo el despliegue a producción. Por ende entonces aquí ahora la aplicación que está en este dominio. Debería funcionar sin mayor problema. Ahí está nuestra aplicación está funcionando sin mayor problema. Y tenemos nuestra aplicación ya hecha sin módulos. Bien y este ha sido el final de nuestra migración. En donde tomamos una aplicación que tenía varios módulos. Y la llegamos a migrar y eliminar todo archivo que sea module.ts. Ahora nuestra aplicación está libre de módulos. Recuerda que esto desde mi punto de vista tiene dos ventajas. Una el bundle size. Es decir el tamaño de nuestra aplicación o el peso podría reducirse. Porque precisamente los standalone components importan de forma más granular lo que necesiten. Y por ende en el momento de transpilar y compilar. Pues puede elegir precisamente que es lo que necesita. Y reducir el peso de nuestra aplicación. Y segundo ya tiene que ver con la forma de aprendizaje. Normalmente este concepto de módulos. Cuando uno aprende Angular es uno de los que más causa fricción. O de los que por ejemplo no existen en los otros frameworks o los otros ecosistemas. En frameworks como Nuxt, con React, con Nuxt, con Vue. No existe esto de módulos y esto ocurre un poco más. Tras bambalinas o bajo cortinas básicamente. Porque el framework lo hace por ti. Angular está también optando por esta opción. Básicamente todo lo de la modularización lo hace por ti. Sin que tú te tengas que preocupar explícitamente por implementarlo. Recuerda que igual puedes seguir programando a nivel como de organización con módulos. Nuestra aplicación precisamente funciona a nivel modular. Es decir tenemos la carpeta modules. En la carpeta admin está todas las páginas componentes. Que están relacionados al módulo de administración. O al módulo de productos o al módulo de usuarios. Se sigue trabajando en ese concepto. Que por si es un muy buen concepto para organizar nuestro proyecto. Que es base a dominio. Entonces si tenemos nuestra aplicación, nuestro módulo de ventas. Pues allí metemos todos los componentes, etc. Es más, podríamos seguir teniendo un módulo llamado Shaded. Que son como estos componentes que se pueden compartir con los demás. Pero a nivel técnico ya no tenemos que preocuparnos por declarar el módulo. Como se comporta. Simplemente todos son standalone. Y lo importamos en donde lo vayamos necesitando. Así que déjame en los comentarios. Que te pareció migrar esta aplicación. Y si quisieras ver otro tipo de aplicaciones para poderlas migrar. O aplicaciones un poquito más complejas. O en que te quedó dudas. Y con gusto lo estaré resolviendo. Recuerda suscribirte al canal. Y nos vemos en la siguiente. Subtítulos por la comunidad de Amara.org