 En este comando te voy a enseñar cómo migrar una aplicación entera de Angular hacia la nueva sintaxis sólo utilizando un comando que nos da Angular, así que veamos directamente cómo empieza. La aplicación que va a migrar hacia la nueva sintaxis es un gestor de un e-commerce, pues que tiene productos y demás y realmente el código no es tan complejo, pero sí tiene bastantes componentes y ahí es donde automáticamente un comando va a migrar todos estos componentes utilizando la nueva sintaxis. Recuerda que para eso, para utilizar esto, ya deberías estar utilizando o estar ubicado en la versión 17 de Angular. Ahí es donde precisamente deberíamos empezar a hacer este tipo de trabajos para aprovechar todas las ventajas. Si necesitas saber cómo migrar paso a paso, te dejo aquí uno de los videos en donde migramos de la versión 16 hacia la 17, pero ahora vamos a hacer esta migración hacia la nueva sintaxis. Así que vamos a ir a la terminal y veamos qué comando tenemos que correr. Estando en tu proyecto, vas a ejecutar el comando ng generate y le vamos a poner angular slash core dos puntos y allí vamos a decirle control flow, control guión al medio flow. Damos enter y aquí él me dice si yo quiero migrar toda la aplicación o si quiero migrar una parte de la aplicación. Esto es importante porque si yo quisiera migrar solo una parte, si yo quiero migrar una partecita de la aplicación, por ejemplo, todo lo que tenga que ver con la carpeta de ventas o con la carpeta de categorías, puedo hacerlo así de forma selectiva. Recuerda que esta nueva sintaxis puede trabajar con la anterior, con la vieja. Entonces pueden vivir sin problema y puedes ir migrando como tú lo vayas indicando. En esta opción yo voy a elegir migrar de una vez toda la aplicación. Entonces aquí voy a elegir que sí, que toda la aplicación. Luego me dice que si yo quiero hacer un reformateo hacia los templates. Realmente sí. Lo aconsejo porque de una vez también te organiza el código con la nueva sintaxis. Entonces le voy a dar que sí. Y luego, pues literalmente me dice que utilice esta migración con precaución, pero ya la ejecutó y vemos que literalmente analizó todos los archivos HTML y de por sí modificó unos punto TS, hizo actualizaciones y aplicó la nueva sintaxis. Veamos cuáles fueron esos cambios. Si vamos a la herramienta de JIT de Visual Studio Code, vemos todos los cambios. Que hizo y les podemos ver en orden. Entonces vamos a ir a ver acá. Entonces, por ejemplo, aquí empezó. Acá teníamos un mat list que se ejecutaba de acuerdo si la variable user estaba o no y literalmente esto ya lo encerró, lo quitó y le encerró utilizando la nueva sintaxis que sería el arroba if user que es la variable que teníamos que digamos que chequear si existía antes de renderizar este mat list. Entonces por eso lo colocó ahí dentro. Pero miramos que también hizo algo en el TypeScript. Veamos qué fue lo que hizo en el TypeScript. En el TypeScript agregó este async. Entonces lo agregó aquí precisamente a los imports. Eso quiere decir que en nuestro HTML en algún punto. Vamos a verlo en algún punto fue donde utilizamos ese async. Esa async, por ejemplo, se está utilizando acá, aquí arriba. Mira, ahí está el async. Y lo. Como ven, está en el async. Vamos a verlo. Estamos utilizando está en components, entonces lo agregó, lo importó y automáticamente lo puso dentro de nuestros módulos. Eso de por sí también lo hizo automáticamente la migración. Vamos a ver qué más ajustes hizo por acá. Vamos a ver qué más ajustes de migración. Acá, por ejemplo, se mostraba un mat error, que son los errores que aparecen en el formulario de login. Entonces si hay un error, por ejemplo, si el email es inválido, entonces se muestra. Entonces. Si hay un error, entonces se muestra. Entonces, si hay un error, entonces se muestra. Entonces, si hay un error, entonces se muestra. Entonces, si hay un error, entonces se muestra. Entonces, si hay un error, entonces se muestra. Pero sí y sólo si el campo ha sido touchet y si el campo tiene un error. Entonces había como un if para poder mostrar ese elemento. Pero ahora, en vez de tener un ng if atada al elemento, pues utilizamos la nueva async que sería esta, arroba if. Y por acá, por ejemplo, teníamos otro if para decir que el email es requerido. En ese caso también debería ser touchet. Y si tiene el error, required. Entonces aquí básicamente pasó como esos error. Que yo tenía mapeados como ng if a arroba if utilizándolo a la nueva sintaxis. Es más, acá hay un spinner. Si hacemos loading, hay un spinner con un loading que se va mostrando. Y ese flujo también estaba controlado por un if. Acá tenemos un show spinner. Y literalmente entonces lo muestra o no. Y lo migró automáticamente a la nueva sintaxis. Estos errores son los que aparecen por acá. Por ejemplo, si yo doy un email inválido. Entonces ahí dice, por favor, el email es válido. Y ese mensajito solo aparece si el campo ha sido touchet. Es decir, hemos trabajado como en él. Ha sido tocado. Sería como la traducción. Y además de eso, pues si realmente es inválido, pues entonces aparece este mensaje. También aparece otro. Donde nos dice que el email es requerido. Para eso tendríamos que borrarlo. Y ahí dice, email is required. Entonces estos mensajes aparecen de forma dinámica. En la interfaz. Y se administraban o se ejecutaban. Básicamente por la definición de un ngif. Y lo que cumple con esa condicional. Ahora precisamente. Entonces se está migrando hacia la nueva sintaxis. Y ya utiliza esta nueva como declaración. Veamos a ver qué otras cosas más hizo en esta migración. Pues realmente, de nuevo. Si tu aplicación es bastante grande. Pues él va literalmente a ejecutarlo. En todos los archivos HTML. Y si ve que hay algún ajuste que hacer en el TypeScript. Lo va a hacer. Veamos por ejemplo. Si esta lista de componentes. Esta tabla. Tiene un for. Por ejemplo, acá hay un for. Entonces vamos a verlo. Acá. Listo. Esa tabla precisamente. O ese for que vamos a ver. Es este que está acá. Es este for de las imágenes. Cada producto tiene como un array de tres imágenes. Entonces aquí cada row. Cada fila. Pues se está iterando. Pero tiene una iteración interna. Que sería. Que cada producto tiene un array de imágenes. Y las itera para mostrar cada uno. Entonces mostrar las tres imágenes. Que hay. Si hay dos imágenes. Pues haría un for de dos. Etcétera. Y si hubiera más. Pues literalmente les va mostrando. Aunque creo que en el código. Tengo un límite de tres. Entonces pues hace la iteración. Desde uno hasta tres. Veamos en código. Cómo hizo esta migración. Utilizando el ng for. Hacia la nueva cláusula. Aquí vemos cómo funcionaba antes. Entonces para hacer esa migración. Utilizaba el img. Y por acá debe estar el for. Ahí está el for. El ng for. Entonces básicamente. Hacia una iteración. De la variable images. Que viene desde la API. Y le hacía un slide. Es decir sólo para que. Si un producto tenía 50. Pues no salieron 50 imágenes ahí. Sino simplemente las primeras tres. Entonces por eso este slide de tres. Pero veamos que pues todo esto. Estaba como en un ng for. Pero ahora. Vamos a ver cómo lo migró. Básicamente él lo puso. La cláusula. Recordemos que la nueva sintaxis. Ya no está atada directamente al elemento. Sino que normalmente. Es una cláusula que va. Encierra al elemento como tal. Entonces acá tenemos el for. Tenemos img. Acá está exactamente la misma. Como. La raíz que vamos a iterar. Con el mismo slide. Acá tiene el track. Este track es obligatorio. En utilizando este tipo de for. Pero él automáticamente ya lo resolvió. Que en este caso es la url de la imagen. Eso también sirve para rendimiento. Y acá pues ya dejó el elemento. Entonces aquí como estamos iterando por img. Pues aquí ya lo podemos utilizar. Imprimirlo. Y pues acá tenemos el ngsrc. Con un ancho y un alto. Y es lo que imprime precisamente. O lo que hace que se impriman esas. Tres primeras imágenes. Y ya automáticamente analizó mi html. Y lo migró a la nueva sintaxis. Y listo. Y literalmente si nos ponemos a ver. Otros html. Vamos a ver que. Pues lo que hizo fue exactamente la migración. Donde había un if. Por ejemplo por acá. Para el counter de productos. Pues donde había. Un if. Lo pasó básicamente. Hacia la nueva declaración. Y si vemos por acá también productos. Acá también tenemos un for. Es más este for es nuestra lista de. De filtro las categorías para nosotros. Filtrar. Entonces básicamente. Mostramos por ejemplo aquí un progreso. Para una barra de progreso que está en el matol. Y mostramos esa barra de progreso. Con este show progress que este show. Progreso. Por si es una. Sánchez. Si nosotros vemos en el h en el. Type script. Vemos que show progreso es una. Sánchez que está en false. Y en algún momento me imagino. Cuando tenemos los productos la cambiamos a. Tú entonces precisamente. De acuerdo a esa sangre. Pues vamos a mostrar o no un elemento. Que sería en este caso el mat progreso. Y antes lo hacemos con el. En gif ahora ya lo hizo con el arroba. If en este caso ya luego teníamos un select. Para seleccionar la categoría que queremos. Pues ver y filtrar los productos. Y acá teníamos un mat option que estaba iterando. Acá la tenemos acá tenemos el en gif. For y vemos como lo migró automáticamente. Y también pues como que respeto el formato. Entonces acá tenemos un mat option. Donde está el valor por defecto que es en todos los productos. Y hizo automáticamente la migración. Sin embargo, acá hay algo que debes tener en cuenta. Y es que él. Básicamente utiliza esta nueva sintaxis. Y la nueva sintaxis el track by. O el track es obligatorio. Cuando se hace esta migración en automático. Con el comando que hicimos. Él simplemente hace el track por el. Por todo el objeto como tal. Pero la buena práctica sería hacerlo por el elemento que no se repite. En este caso podríamos colocar el identificador. Vamos a ver categoría punto aire. Esa sería una mejor práctica. Es decir, si tenemos un identificador único de esa categoría. Deberíamos darle el aire. Aquí lo está haciendo como el objeto en general. Eh, si bien funciona. Funcionaría mucho mejor si le damos en particular el objeto que no se repite. O el atributo que no se repite a través de todos esos objetos. Que en este caso es nuestro ID. Entonces eso si no lo hace de forma automática. Simplemente deja el todo el objeto. Entonces si quieres. Eh, tener esa mejora. Y si dentro de tus objetos hay una variable o un identificador. Puede ser ID. Puede ser. Primer aquí. Puede ser algún otro elemento que tengas. Que sea. El. Identificador único de ese elemento. Pues lo puedes poner aquí en el track by. Y con esto vas a lograr mejor rendimiento. Entonces, pues literal. Esa fue la migración. Lo hizo. Eh. En varios de los archivos como te indicaba. Si tú quieres hacerlo durante todo el proyecto. Pues él va a leer todos sus archivos HTML de todo el proyecto. Si hace falta algo en el TypeScript. Lo va a poner como vimos. Eh, normalmente deberías ya utilizar los Standalone Components. Pero si no utilizas Standalone Components. Igual la migración te va a funcionar. Eh, porque recordemos que eh también la una de las ventajas de Angular. Eh, que sigue manteniendo en esta versión y en cualquier otra es la retrocompatibilidad. Entonces, si estás trabajando con módulos y aún así quieres utilizar el nuevo modelo de sintaxis, lo puedes hacer y ejecutar este comando y listo. O si estás utilizando ya el Standalone Components. Igual puedes hacer esta migración hacia el nuevo modelo de sintaxis y sin problema funciona. Es más, vemos la aplicación funcionando. Entonces aquí si yo me logueo. Vamos a a mirar aquí en productos. Tengo una lista de productos. Vamos a editar. En este caso voy a editar. Este ahí está. Edita entonces funciona. Acá está literalmente la lista de categorías que recordemos que esto ya está con un for. Eh, pero con un for de la nueva sintaxis, pero funciona el nuevo filtro. Acá tengo categorías, acá tengo usuarios y pues tengo nuestro logout y funciona perfecto. Si yo le coloco un eh contraseña inválida. Entonces. Vamos a hacer. Se muestra el progress que les estaba mencionando y si pues la contraseña es inválida, me muestra aquí un mensaje con eh credenciales inválidas y pues lo cierro y demás. Acá también tengo esto de por si esto también está controlado por un ng if sí, pues el si yo le digo pues que lo muestre la contraseña, pues cambia el type y si no, pues la vuelve a ocultar, etcétera. No, entonces aquí tenemos un comportamiento normal y todo esto ya está con la nueva sintaxis y mi. Simplemente en un solo comando, así que ahora vamos a lanzar la producción. Ahora esto lo fui trabajando como en una rama, así que voy a agregar todos estos ajustes. Lo va a decir a la inteligencia artificial que de acuerdo a todos esos cambios me generó un commit. Acá dice que hizo literalmente lo el análisis que él dice y el commit que él me propone es este fix html syntax errors and update imports. Eh, que no es arreglar la sintaxis, yo creo que sería como más migrar. Mi grade eh html. Síntaxis y no son errores, o sea, no había errores, simplemente lo estamos actualizando, entonces fíjate que acá podría mejorar ese comité y ya, pero igual fue un buen comité que generó visual estudio de code con inteligencia artificial. Pasa el commit público, ahora está la nueva branch y vamos a hacer el PR a la rama principal. Listo, aquí tenemos precisamente este nuevo branch, entonces vamos a hacer el PR aquí, lo voy a dejar de mayúscula. Ah, no colocará en la descripción, no es buen consejo, coloquen algo en la descripción, en este caso simplemente lo voy a saltar. Y listo, entonces vamos a ver realmente cuáles fueron esos cambios. Si alguien, si algún desarrollador me enviara esto y tuviera que hacer code review, pues aquí vemos todos los cambios que hizo. Básicamente, pues como vemos, cambió el ngif hacia la nueva sintaxis, introdujo unos imports que al parecer faltaban en el modo standalone. Acá tenemos otro if, pues toda la migración que hizo, básicamente ahí la tenemos. Entonces tenemos acá otro if por acá que teníamos, tenemos los imports aquí, por ejemplo, tenemos un mat grid, esto es en el si no estoy mal, es en el componente de dashboard. Acá pues tenemos nuestro for. En fin, aquí nosotros ya podemos ver toda esa migración que hizo en automático y pues simplemente hizo esa actualización en el HTML. Entonces aquí ya podría, pues, hacer march, confirmar el march. Vamos a hacerlo. Y por defecto, al hacer ese march, pues se va a hacer un deployment. Aquí podemos ver el detalle del deployment. Se va a hacer el deployment a Fiber Hosting. Entonces automáticamente se despliega nuestro nuevo proyecto utilizando esta versión que sería con la nueva sintaxis. Listo, aquí ya terminó el deploy, vemos que todo salió check, entonces podemos ir al dominio donde está la aplicación. Aquí es donde la tengo alojada. Vemos que, literalmente, ya estamos utilizando la nueva versión. Aquí podemos inspeccionar. Vemos que estamos utilizando la 1. La 17.1.0 y veamos que todo sigue funcionando. Entonces aquí está nuestro login. Los productos siguen funcionando, se siguen renderizando, sigo teniendo el filtro, etcétera. Literalmente, la aplicación está en producción utilizando la nueva sintaxis. Resumiendo, entonces utilizamos este comando y el comando nos va a permitir tener la opción de migrar toda la aplicación, o si queremos ir migrando en una carpeta en particular. El va a analizar todo el HTML por ti y va a hacer toda la migración. Por ejemplo, en mi código no había ningún switch, entonces simplemente solo lo aplico hacia los if y hacia los force, que es donde estaríamos aplicando este nuevo modelo de sintaxis. Entonces, todo lo que sea precisamente un if que estaba declarado de esta manera, es más, tenías un else, el automáticamente lo va a migrar, eso va a analizar estos bloques en particular, y lo va a migrar utilizando este nuevo modelo de sintaxis. También lo va a hacer en los force, vieron que cualquier force que tenía ahí en la tabla, él lo va a analizar, va a interpretar, lo va a migrar y de por sí va a implementar un formateo para que ya todo quede organizado. También, de nuevo, si encuentro un switch como este, él va a hacer la migración. Entonces tenemos un switch y lo va a migrar de esta manera. Entonces, él automáticamente lo analiza y hace el ajuste. Recordemos que la nueva sintaxis no es solo una mejora, developer experience, sino realmente tiene mejoras en performance bastante interesantes. Entonces, si nosotros aplicamos esta nueva modelo de sintaxis, realmente no sólo vamos a tener una mejor developer experience, poder leer mejor nuestro código, sino también la aplicación como tal va a ser más performante, más rápida, porque literalmente hacer una actualización bajo esa lista y si utilizas bien el track que podemos en un video exclusivo de ver cómo funciona ese track, pero aquí básicamente el tip es ese track literalmente tienes que darle un ID único para que él pueda cuando se haga una inserción, se remueva, etcétera, saber el identificador en particular de ese elemento y hacerlo de forma óptica óptima, eliminar precisamente algo dentro de una lista, actualizarlo, crearlo, etcétera. Entonces, todas estas manipulaciones del DOM las hace mucho mejor que si lo comparamos con la antigua sintaxis. Así que, listo, eso es todo por el video. Recuerda suscribirte por acá, te van a dejar según la inteligencia artificial de YouTube, te van a dejar videos recomendados y recuerda suscribirte porque igual voy a seguir enviando más videos acerca de utilizar las ventajas que ya tenemos en la versión 17. Una de ellas es utilizar este nuevo modelo de sintaxis, pero también hay otro par del cual te voy a estar hablando, así que suscríbete y compártelo a toda tu comunidad, amigos en tu empresa, precisamente si quieren ya ver si te gusta este video, ver esta nueva sintaxis y migrar, pues mándales este video. Nos vemos en la próxima.