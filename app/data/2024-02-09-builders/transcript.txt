 Desde la versión 17 ahora tenemos tres builders diferentes para construir nuestra aplicación. Uno basado en Webpack, otro en ESBuild y otro que te deja ya preparado para hacer server-side rendering. ¿Cuál escoger y cuáles son las ventajas y cómo podríamos movernos entre ellos? Pues precisamente es lo que voy a ver en este video y vamos a ver cómo implementarlo. Así que iniciemos. Si vas a la documentación nueva y buscas Building Angular, ahí está, Building Angular Apps, vamos a encontrar cuatro tipos de buildings. Uno que es especial para paquetes, para librerías, no es nuestro caso. Si nosotros estamos interesados en construir aplicaciones, estos son los tres que nos interesan. Browser, Browser ESBuild y Application. Cada uno de ellos tiene una aplicación, así que vamos a verlo. Empecemos por el de Browser, que es el más antiguo y es el que normalmente la mayoría utiliza en sus aplicaciones. ¿Por qué? Porque es precisamente el empaquetado que siempre hemos venido trabajando con Angular. Este precisamente está descrito como una aplicación que va a ser, el render va a ser desde el lado del cliente y su empaquetador va a ser Webpack. Está escrito precisamente de esa manera y tiene esas dos variantes. Recuerda, utiliza Webpack y el render va a ser desde el lado del cliente. Te recomiendo usar este si lo que quieres es causar la menos fricción posible en la migración hacia las nuevas características de Angular. ¿Por qué? Porque este es precisamente el que siempre hemos utilizado. Es más. Si tienes algún paquete que utiliza Webpack o está personalizado, alguna librería o algo que hayas construido que funciona solo con Webpack, pues este debería ser el que deberías utilizar. O si tienes alguna customización de la forma que haces building de tu aplicación y tienes por allá un custom Webpack o algo similar, pues este debería ser la forma y con esto rompes lo menos posible. Sin embargo, los otros builders son estables, pero pues podrían causar algún problema si la librería no está adaptada a estos nuevos builders. El siguiente es Browser ESBuild y es básicamente lo mismo que el anterior, solo que en vez de Webpack utiliza ESBuild. Ahora, este tiene un gran potencial porque básicamente ESBuild es un empaquetador que está escrito en Go y es muchísimo, muchísimo más rápido que Webpack. Lo vemos en estas métricas precisamente que estamos viendo en el slide. Pero Angular ha hecho bastantes pruebas y casi que en los sistemas de construcción utilizando ESBuild es 57% más rápido. Entonces, si tú tienes integración continua, estás haciendo building para ejecutar pruebas, para literalmente poner tu aplicación en producción, etc. Entonces, vas a ver una reducción muy interesante de tiempos. No solo también en sus sistemas de CLI, de integración continua, sino también lo vas a ver en tu local. Es decir, va a ser ejecuciones más rápidas, el ng-serve trabaja pues mucho mejor, etc. Entonces, aquí tenemos eso. La aplicación sigue siendo construida para el cliente, se renderiza en el lado del cliente, y el último que se llama Application. Este lo lanzó desde la versión 17. Probablemente es el que va a estar más soportado desde la versión 17 en adelante. Y Angular quiere que nos migremos hacia este, hacia Application, porque tiene ventajas bastante interesantes. Es más, si tú inicias un proyecto hoy desde cero con Angular y lo haces sobre la versión 17, ya por default viene con este builder. Si tienes una aplicación antigua, también lo puedes llevar a este builder. ¿Qué es lo que vamos a hacer en este video? Literalmente, como yo tengo un sistema que utilizaba el builder antiguo, si no estoy mal, lo utilizaba Browser o Browser ESBuild, vamos a migrar a Application. Vamos a ver que es súper sencillo. Pero lo importante es qué tiene este nuevo builder y por qué Angular quiere que lo manejemos. Pues está descrito precisamente como una conjunción entre Byte y ESBuild. Sigue utilizando ESBuild como motor de empaquetamiento, pero desde el lado de desarrollo también utiliza algunas ventajas de Byte, lo cual mejora mucho el proceso de desarrollo. Este builder es muy interesante porque el equipo trabajó bastante en este nuevo para que funcione muy bien la parte de Server Side Rendering y la parte de Client Side Rendering. Es decir, con este application podemos generar esos dos tipos de aplicaciones, pero internamente está muy optimizado para traer ventajas en rendimiento. Sobre todo si empiezas a habilitar Server Side Rendering. Entonces, básicamente tenemos que con Application tendríamos igual. Utilizamos ESBuild y Byte. En algunos casos, pero digamos que el empaquetador principal sigue siendo ESBuild. Podemos renderizar aplicaciones del servidor y también va a ser el render del lado del cliente. Y si nosotros queremos sacar mucho provecho al lado del servidor, como Hydration y otras cosas, pues este es el builder que vamos a empezar a utilizar por defecto. Es más, se dice que en la versión 18 va a venir Application por defecto, este builder por defecto y las aplicaciones van a ser Server Side Rendering por defecto. Esto porque es una tendencia en los frameworks. Normalmente, ahora casi que todos los frameworks Byte default, por ejemplo, Ness de React o Nux de Vue vienen ya listos para ser renderizados del lado del servidor. Entonces, Application viene precisamente como este builder para solucionar este espacio en el que Angular normalmente viene haciendo siempre el render del lado del cliente. Y este es el que deberíamos usar si queremos empezar a ser renderizado del lado del servidor. Sin embargo, es opcional. Es decir, puedes migrar. Hacer hacia Application, pero no tener Server Side Rendering. Porque recuerda que Application también podría generar las aplicaciones que se renderizan del lado del cliente. Y es más, podría ser un pre-render en ciertos hosting en específico. Aquí hay algo interesante y voy a dedicarle un video entero a Server Side Rendering utilizando este nuevo builder y utilizando por las ventajas de Server Side Rendering. Pero por ahora, simplemente hagámoslo a la migración. Tengo una aplicación y vamos a utilizar este nuevo builder. Veamos cómo sería. Lo primero que tengo es la siguiente. Es una aplicación típica que siempre utilizo para estos ejemplos de mostrar ventajas de Angular de cada versión. Y este sistema está construido con un builder en específico. Veamos el código y veamos cuál es. Para ver qué builder está utilizando tu aplicación tendrías que ir al AngularJson. Y por acá ves el builder que se está utilizando. Y literalmente aquí vemos que el builder que se está utilizando es el de browser. Es decir, que esta aplicación que tengo, que ya utiliza ventajas de la versión digital, es el de browser. Es decir, que esta aplicación que tengo, que ya utiliza ventajas de la versión digital, es el de browser. Y la versión 17, como el nuevo asentaxis, como los standalone component, etc. Sigue estando renderizada por el lado del cliente y con webpack. Entonces, fíjate que igual tú podrías utilizar cosas como la nueva asentaxis y utilizar este builder. De nuevo, este es el builder más típico que vas a encontrar en aplicaciones de Angular. Pero precisamente el equipo quiere que nos movamos hacia application. ¿Y cómo cambiamos? Pues literalmente, escribimos aquí el builder. Application. Ahí está. Application. Ahí está. Application. Y empezamos a tener algunas señales de algunas cosas que debemos cambiar. Esto lo hace automático, sobre todo porque está siguiendo un esquema. Y nos empieza a dar algunas señales de qué cosas deberíamos cambiar en este archivo para utilizar application. Entonces, por ejemplo, aquí nos dice que main ya no está permitido. También nos dice que los polyfiles deberían ser un array, etc. También nos dice que los polyfiles deberían ser un array, etc. Y aquí nos dice que si quieres más detalle de estos cambios, aunque de nuevo, realmente el... Aquí Visual Studio Code me dice exactamente cuáles son esos ajustes, pero si quieres ver la explicación en detalle, lo podemos ver en la documentación. Aquí en la documentación vamos a entrarnos a este apartado que dice esbuild. Y acá nos dice, mira, para nuevas aplicaciones por defecto va a estar application. Pero para aplicaciones existentes nos dice, pues cómo deberíamos usar cada paquete. Aquí si tú quieres utilizar browser y esbuild, te dice, sí, sí, sí, sí, sí, sí. Aquí si tú quieres utilizar browser y esbuild, te dice que solo lo cambies, por ejemplo, en el mismo archivo que estamos. Pero en nuestro caso que lo estamos cambiando a application, pues nos dice, hey, cambia de browser a application. Y un par de cambios. Por ejemplo, nos dice, mira, main debería ser renombrado como browser. Entonces, básicamente, hagamos ese renombramiento. Browser, ahí está, browser. Nos dice que los polyfiles deberían estar como un array. Entonces, esto lo ponemos como un array. Ahí está, lo ponemos como un array. Listo. Por acá tenemos otros buildup optimizer y de por sí son las otras dos señales que tenemos como de error. Vamos a ver qué pasa con estas. Por acá nos dice que builder optimizer debería ser removido porque esto ya está cubierto en la opción de optimización. Así que básicamente esto sobra. Y vendor short también nos dice que es removido. Así que listo, lo dejamos así. Literalmente, fíjate que esto solo es para... La configuración desde el lado de desarrollo. Por eso la optimización está en false. Cuando tú normalmente estás construyendo para producción, pues ya se habilitan estas opciones de optimización. Haciendo estos ajustes vamos a ejecutar un ng-serve, pero quiero que notes algo muy interesante. Y es, si tú estás utilizando el nuevo builder, que es application, vas a notar que el formato es un poquito diferente. Por ejemplo, aquí guardé un ng-serve utilizando el browser. Es decir, el sistema de buildup. Es decir, el sistema de building antiguo que sería del lado del cliente y con webpack. Fíjate aquí cómo presenta los archivos. Y por aquí como dice que ya tenemos un servidor de desarrollo que está escuchando en este puerto. Y por acá tenemos un tiempo. Si ya estás utilizando el nuevo, vas a tener este formato como un poco más limpio de los archivos. También tienes acá un tiempo que ya de pronto no está en milisegundos, que es un poquito difícil de leer. Sino que directamente lo da en segundos. Sería que se demoró 2.74 segundos. Y acá nos dicen qué puerto está corriendo. Y si pruebo la aplicación en este puerto, literalmente la aplicación sigue funcionando tal cual. Tengo mis productos, mi lista. Por acá tengo la forma de filtrar los productos, todos los productos, los de ropa, los de electrónica, etc. Literalmente tengo la forma de, o la aplicación sigue funcionando sin mayor inconveniente. Simplemente con hacer esos ajustes ya estamos utilizando el nuevo builder que recomienda Android. Ahora probemos con un ngBuild. Por ejemplo voy a construirlo. Pero también me guardé como un screenshot de cómo sería anteriormente. Entonces acá tenemos un ngBuild. Así normalmente genera el formato si estamos utilizando browser o browser.esbuild. Acá nos da unos tiempos. Por ejemplo esto es alrededor de 17 segundos. Pero miramos cómo ya lo genera en este nuevo formato. También tiene un formato más fácil de leer en cuanto a los tamaños y demás. Y aquí también nos dice que la aplicación es un builder. Y aquí también nos dice que la aplicación fue generada en 5.3 segundos. Entonces tenemos como estas diferencias tanto en formato como en tiempos. Otra gran diferencia es que normalmente cuando nosotros generábamos la aplicación teníamos una carpeta llamada this de distribution. De por si aquí guardé la antigua, this alt. Y luego teníamos el nombre de la aplicación. Que en este caso yo le coloqué CMS, un Content Manager System. Y aquí directamente encontramos el index HTML. Ya que esta aplicación fue generada por Webpack. Y normalmente es generada para que se renderice o se ejecute desde el lado del browser. Esto puede inferir porque al final, por ejemplo, cuando hacemos deployment. En este caso por ejemplo yo hago deployment en Fiverr Hosting. Le digo mira, los archivos, los documentos van a estar disponibles en esta carpeta. Ok, eso era en el builder anterior. Así que ya me puedo borrar esta carpeta. Delete, delete, delete. Esta, delete. Perfecto. Y con el nuevo builder que es application vamos a ver cómo queda. Realmente él ahora tiene una subcarpeta llamada browser. Esto qué nos quiere decir? Que cuando nosotros habilitemos server-side rendering. Va a haber una carpeta llamada server. Entonces vamos a tener ahora estas dos carpetas. Entonces en una subcarpeta llamada browser. Pues encontramos todos los chunks. Y pues el HTML. Esto sería pues ya la aplicación que construyó ESBuild. Para el cliente, para el client-side rendering. Y si nosotros habilitamos. El server-side rendering. Pues crearía otra carpetita llamada server. Entonces esto es importante porque al final. Si estabas apuntando tus archivos. Esperando a que construyera una carpeta. En donde están los archivos que vas a distribuir. Pues ahora tendrías que colocarle por ejemplo aquí. Browser. Porque es donde van a quedar los archivos del lado del cliente. Y listo. Eso porque pues al final si no tienes eso en cuenta. Pues que tus sistemas que hacen deployment. Estén apuntando a la carpeta incorrecta. Cuando hayas migrado hacia el builder application. Ok. Entonces basado en esos cambios. Voy a hacer un PR. Entonces aquí voy a ponerle. Migration to app builder. Listo. Voy a crear el pull request. Solo para resumir. Cuáles fueron los ajustes. Al final. No cambiamos nada de código. Lo único que hicimos fue cambiarle el builder. Literalmente. Utilizando application. Hicimos los ajustes en browser. Polyfiles. Y quitamos. Los dos. Atributos llamados build optimizer. Y vendor chunk. Eso lo quitamos porque ya no es necesario. Y en nuestro caso. O en mi caso en particular. Que yo hago deployment de esta aplicación. A FB Hosting. Le cambié el. Hacia donde está apuntando los archivos del lado del navegador. Es decir. Va a ser this. Cms. Browser. Entonces aquí. Yo ya podría hacer merge de esto. Vamos a hacer un merge. Y ver que la aplicación. Se despliega. Y ya está. Entonces aquí. Vamos a hacer un merge. Y aquí. Vamos a hacer un merge. Y aquí. Vamos a hacer un merge. Y aquí. Vamos a hacer un merge. Y vamos a hacer un merge. Entonces aquí. Vamos a hacer un merge. Y aquí. Vamos a hacer un merge. Y vamos a hacer un merge. Y vamos a hacer un merge. Pero antes de que el build. Se despliegue. Construya con el nuevo sistema de building. Por aquí ya está. Debería estar corriendo. Vamos a recargar. Ahí está. Ahí está corriendo. Y ver que no haya ningún problema. Al desplegar esta aplicación. Que ya utilizaría. El sistema de building. Recomendado por Angular. Que es el de. Application. En este momento. Ya terminó el proceso de building. Entonces ahora. Ya debería estar la aplicación. De forma productiva. Ahí está, la aplicación sigue funcionando, vamos a inspeccionar, aquí sigue inspeccionando o seguimos viendo que utiliza la versión 17.1.0 de Angular y la aplicación funciona sin mayor inconveniente. Ahí está, productos, ahí están los productos, podemos ver cómo podemos filtrar, etc. La aplicación sigue funcionando sin mayor problema. Angular compartió estadísticas en la cual comparan los tiempos utilizando el sistema de Build y Legacy contra el de Application y podemos ver mejoras bastante significativas en que utilizando Application, corriendo tareas como un ng-serv o un ng-build, mejoran bastante. Y estas pruebas fueron ejecutadas en aplicaciones de grandes dimensiones, como por ejemplo, aplicaciones que tienen unos 100 componentes, 200 componentes, 5 componentes, y aún así los tiempos son bastante buenos. Y recuerda que Application fue literalmente reescrito para tener un mejor sistema de building de construcción basado en byte y sbuild y un montón de optimizaciones para que ya quede casi listo para habilitar el server-side rendering. Y esa sería la pregunta, si ya tenemos Application y ya estamos al menos generando la aplicación del lado del cliente, ¿en qué casos deberíamos manejar la aplicación y habilitar el server-side rendering? Esa es una discusión bastante interesante, realmente depende mucho de tu caso de negocio que estás buscando en tu aplicación. Pero normalmente, habilitando server-side rendering se ganan dos cosas. Performance en la carga, o sea, en la primera carga hacia tu usuario, pues básicamente habilitar server-side rendering hace que esto sea más rápido y también mejora el posicionamiento en buscadores. Entonces, si esas dos características son vitales para ti, pues uno podría optar por habilitar el server-side rendering. Ahora, casos en que de pronto no. Literalmente, cuando los tiempos de carga ya son buenos, así sea. Desde el lado del cliente son buenos. Normalmente porque, por ejemplo, aplicaciones de tipo de administración, que tienen gráficas, todo ese tipo de cosas como dashboards, normalmente se abren en, como en la compañía, en una empresa que está limitada precisamente a los usuarios de esa compañía y normalmente tienen un ambiente bien configurado. Digamos que una buena laptop, un buen computador, en donde la gente, vendedores, administradores, abren esa aplicación normalmente desde ese tipo de dispositivos. Entonces, como que es un ambiente un poco controlado y no se han tenido problemas de rendimiento, entonces podemos seguir optando por la parte del lado del cliente. Pero, por ejemplo, un caso en el que se podría habilitar server-side rendering y tiene bastantes beneficios es una aplicación en la cual tendríamos el público de masas. Es decir, ya no es una empresa con ciertos determinados usuarios y con cierto ambiente en el que normalmente abren estas aplicaciones, sino es el público en general. En la cual, pues, el público en general. Tiene diferentes dispositivos, yo no sé en qué conexión se esté conectando o qué tipo de dispositivo se esté conectando. Entonces, allí, si es un e-commerce en donde los usuarios van a ingresar o una aplicación en donde yo quiero capturar la mayor parte de usuarios posible, pues los tiempos de carga deberían ser mucho más óptimos y también debería estar optimizado para que los motores de búsqueda como Google o como Bing o cualquier otro, pues pueda buscar el contenido que yo le estoy ofreciendo. En ese caso, entonces, sería... Una gran ventaja utilizar o habilitar server-side rendering. Sin embargo, depende, depende de muchas cosas. Literalmente, ahorita es casi una tendencia que por defecto se haga server-side rendering. Es decir, no nos quebramos mucho la cabeza pensando en eso, sino que por defecto ya hace server-side rendering. Eso normalmente Angular lo va a habilitar en la versión 18. Que por defecto ya venga server-side rendering habilitado. Y cuando se levante la aplicación ya está renderizada del lado del servidor. Y se hace... Para que se vuelva interactiva del lado del cliente. En fin, es un tema bastante interesante que voy a hablar en un video en específico. Pero como ya habilitamos y utilizamos el nuevo Builder Application, pues podemos empezar a jugar con estas habilidades que te comento de server-side rendering. Así que, no siendo más, recuerda suscribirte a este canal, ve los videos aquí que te está sugiriendo YouTube con su inteligencia artificial de recomendaciones. Y dime precisamente en los comentarios qué preguntas. Tienes acerca de server-side rendering. Y qué quisieras ver en ese video que voy a publicar hablando de esto en específico con Angular.