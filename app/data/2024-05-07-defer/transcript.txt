 Hola, te voy a enseñar cómo hacer tablas responsive y en el proceso cómo hacer tu aplicación más rápida salvando algunos bytes utilizando el Differ View de Angular. Así que veamos de qué trata y empecemos. Supongo que tienes este tipo de vista que normalmente es muy común en los Dashboard o aplicaciones que normalmente administran cosas. Tenemos una tabla con los elementos, acciones para editar, etc. Pero también quieres darle gran soporte mobile, es decir, que los usuarios también puedan ingresar y hacer estas acciones desde el dispositivo móvil. Aquí básicamente lo que quisiéramos es transformar y que la versión móvil no muestre una tabla, sino que muestre como una lista con cards. Eso es lo que vamos a lograr y vamos a ver cómo va a ser el proceso. Realmente hay diferentes tipos de técnicas para lograr como tablas responsive. Por ejemplo, está esta en la que simplemente tenemos la tabla y como con un scroll horizontal, vamos navegando la información. Hay diferentes técnicas. La que yo voy a usar es como la más simple y es hacerlo desde un modo de transformación. Es decir, por ejemplo, tenemos una tabla con sus columnas y filas, pero ya en modo mobile lo que hacemos es tener como los bloques divididos como en grupos. En mi caso lo voy a hacer con cards. Bien, y al final, esta es la manera como más sencilla, porque normalmente cuando tenemos que crear tablas responsive, tenemos que usar mucho código para que eso se logre, pero básicamente esta es la forma más sencilla, porque precisamente al tener como dos interfaces o dos vistas diferentes, podemos simplemente separarlo en dos componentes y ya. Entonces básicamente todo se va a basar en esta, en esta condición. Literalmente, si la aplicación se está ejecutando en mobile, entonces vamos a mostrar como un componente que es como la lista, pero si no, entonces simplemente mostramos la tabla. Bien, esa va a ser la forma. Y vamos a ver cómo vamos a hacer esa condicional y cómo utilizando el nuevo sintaxis, el nuevo bloque de Tiffer, vamos a ahorrar un montón de bytes, precisamente dependiendo de qué componente cargar de acuerdo a si es móvil o no. Así que vamos al código. Acá ya estamos en la aplicación y fíjense, aquí ya estamos en la aplicación en donde pues tengo una tabla típica y si nosotros vamos a inspeccionarlo y de pronto hacemos algo de tipo mobile, es decir, queremos ver cómo se ve en el dispositivo móvil. En este momento básicamente hay un mal responsive. Si nuestra aplicación llega a ser abierta desde un mobile, pues si tiene aquí como el menú lateral, pero realmente cuando se renderiza la tabla, pues vemos que genera un scroll y pues ya daña el header y realmente no es una gran forma de visualizar nuestra tabla o nuestros productos en forma mobile. Así que precisamente vamos a ver cuál sería el objetivo y cómo lo podríamos, precisamente, arreglar. Si voy al componente que renderizará lista, pues acá tenemos, por ejemplo, el toolbar, por acá tenemos la barra de progreso, también tenemos un cart, pero aquí si te fijas es donde tenemos un componente aparte que realmente es la tabla, o sea, como que el otro es sólo como el layout, donde está el toolbar, como en donde se va a mostrar, pero luego hay un componente en específico que es la tabla per se y tiene un input que recibe la lista de productos. Si nosotros miramos, la lista de productos al final se recibe aquí con este get, básicamente se le hace una petición a la API y por ende obtenemos la lista de productos y listo. Y pues una vez tenemos la lista de productos, se la enviamos por medio de este input y si vamos a ver esa tablita, o bueno, ese componente, esa tabla o ese componente al final lo que tiene es la incorporación del map table module, que es lo que estoy usando precisamente para hacer el render de las tablas, y pues ya su lógica de HTML, es pues literalmente utilizar los componentes de Angular Material para renderizar la tabla. Sin embargo, como vamos a utilizar la forma de transformación, es decir, si es en mobile debería mostrar la lista de cards, pero si es de stock o tablet, pues vamos a mostrar precisamente esta tablita o esta interfaz. Aquí lo que hacemos es que vamos a crear otro componente. Aquí ya lo tengo listo porque realmente el código no es tan complejo, pero fíjate que algo que tiene en común es que los dos van a recibir la lista de productos y ya, y lo que cambia es en cómo se muestra. Entonces aquí por ejemplo igual, recibe la lista de productos y el HTML es un for y básicamente en vez de ahora renderizarlo como una tabla, pues se renderiza como una lista de tarjetitas. Ya con sus imágenes y demás. Listo. Entonces lo único que aquí realmente importa es decidir, porque aquí, pues básicamente vamos a llamar a la tabla de los paréntesis, que es un tablero, entonces aquí realmente importa es decidir, porque aquí, pues básicamente vamos a llamar a la tabla de los paréntesis, que es un tablero, a el componente de lista vamos a ver si ya lo tengo importado por acá acá está list component solo que no lo hemos utilizado entonces básicamente lo que tendríamos que decidir es cuando carga cada componente porque básicamente si yo comento esta tabla y veo mi aplicación en ese momento ya estoy cargando el componente que simplemente renderiza esos productos en forma de una lista de cards obviamente aquí ya funciona pero pues si yo ya lo veo como en de stock pues ya no se ve tan chévere como pues como nuestra vista de tablas porque al final lo que tenemos es esos dos simples componentes una en forma de tabla y una en forma de listas y los dos reciben la lista de productos entonces esa es como la forma una metodología ahora sólo nos toca es decidir cuándo carga y luego optimizarla con el de fer view pero aquí es donde vamos a utilizar una de las ayudas del angular cdk para saber cuándo es mobile o no entonces vamos a importarlo entonces vamos a ir aquí a los imports y vamos a utilizar una utilidad que precisamente viene del angular cdk por acá vemos el angular cdk el recordemos que el angular cdk es una serie de utilidades sin interfaz gráfica es decir es agnóstico realmente si estás utilizando angular material o no el angular cdk está agnóstico a la apariencia visual que tú tengas puedes tener tailwind puedes tener otro tipo de interfaz pero esta serie de utilidades del cdk es agnóstico entonces por ejemplo acá tenemos una utilidad que voy a utilizar creo que acá es sdk layout el que necesito entonces aquí sdk layout voy a importarme un brain point para observar y luego ellos tienen definidos unos brain points en específico que me muestran dos champullos aquí que le Santé muchas veces que elorno sería una concentración general hypósica o es axis de motor o sea que caseco o f1 que sea que sonardı como figura dentro del proceso o a punto numérica un fandom no me adelantaré mucho si usted está probando alguna qué es un bicyklet ahora queremos utilizar ese data lb de registro de determinación de la inteligencia que hoy conozco este verano tras las siete en esta últimaline y vamos a依ください ni bajкое control está de 2 para 제가 del acción de la banget guardba voy acommando de dist Lee wow la siguiente, vamos a tener un inject y voy a poner a este breakpoint observer, realmente este no va a ser el observador per se, este se lo está haciendo como el servicio, la inyección de dependencias y luego si vamos a tener nuestro observador, entonces vamos a definir el observador, ¿cuál es ese observador? pues ese observador lo vamos a llamar isMobile, vamos a ahora sí ponerle signo pesos porque este sí va a ser el observador y vamos a decir que de breakpoint observer vamos a estar como observando, valga la redundancia, pues cuál breakpoint va a cambiar, entonces aquí por ejemplo le voy a poner, mira, de por si hay varios, mira, es handset, large, small, web, web portrait, xsmall, yo voy a elegir small, o sea para small, ¿qué significa? significa que los breakpoints son o hacen match precisamente con una pantalla pequeña, entonces si eso es verdad, entonces aquí voy a operar eso con un pipe porque al final es un observable y pues simplemente quiero cambiar eso a un true o false, entonces voy a hacer un map, de acuerdo a ese map, déjame, voy a organizar esto un poquito más para que se vea un poco mejor de lo que estoy haciendo, entonces este map recordemos que viene rxjs, vamos a hacer un map, vamos a hacer un map, vamos a hacer un map, vamos a hacer un map, vamos a traerlo de rxjs, si es que no me lo trae automáticamente de los operadores, ahí está, me lo trajo de los operadores de rxjs y entonces acá tenemos pues básicamente el resultado y si ese resultado, fíjate que aquí nos trae precisamente si hace match o no, entonces si eso es un true, pues básicamente esto va a ser pues un booleano, listo, el único lío aquí es que este is mobile es un observable y yo quisiera algo más como, pues realmente lo podríamos utilizar con un assign pipe, pero pues ya que tenemos signals dentro del ecosistema de Angular, pues vamos a utilizar, convertir este observable en una señal y allí es donde utilizaríamos is mobile, solo que sin el signo pesos y le digo que quiero to signal, to signal me va a servir para convertir un observable en una señal, eso viene dentro del paquete de Angular, ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ¿qué es lo que va a hacer? ejecutando el componente de list, si no pues el componente de table, pero si lo que ocurre es que hay un peso, un JS que está yendo al mismo, a la misma página, vamos a verlo para que lo veamos un poco más claro, entonces vamos a ejecutar por ejemplo un ngBuild y ver cuáles son los componentes que se están renderizando y cuánto están pesando, entonces realmente nuestro componente, products component, este es el componente que al final tiene el if, aquí tenemos que estar muy pendientes de eso, entonces por acá vemos que el rowSide es de 7.73 y bueno, y ya el estimado transferido sería este 2.47, pero fijémonos en esto, 7.73 es lo que pesa nuestro componente y en ese componente están listos, los dos, el peso tanto de la lista, tanto de la tabla, puede que no se estén ejecutando y estamos ahorrando como performance en runtime, realmente no estoy ejecutando los dos componentes al mismo tiempo, se detecta, pero al final lo que sí se está yendo en conjunto es el peso del componente, es decir, acá tenemos literalmente el peso del componente, lo que pesa el appList, tanto lo que pesa el appTable y gracias al differBlock podemos hacer carga diferida y realmente no hay problema, no hay problema, no hay problema, no hay problema, no hay problema, no hay problema, no hay problema, no hay problema, no hay problema, simplemente hacer un chunk, partir eso y realmente que se cargue cada componente cuando sea necesario, así que vamos al código y veamos cómo lo aplicaríamos. El cambio realmente no es mucho, el cambio simplemente es poner acá y decirle que este componente se va a cargar de forma diferida, es decir, no debería ser incluido dentro del bundle side de nuestro products component, sino que sólo cuando realmente este bloque se ejecute, ese componente va a cargarse, entonces aquí estoy utilizando el differ y listo, y ya con esto deberíamos tener una mejora bastante interesante en rendimiento, ¿qué logramos acá? Logramos primero que realmente este componente appList sólo se ejecute si realmente es mobile y segundo con la carga diferida sólo se va a cargar si realmente está en ese ambiente, o sea el JS sólo se va... a cargar sí y sólo sí, pues esa condición se cumple. El differ tiene bastantes condiciones, uno le puede poner aquí que se cargue inmediatamente, que se cargue de acuerdo a algo, de acuerdo por ejemplo también al scroll, etcétera, pero por ahorita si lo dejo así, significa que simplemente se va a cargar inmediatamente si la condición se cumple. Ahora, veamos precisamente si hacemos un ngField, cuáles serían los beneficios en rendimiento en el peso de nuestro JavaScript. Entonces ahora fijémonos muy bien, ahora si hacemos un ngField, veamos que products que pesaba 7.70 y algo, 7. algo, ahora ya no pesa eso, pesa 4. kilobytes, recordemos que estaba como en los 7.7 algo. Ok, products component ahora es más liviano, sólo pesa 4 porque ya no tiene el peso de appList y el appTable. Esos dos componentes fueron... Son ahora chunks, son pedacitos chiquitos, acá está table component y por acá está list component. Y ahora, table component sólo pesa lo que debería pesar, sólo él, como es tan alone, como él solito, pesa 13.15 y list component pesa 1.54. ¿Qué quiere decir? Y esto tiene sentido, porque al final el table component tiene más cosas, pues nosotros al final en table component, si nosotros miramos table component... Pues tiene, importa el matTableModule y un matBurdenModule, bueno, y normalmente matTableModule, que es lo que utilizamos de material para renderizar nuestra tabla, pues es un poquito más pesado que, por ejemplo, el componente que simplemente es una renderizada de cards, del componente cards. Entonces aquí list component es más liviano que table. Y ahora, como los dos están de forma separada, no están dentro de products component, realmente cada uno de estos componentes... Se va a cargar cuando sea necesario y cuando nuestro componente realmente lo necesita, que en este caso es cuando se cumpla la condicional. Entonces veamos que si se carga en mobile, pues pesaría o cargaría los 4.06 del componente per se, que ahí es donde está como el toolbar, el routing, etc. Y luego, si realmente está en mobile, pues carga el list component, pero si está en tablet o en desktop, pues va a cargar table component. Entonces aquí en mobile estaríamos... Haciendo una optimización de peso y de carga bastante interesante. También podríamos inspeccionar esos chunks que se cargan aquí con nuestros devtools. Aquí vemos cada uno de los chunks. Estos chunks que vas a ver aquí son un poco más pesados porque estoy en modo desarrollo. Pero recuerda que cuando haces ng-build, optimizas y comprimes mucho más para que sea más óptimo para producción. Pero fíjate, aquí se cargó products component. Este es el chunk, el js de products component. Y por aquí abajo tenemos ya el chunk que dice list component. Es decir, aquí sólo se cargó el componente que realmente necesitamos en esa vista. Ahora, si yo fuera a desktop, si estamos ahorita en desktop, que es nuestra tablita ya toda, pues aquí vemos que table component... Acá seguimos viendo nuestro products component, que está por acá. Este es product component con su peso. Pero por acá vemos que table component se cargó. Y simplemente entonces cada uno de los componentes ya se carga de forma dinámica de acuerdo al ambiente. Y toda esa optimización... Es gracias a la nueva sintaxis que ofrece Angular. Precisamente aquí tenemos el if para preguntar si sí o si no. Y de acuerdo a eso, pues entonces ejecutamos un defer de un componente. Recuerda que hacer un defer de un componente hay varias técnicas. Si tú lo dejas en vacío, simplemente significa que se carga automáticamente. O sea, si entras a ese bloque, lo cargas en automático. Pero recuerda que el que controla quién entra al bloque o no es nuestro if para saber si es mobile o no. Y si nosotros hacemos unos números, básicamente... La estadística ya de acuerdo a lo que teníamos, básicamente me da esto. Nosotros, si hubiéramos cargado, o sea, sin el defer, el componente products component sin hacer ese split, esa división de los dos componentes table y list, si no hiciéramos eso, pues básicamente en mobile o en desktop pesarían igual, porque no tienen ninguna optimización, que es 7.72 kilobytes. Eso es lo que pesaría en mobile. Es decir, ahí estamos incluyendo dentro de products component. Los dos componentes y su GIS. Pero si ya hacemos carga diferida y si solo evaluamos mobile, en mobile solo estaríamos ejecutando pues el componente, products component más list y eso nos dará una carga solo de 5.56. Entonces ahí estamos optimizando una carga bastante interesante de JavaScript. Estamos enviando menos JavaScript al usuario de acuerdo a si es mobile o no. Y por ende recuerda que si entre menos JavaScript, pues mucho más rápida tu aplicación, va a cargar más rápido, etc. Y en desktop hay una mejora chiquita porque al final seguimos utilizando el table component, pero pues hacemos una mejora de 7.24, lo bajamos un poquito más. Pero entonces ya tienes el control de cómo cargarlo de acuerdo a ese bloque. Y listo, básicamente para resumir, si nosotros viéramos esto en un formato de pull request, ¿cuáles fueron los cambios? Pues básicamente lo que hicimos fue, en vez de cargar app table, pues simplemente empezamos a incorporar y cargar componentes de acuerdo a los componentes. Y lo que hicimos fue, en vez de cargar app table, pues simplemente empezamos a incorporar y cargar componentes de acuerdo a los componentes. Y luego básicamente creamos este observable y también utilizamos signals para saber si está o no en mobile. Recuerda que acá utilizamos el Angular CDK layout, que es el que me da esta utilidad. Y recuerda que el CDK de Angular es agnóstico. Si tú estás utilizando Tailwind o algún otro sistema de diseño que no sea material, igual lo puedes utilizar porque viste que es una solo lógica. Es solo lógica para detectarlo. Y ya lo que tú utilizas en el render es otra cosa. Y aquí un pequeño cambio que hice de la API. Pero listo, que es simplemente donde se conectan los datos. Pero esta es la parte importante y con eso logramos una optimización, logramos responsive de tablas y ser mucho más óptimos en ambiente mobile o desktop. Y listo, eso ha sido todo por hoy. Recuerda suscribirte y precisamente en este vídeo quería enfocarme a un uso muy práctico del different view, que es parte de la nueva sintaxis de Angular y de las nuevas características. Que se ofrecen casi desde la Angular 16, 17. Básicamente está disponible, por ejemplo, hacer este tipo de differ, el differ block. Entonces si no lo estás usando, pues aquí ya viste una forma muy práctica de usarlo y de ahorrar bytes a tu usuario para que tu aplicación cargue mucho más rápido. Así que dale like, compártelo, déjame tus comentarios si sabías de esto, si sabías del differ block. Pero este uso práctico de ella te abrió de algún momento los ojos para ver cómo utilizarla. Y si la empiezas a utilizar gracias a este vídeo. Así que compártelo y nos vemos en la próxima. Suscríbete.