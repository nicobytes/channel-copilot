 En este video vas a aprender cómo manejar diferentes tipos de ambientes para tu proyecto en Angular. Esto se hace referencia a que, por ejemplo, si estás desarrollando tu aplicación en forma de desarrollo, hay algunas variables precisamente que quieres que, como estás en desarrollo, apunten hacia cierto lugar, hacia cierto lado o tengan cierta configuración. Por ejemplo, el caso más típico es una API. Entonces, si tú estás en una versión de desarrollo, normalmente quieres pegarle a una API a una dirección diferente para que esté también corriendo en tu local o alguna que, por ejemplo, estés trabajando, que no es directamente la de producción. Y viceversa, precisamente, si estás ya en producción, si compilas ya la aplicación para producción, necesitas que la API o esa variable apunte ya a la API de producción. Entonces, ¿cómo se maneja esto en Angular? Realmente, si ya tú trabajabas en Angular desde ciertas versiones anteriores, Angular tenía un... unos archivos que son environments, que precisamente servían para esto. Pero ciertas versiones en adelante ya no se incluyen. Y si me lo preguntas a mí personalmente, a mí me parece que sí deberían incluirlas en el... como en el inicio, en el bootstrap de la aplicación por defecto, porque me parecía una muy buena práctica. Mira, te muestro lo siguiente. Por ejemplo, yo acabo de iniciar este proyecto que se llama demo. Y aquí en ese demo no hay ningún archivo de configuración. Aquí, por ejemplo, hice la inicialización de un proyecto. Un proyecto en Angular sencillo, con CSS, con server-server en el inhabilitado, ya que esto está en la versión 17. Pero fíjate que aquí no hay ningún archivo de environments. Antes, en las versiones anteriores, sí venía, como en el inicio de la aplicación, un archivo para manejar los diferentes tipos de ambientes y ya no es incluido desde... como desde el momento cero. Tú tienes que habilitarlas. Y eso es precisamente lo que te voy a enseñar hoy. Cómo habilitarlas si es que tu proyecto no las tenía, aunque si tu proyecto ya es... pues ya venía desde versiones anteriores en Angular, muy seguramente tienes este archivo y vas a aprender precisamente de qué trata y de pronto un par de cosas más. Así que veamos el código. Ahora, veamos en dónde lo vamos a aplicar. Yo tengo este proyecto que es como la landing page de un e-commerce sencillo. Y si vemos hacia dónde apunta esta URL, entonces vamos a inspeccionar. Vamos a poner el browser hacia este lado. Y vamos a ver hacia dónde está enviando los requests. Entonces vamos a ir aquí al network. Vamos a ir aquí al network. Vamos a, por ejemplo, filtrar por http. Y aquí vemos que tenemos esta API. Esta es una API que yo tengo precisamente desplegada que se llama API.nicobytes.store.api. Esa es precisamente una API que tiene todos los productos. Pero aquí hay algo raro. Y es que normalmente si tú estás desarrollando en local y estás haciendo pruebas como edición, creación, pues no quieres afectar los datos de producción. Entonces normalmente tú corres también esa API en desarrollo o tu equipo te da una API exclusiva para hacer pruebas de desarrollo y tienes que apuntarlo a esa API de desarrollo. Precisamente para no modificar los ambientes o no perjudicar el ambiente de producción. ¿Cómo hacemos ese switch? Al final es una variable que debería cambiar dependiendo del ambiente. Entonces vamos a ver cómo hacerlo. Miremos dónde en el código se utiliza la API. Si miras este código, por ejemplo, vemos que acá está como de forma quemada. La API, es decir, acá está API.nicobytes.store.api. Y vamos y hacemos un fetch a los productos o hacemos el get de un producto. También lo podemos ir a ver en categorías. Por acá también, este es el servicio del carrito de compras. Estos dos servicios, el de category y products, son los que se están conectando a la API. Solo que tener esto así quemado en el código suele ser una mala práctica. Porque tú necesitas que esa variable sea dinámica, de acuerdo al ambiente que estás ejecutando. Así que veamos cómo hacerlo. Si vas directamente a la documentación y buscas ambientes, básicamente, vas a encontrar esta documentación donde te explican un poco acerca de cómo funciona y cómo puedes construir para diferentes ambientes. Y lo más interesante sería este código, ng-generate-environments. Vamos a ejecutarlo. Estando en la terminal, vamos a ejecutar ng-generate. Y vamos a copiar este environment para no tener errores de typo. Y los vamos a generar. Recuerda, si tu aplicación ya los tiene, no hay problema. Pero vamos a generar un ambiente más. Añadir un ambiente más al que normalmente viene en Angular por defecto. Y si no tienes ninguno, ninguno, pues precisamente aquí es donde vamos a generar el básico. Angular por defecto, para generar estas variables de ambiente, te genera una carpeta dentro del CRC, environments, y te genera dos ambientes de desarrollo. O dos ambientes en los que vas a trabajar. Uno que es el de producción y uno que es el de desarrollo. Esos son los que vienen por defecto. Y cada uno, cuando se habilita, precisamente en automático, eso ya lo hace Angular por detrás, en automático, cada vez que ejecutes ng-serve, se va a inyectar las variables de entorno de environment.development. Y si ya compilas, haces un ng-build, que normalmente ya es para producción, toma las variables que son environment.ts. Si después de ejecutar este código, vemos cuáles fueron los ajustes, básicamente vemos que en el angular.json, en el ambiente de development, se agregó este archivito, que es file replacement. Y el de production ya viene por defecto. Acá tenemos las configuraciones que se tienen. Abrámoslo por acá. Ahí está. Production es este, que tiene como esta configuración. Y en development, que básicamente lo que va a tomar es que se ejecuta el archivo environment, pero se sobrescribe por lo que haya en development. Luego vamos a agregar un tercero, para que veas un poco también que puedas tener un ambiente más. Pero el clásico, el clásico es tener un ambiente de desarrollo y el de producción. Ahora, ¿cómo se trabaja con estos archivos? Pues aquí es donde tú pones precisamente tus variables de entorno. Una sería, normalmente vienen en mayúscula, porque son constantes. Y allí es donde vamos a poner esas variables que van a ser dinámicas. Entonces, por ejemplo, mi variable dinámica va a ser la url de la API. Bien. Esta va a ser la de producción. Pero, ¿qué pasa si yo quiero desarrollar, obtener una API diferente cuando estoy desarrollando? Por ejemplo, en mi caso, vamos a correr la API, la estoy corriendo en local, en un localhost. Y en el puerto 8787. Localhost. Listo. Ahí estoy corriendo mi API de forma local. Entonces, lo que quiero es que este archivo de servicios, de service, tome esta variable de la API de forma dinámica. Si estoy ejecutando, si estoy en modo desarrollo, pues tome esta variable. Y si estoy en modo producción, tome ya la API que es para producción. Ok. Acá yo lo que te aconsejo es que tú puedes ir ya al servicio. Hay varias formas. Una es, por ejemplo, hacer un inject token. Pero por ahora vamos a hacer como lo más sencillo, que es simplemente importarlo. Entonces, vamos a hacer un import y... Vamos y... Resolvemos hasta donde estén los ambientes. Acá traemos a environment. No es que nos vamos a traer a environment development, que aquí está de por sí. No, nos traemos a environment. Y automáticamente Angular va a ser el replacement por el archivo que estemos ejecutando. Entonces, acá están las variables de entorno. Normalmente también se llama environment por acá. Y vamos a ver... Ahí está. Como no lo estoy utilizando, pues tengo ese error. Pero ahora vamos a utilizarla. Entonces, aquí, ¿qué es lo que cambiaría? Pues al final yo podría inyectar ya esta variable de forma dinámica. Y, por ejemplo, podría ir a environment.api.url. Y listo. Y automáticamente, entonces, si estoy en desarrollo, él va a ser el replacement. Y si estoy en producción, pues va a utilizar la de producción. Ahora, dependiendo de dónde tú estés manejando y cuántos folders tengas y qué tan grande sea tu aplicación, este... este... punto, punto, slash, punto, punto, slash, puede ser un poco complejo. Vamos al archivo tsconfig y vamos a colocar un shortimport más. En este caso, es muy similar a los que tenemos acá, solo que le decimos que es environment. Y ponemos la ruta. Entonces, vamos a ver en dónde está. Acá sería tal cual. Por acá. Recuerda que esto no está dentro de app. Está dentro de su propia carpeta llamada environment. Y lo dejamos de esta manera. Entonces, no importa desde dónde lo estés llamando, tú simplemente te ahorras el... como el punto, punto, punto, punto, sino simplemente ahora llamas a tu shortimport llamado amp. Y listo. Y ahí ya cargas el de environment. Listo. Entonces, teniendo en cuenta eso, vamos a ir ahora sí a products. Y ahora a inyectar en este punto la variable de ambiente, que sería la API. Que va a cambiar de forma dinámica de acuerdo a el ambiente. Entonces, tenemos acá... Vamos a poner acá. Listo. Aquí algo me está fallando. Ah, hice dos puntos. Listo. Entonces, mirémoslo. Miremos lo siguiente. Cuando nosotros vamos a compilar, vamos a hacer un ngServe. Aquí vamos a poner un ngServe. Él automáticamente toma la versión de desarrollo. Que recuerda que la versión de desarrollo apunta hacia localizaciones. Entonces, si yo inspecciono y veo hacia dónde está enviando el request, entonces, por ejemplo, por acá, vemos que está corriendo o está apuntando a mi localhost. Que realmente tiene razón, porque yo aquí tengo una aplicación en Node, que tiene la API desplegándose, que es esta. Entonces, si yo voy y le hago un request, por ejemplo, a los productos, pues acá tengo los productos, que son mi versión de desarrollo, que puedo jugar, editar, dañar, y luego, si yo hago un request, pues aquí tengo mi versión de desarrollo, que puedo jugar, editar, dañar, sin problema. Y mi aplicación, que también está en modo desarrollo, está pegándole hacia esa API. Y de forma dinámica estamos cambiando. Pero, ¿qué pasa cuando compiles para producción? ¿Hagas un ngBuild? Pues ya esa variable no va a apuntar a localhost, va a apuntar precisamente a la versión de producción, que sería ya la API de producción, que en este caso es una URL, que en este caso nuestra URL es... La versión de producción sería API de producción. Y aquí, en este caso, sería API, nicobytes.store. Esta API es la de producción. Ahora, ¿qué pasa si tú, por alguna razón, quieres hacer un ngServe, que normalmente apunta hacia la versión de desarrollo por defecto, sin hacer nada, igual apunta hacia esa versión? Pero, ¿qué pasaría si tú, igual, en la versión de desarrollo, quieres apuntar a tus variables de producción? Pues precisamente harías el comando ngServe, le das "-c", que sería configuration, y le dices, mira, yo sé que voy a ejecutar mi aplicación en modo desarrollo aquí en mi local, pero quiero que apuntes hacia las variables que están hacia producción. Recuerda que si tú no agregas el "-c production", por defecto, ngServe va en automático a tomar el archivo de environment.development. Pero en este caso estoy siendo explícito y le estoy diciendo que, por favor, configure y tome las de producción. Entonces vas a ver que, aún así, mi aplicación está corriendo en local, en el localhost 4200, va a apuntar a la versión o a la API, al archivo de producción, que en este caso tiene la API de producción. Veámoslo. Entonces aquí, por ejemplo, tenemos otra vez la API, entonces por acá yo estoy teniendo, pues, request, y fíjate que acá estamos apuntando a la API de producción, no es la API de desarrollo. ¿Por qué? Porque, pues, cambiamos de forma muy manual hacia dónde estamos corriendo, en este caso, hacia production. Entonces recuerda, ngServe, por defecto, va a apuntar hacia el environment.development. Y cuando hagas un ngField, que significa que es producción, pues automáticamente estas variables van a ser las que estén en tu archivo de producción. Entonces ya tenemos esta habilidad de tener un ambiente de desarrollo con una variable, con ciertas variables que apuntan a cierto lugar, y para producción, pues las que ya son productivas, valga la redundancia. ¿Qué cosas se pueden hacer aquí? ¿Qué cosas se puede poner aquí? Algo muy interesante es que normalmente se pueden crear backends, o tu equipo te puede crear precisamente backends que respondan solo para ambientes de prueba. Por ejemplo, yo he visto que aquí se pueden colocar las tokens o la configuración para un proyecto de prueba, de Fibers. Aquí entonces están las llaves, haces tu configuración de las llaves de Fibers, de la API, de una base de datos como Firestore, todo lo haces aquí, y para desarrollo tienes una con la cual puedes hacer, cubrir, hacer, hacer, hacer, hacer, hacer. Puedes jugar, puedes probar precisamente, y ver que todo funcione bien sin afectar como lo de producción, y ya en producción, luego ya tienes las llaves productivas, las que sí realmente son las que utilizan los usuarios. Entonces aquí puedes hacer este tipo de cosas. En cada una ya puedes colocar las variables que dependan al ambiente y cuidar precisamente de este tipo de cosas. De nuevo, lo más típico es hacia dónde estamos apuntando en producción. En una API y cualquier servicio externo que normalmente tenga una API, un token, etc. Entonces, si ya resumimos esto básicamente y vemos esto en un pull request, lo que hicimos fue en el archivo angular.json y con el comando ng generate environment, pues se crea este archivo o este replacement dentro de la versión de development, y luego empezamos a trabajar, bueno, creamos realmente también un short import para poder llamarlo de forma como directa, y empezamos a utilizar esas variables en donde queramos que sean dinámicas. Y listo, eso fue el tip por el video de hoy. Déjame en los comentarios si ya sabías cómo manejar estos ambientes. Normalmente si ya eres desarrollador como experimentado en Angular, esto ya venía por defecto y en los nuevos proyectos no sé por qué no viene. A mí me parece que era una excelente práctica desde el inicio, pero simplemente ya sabes igual cómo volverlo a habilitar con el comando ng generate environment. Dime si sabías desde este comando, si ya lo tenías habilitado, si ahora tienes, ahora lo vas a poder habilitar y vas a dejar de quemar esa variable directamente en tu código y ahora lo manejarías por ambientes que sería la buena práctica. Así que déjate tus comentarios, suscríbete, dale un like, compártelo, y nos vemos en la próxima.