 En esta ocasión te voy a enseñar cómo habilitar el server-side rendering a una aplicación que ya tenemos, que por sí ya está en Angular, pero pues es una single-page application, es decir, que sólo se renderiza desde el lado del cliente, pero queremos habilitar el renderizado desde el lado del servidor, así que vamos a hacer todo el proceso. ¿Cuál es el proyecto? Veámoslo. El proyecto es este, que por sí ya tiene un dominio propio, que se llama nicobytes.store. Nosotros podemos ver que cuando cargamos la aplicación, pues como que hay aquí un loading y hace un fetch directamente. Vamos a ver que si nosotros vamos a inspeccionar, vamos a ir aquí al network. Aquí básicamente vemos que cada vez que se hace una petición para filtrar de categoría, pues vamos y hacemos un request a una API. También vemos el detalle de un producto, tenemos aquí como un carrusel, y pues vemos aquí también que obtuvimos... obtuvimos el detalle del producto, pues con base a la API. Ok, pero esto quiero volverlo server-side rendering, es decir, quiero precisamente que esto venga renderizado del lado del servidor. Ahora, ¿por qué queremos habilitar server-side rendering? Básicamente esto depende mucho del proyecto, por ejemplo, para aplicaciones que son administrativas, que son tipo dashboard, formularios y pues que son más administrativas, yo igual podría seguir optando por una single-page application, pero en este caso, que es una aplicación que va... va hacia el público en general y que normalmente mi cliente final es el... cualquier persona en internet, normalmente se quiere que tu sitio esté indexado en motores de búsqueda como Google. Y los motores de búsqueda son muy malos indexando aplicaciones que tienen single-page application, es decir, que el render viene del lado del cliente. Entonces se prefiere que estas aplicaciones, el contenido se renderice del lado del servidor. ¿A qué me refiero con esto? Veamos, si tú, por ejemplo, estás en esta página, nicobets.store, y ves el contenido, acá podemos ver el contenido y podemos inspeccionarlo. Recuerda que al final esto es el navegador, pero un robot o un scrapper o un crawler de un motor de búsqueda, realmente no mira esto de forma visual, ve código HTML, esto. Entonces estos bots que están inspeccionando para indexar contenido, pues empiezan a ver este contenido. Pero realmente este contenido se formó de forma dinámica, se generó una vez llegó... hasta el navegador, no en el servidor. Quiere decir que esta página realmente está en vacío. Una vez llegó al cliente, se hizo la renderización. Puedes verlo de esta manera, si vas en vez de inspeccionar código, vas a ver código fuente de la página, vas a ver que aquí en el body, aquí puedes encontrar el body, vamos a hacer un poquito más de zoom, realmente es una aplicación en vacío, es una página en blanco, es una página que no tiene nada. Y esto es lo que ven los motores de Google. Ven los motores de búsqueda. Motores de búsqueda como Google, precisamente ven o inspeccionan el HTML de esta forma y indexan contenido para mostrar en motores. Entonces si yo quiero atrapar nuevos clientes, porque mis productos son productos en Bolivia para el verano, no sé. Y quiero que mis productos estén indexados, pues en esa zona, etcétera. Pues está muy mal que nuestro sitio esté aún renderizado en blanco. Aquí es donde vemos que el render desde el lado del servidor, y esto es lo que normalmente ven los crawlers, los robots estos que indexan contenido, pues al final para ellos nuestra página web es esto, nuestro contenido es esto. Y no hay contenido precisamente, ese es el problema. No hay meta tags que indexen y le den información a este motor de búsqueda para saber cuál es nuestro contenido. Y tampoco hay contenido per se, simplemente es una aplicación en vacío. ¿Por qué? Porque es una aplicación en vacío. Porque, pues precisamente, esta aplicación es una single page application en Angular. Quiere decir que sólo hasta que ya llega, pues hasta que este contenido como tal llega al cliente, una vez ya llega el cliente se renderiza del lado del cliente. Es decir, Angular empieza a hacer toda su magia para empezar a renderizar todo el contenido como una single page application. Pero sólo es hasta que llega al cliente. En el servidor sólo se genera esto. Y el problema es, precisamente que en el servidor pues la aplicación está en vacío y los motores de búsqueda lo que hacen es ver este archivo. Y pues como no hay nada, no hay mucho que puedan indexar. Precisamente eso es lo que vamos a cambiar. Nosotros necesitaríamos habilitar server-side rendering para que nuestra aplicación en Angular ya básicamente construya todo el contenido desde el lado del servidor. Eso no significa que tú pierdas todas las bondades que tiene Angular para que se comporte de forma interactiva desde el lado del cliente. Como que uno haga un clic, o algo así. Que haga un fetch. Ahí básicamente lo que hay es ya mucho trabajo en Angular para renderizar. Básicamente renderiza y pre... Como que pre-construye toda la aplicación desde el lado del servidor con Node o con un motor de JS. Lo construye, lo entrega ya renderizado precisamente para que motores de búsqueda vean que hay contenido. Y una vez que ya entregan ese contenido renderizado. Y ese contenido ya pre... Renderizado por el servidor. Llega al cliente. Lo que pasa es que hay un... Como un proceso que se llama hydration. Que básicamente es darle vida y ya volverlo interactivo. Entonces Angular dice, ah mira. Ya no tengo, ya no me enviaron algo en vacío desde el servidor. Sino que realmente ya tengo contenido. Contenido que ya puede ser indexado. Ya hay contenido. Y cuando llega el cliente pues ya le da vida. Y empezamos a hacer todo lo que nuestra aplicación hace. Hacer, no sé. Mandar un clic. Montar componentes de forma dinámica. Básicamente ese proceso de darle vida. Entre lo que se fue a renderizado del servidor. Y cuando lleva al cliente se llama hydration. Y vamos a habilitarlo. Ahora también hay otra ventaja. Y es que también al aplicar server server rendering. También puedes optimizar la carga. Es decir, que tu sitio se cargue más rápido. ¿Por qué? Porque ya se genera como una precarga desde el lado del servidor. Ya está como construido. A Angular le tocas hacer hydration. Que no es tan fácil. Pero es parte de desarrollar con un framework. Él hace hydration. Pero de cosas que ya están construidas. Entonces no le toca hacer todo el trabajo desde cero en el cliente. Eso es una buena bondad. Porque pues ya como que adelantamos un poco de trabajo. Ya es del servidor. Ahora, una desventaja es que normalmente en Angular. Estábamos acostumbrados a crear single page application. Y realmente no solo en Angular. Estábamos también acostumbrados en React y Vue. A generar single page applications. Pero ahora vienen frameworks como Next, como Nux. En donde ya vienen. Utilizados del lado del servidor. Y también tenemos que entonces cambiar los proveedores. En donde nosotros tenemos nuestras aplicaciones. Por ejemplo, algo muy común de una aplicación single page application. Es que como no necesitaba de servidor. Porque son solo archivos estáticos. HTML, JavaScript y CSS. Podríamos tener eso en un S3. Por ejemplo, de Amazon. Y ya. O por ejemplo, tener un Nginx. Para servir los archivos estáticos. Etcétera. Podemos tener diferentes proveedores. De contenido. De contenido estático. Un CDN. GitHub. Por ejemplo. GitHub Pages. GitHub Pages. Por ejemplo. Y un montón de proveedores que hay. Para servir archivos estáticos. Pero en esta ocasión. Si tú ya habilitas Server Side Rendering. Ya no necesitas ese tipo de proveedores. Como Fiber Hosting también. Que también es parte de servir esos archivos estáticos. Ahora sí necesitas un servidor real. Un servidor no de archivos estáticos. Sino realmente. Que corra Node. Porque literalmente necesita. Ejecutar todo ese. Como toda esa lógica. Desde un backend. Desde un servidor backend. Pues crear ese render. Desde el lado del servidor. Y luego. Pues cuando llegue al cliente. Se hace todo el proceso de Hydration. Pero sí necesitas cambiar de proveedor. A un proveedor realmente que tenga Node. En este caso. Por ejemplo. Si estás utilizando S3 de Amazon. Por ejemplo. Podrías ya cambiar a una función Amplify. O por ejemplo. Una estancia de Node. Etcétera. Ya toca empezar a ver. En dónde haríamos. El despliegue de una aplicación. Que ya no sólo es contenido estático. Sino realmente necesitamos. Que haya ejecución desde el lado del servidor. En esta primera parte. Del video. Voy simplemente a habilitar. Server Side Rendering. Y luego te voy a dar una opción muy interesante. En este caso. Cloudflare. Para desplegar tus aplicaciones. Ya te mostré por ejemplo. Si ves en mi canal. Una alternativa en Cloudflare Pages. Para desplegar sitios estáticos. Como una Single Page Application. Pero también se puede desplegar. Servers Side Rendering. Pero hay que hacer un poquito más de truquitos. Y cositas para que funcione bien. Eso lo voy a dejar para otro video. Por ahora vamos a adelantar. Lo que es habilitar el Servers Side Rendering. Entonces vamos al código. Estando en el código. Lo único que vamos a hacer. Es como siempre. Ejecutar la magia de Angular. Y vamos a decirle. En GADD Angular. SCR. Servers Side Rendering. Este comando en automático. Va a transformar nuestra aplicación. A una aplicación. Rendirizada del lado del servidor. Ahora ya es nuestra labor. Ver entonces en donde ahora. Hacemos la distribución de esa aplicación. Como te decía. Escoger un proveedor en Node. Pero aquí básicamente lo que hace es. Varios cambios. Varios ajustes para que eso funcione. Vemos por ejemplo. Aquí el resultado. Vemos que ha creado un archivo. Que se llama. CRC Main Server. TypeScript. Ahí está. Es un archivo especial. Que va a correr en el servidor. Fíjate que también. Creo el config. Creo un server.ts. Y bueno. Otros ajustes. Vamos a verlos. Si vemos todo lo que hizo. Vamos a ver que. En el Angular.json. Agregó unos archivos. Para el server. Y hacer pre-render. También empezó a agregar. Unas dependencias. Como express. Porque necesitamos. Normalmente Angular. Se apoya en express. Para hacer el renderizado. Del lado del servidor. Que es como. Pues el motor normal. Para hacer backend. En JavaScript. Con Node. Vamos a ver. Que más agregó. Vamos aquí. Ver que agregó. Una nueva librería. Que se llama. Angular. Server Server Rendering. Y express. Como tal. Y acá otra. Que se llama. Platform Server. Vemos que creó un archivo. Este archivo. Es como el más. Interesante. Importante. Porque este archivo. Es el que normalmente. Desplegaríamos. Para. Ejecutar. Nuestro. Aplicación. Desde el lado. De una instancia. Con Node.js. Como literalmente. Correrla. En el lado del servidor. De por sí. Él debió agregar. Unos comandos. En el. Acá. Por ejemplo. Como ya. Ejecutar. Este renderizado. Del lado del servidor. Por ejemplo. Tenemos nuestros comandos. Normales. Pero si quisiéramos. Solo. Ver cómo se ejecuta. Desde el lado del servidor. Él nos creó. Un archivo. Para hacer. Como. Esa inspección. Luego vamos a ver. Este. Cuando. Que nos generó. Y bueno. Ya que creo. Otros archivos. Main. Punto. Server. Y aquí. Un config. Punto. Server. En donde empieza. A habilitar. Ciertas características. Para que el server. Ser rendering. Sea posible. Aquí también. Fíjate. Que incluyó. Un. Provide. Client. Hydration. Precisamente. Que es el que. Haría. Como. El mix. Que te comentaba. Entre. La aplicación. Que ya es renderizada. En el servidor. Y luego. Conectarla. Con la. El dinamismo. Y la interactividad. Que ya tenemos que tener. Cuando llegue. Al lado del cliente. Entonces. Agregó. Este. Provide. Client. Hydration. Y esta configuración. En especial. Etcétera. Ok. Entonces. Parece que ya con eso. Deberíamos. Tener nuestra aplicación. Algo también. Que te recomiendo. Es que ya utilices. El builder. Que es. El. De. Application. Aquí deberías utilizar. Application. Es el mejor builder. Ahorita. Para soportar. Este tipo de características. Si no. Si no sabes. De qué estoy hablando. Angular. Tiene. Diferente. Es builders. Uno con. Y es. Build. Browser. Y este. Que es el nuevo. En un video. En específico. Te voy a comentar. Que de por sí. Ya lo puedes encontrar. En mi canal. Para ir. Más a fondo. De qué trata esto. Si este comando. Mágico. Ya funcionó. Vamos a ver. Que todo. Funcione. Con un. Serp. Vamos a ver. Que todo. Se ejecute. Fíjate. Que cae. Como. Algún error. Al parecer. No encuentra. Express. Qué raro. Que no encuentre. Express. A ver. Vamos a quitarlo. Y. Algo. Que de pronto. Me puede ayudar. A solucionar. Este error. Sobre todo. Cuando. Después de correr. El comando. Que aplica. Service. Rendering. Es borrar. El node. Modules. Y reinstalarlo. Todo. Entonces. Vamos a borrar. Node. Modules. Y. Instalarlo. Aquí. Ya instalamos. Esto. Entonces. Vamos a volver. A correr. Nuestro comando. En. Y. A ver. Si sigue dando. Problemas. A ver. Si todavía. No encuentra. Express. Vamos a ver. Ahí está. Sigue dando. Algún tipo. De problemas. Eh. Inspeccionémoslo. Si miramos. El archivo. Server. Parece que este es el. Que no está. Como. Encontrando. Parece que. Hay algo. Que tenemos. Que habilitar. Que. Automáticamente. No habilito. El comando. Eh. Vamos a ver. Que es. Por acá. Vamos a ver. Si en el. Tttp. Aquí. Ya. Incluyó. Algunos archivos. Vamos a ver. Si dando. Ese comando. Que sugiere. Que es este. Vamos a ver. Que es decirle. Que permita. Allow. Este. Intact. Default. Import. Y vamos a ponerla. A ver. Que pasa. Porque algo. Está pasando. Con. Esa librería. Y es la que. No nos está. Funcionando. Entonces. Aquí vamos a ver. Los valores. Vamos a ponerle. True. A ver. Que pasa. Y. Vamos a ponerle. Server. Aquí ya no da el error. Entonces. Vamos a ver. Si ya compila. Entonces. Al agregar esa variable. Vamos a. Volver a. Ejecutar. Y ver. Si. Funciona. Vamos a ver. Que todo. Funciona bien. Listo. Al parecer. Funciona. Que raro. Que nos toque. Habilitar esto. Voy a andar un poco más. A fondo. En esto. Tal vez sea un bug. Del. NGDD. Normalmente. El debería esforzarse. En habilitar. También esta. Si. Si realmente. Necesita esto. Pues habilitarlo. Por defecto. Para no tener errores. Pero pues. Ya sabes. Si te enfrentas. Con el mismo error. Lo puedes hacer. O de pronto. Ya Angular. Solucione. El bug. O más que bug. Automáticamente. Normalmente. El comando. Puede agregar. Esta validación. Por ti. Así como. Él hizo ajustes. En el Angular. Gson. Creó archivos. Él también. Podría. Automáticamente. Habilitar esto. Si es que fuera necesario. Y en nuestro caso. Lo fue. Así que. Lo hicimos. De forma manual. Pero probablemente. Pues lo notificamos. Al equipo de Angular. Y veamos. Si. Lo ponen. En automático. Pero por ahora. Pues veamos. Que nuestra aplicación. Ya se ejecutó. Por acá. Fíjate que. Él ya tiene. Dos tipos de archivos. Uno que es. El browser. Y otro que es. El server. Vamos a ver. Cómo es. Nuestra aplicación. Se comporta. Entonces. Aquí. Ya se renderizó. Pero vamos a ver. Que si hacemos. Un inspeccionar. Vemos que todo. Se está renderizando. Igual. Se comporta. Igual. La aplicación. Dinámicamente. De forma interactiva. Sigue funcionando. Es decir. Yo aquí agrego. Productos al carrito. De compra. Y siguen habiendo. Elementos. Es más. Si hago. Una petición. Voy al network. Y voy. Literalmente. También. Se están yendo. Las peticiones. O sea. Funciona. Tal cual. Pero si nosotros. Vamos a ver. El código fuente. Ahora vamos a encontrar. Es que realmente. Hay contenido. En el body. Antes esto estaba. En vacío. Ahorita. Básicamente. Está. En una sola línea. Pero vamos a encontrar. Que todo el contenido. Ya fue renderizado. Del lado. De el servidor. Y es más. Creo que acá. Lo podemos decir. Ajuste. En la línea. Y aquí. Literalmente. Ahora. La app root. No viene en vacío. Aquí podemos encontrar. Que se hizo. Todo el renderizado. Acá está. Literalmente. Todo el contenido. Que se renderiza. Desde el lado. Del servidor. Qué quiere decir. Que precisamente. Cuando la aplicación. Cuando estos motores. De búsqueda. Ya. Quieran ver. Qué. Qué hay. En nuestro sitio. Qué hay. En nuestra URL. Van a encontrar. Contenido. Van a decir. Ah mira. Hay categorías. Hay productos. Por acá. De por sí. Deben estar los productos. Las imágenes. De los productos. Etcétera. Está comprimido. Pero hay contenido. Y por acá. Tenemos de por sí. Algo muy interesante. Que es el estado. De la aplicación. En el cual. Luego me imagino. Que hace el proceso. De hydration. Para ya. Volverlo interactivo. Desde el cliente. Pero fíjate. Que ya es. Contenido. Que es dinámico. Y esto. No sólo. Para la ruta principal. Qué pasa. Si nosotros. Entramos. A una ruta. Por ejemplo. El detalle. De un producto. Este. El detalle. De un producto. Por ejemplo. Debe tener. El carrusel. El botón. A tu car. Etcétera. Si vamos a ver. El código. Pues vamos a ver. Que esto. Sigue funcionando. Aquí también. Puedo agregar. Un carrito. Pues al. A un producto. El carrito. De compras. Pero vamos a ver. El código fuente. Vamos a. Darle un poquito. De zoom. Hacer un ajuste. De línea. Y vamos a encontrar. Que el contenido. Del producto. Por ejemplo. Este. Vamos a buscar. El título. Vamos a buscarlo. Ahí está. El contenido. Por acá. Está la imagen. Por acá. De por sí. Debe estar en un H1. Acá está el H1. Por acá. Está el H1. Acá se cierra un H1. Acá está. Aquí se abre el otro H1. Aquí está el párrafo. Con la descripción. El precio. El botón. Debe estar por acá. Aquí está el botón. Fíjate acá. El botón. Agregar al carrito. De compras. En fin. Todo este contenido. Ya fue. Renderizado. Del lado del servidor. Por ende. Si. Si. Algún. Motor. De búsqueda. Va a indexar. Nuestro contenido. Pues básicamente. Va a encontrar. Texto. Va a encontrar. Cosas. Antes. Donde no encontraba. Nada. Encontraba cero. Y básicamente. El render. Lo hacía el cliente. Ahora. Estamos haciendo este. Render. Desde el lado del servidor. El servidor. Un servidor. Con express. En node. Le entrega esto ya. Pre renderizado. Listo. Al cliente. El cliente. Luego ya. Con el proceso. De hydration. Lo vuelve. Como. Le da como vida. Para que ya. Se. Pues haga. Todas las cosas. Interactivas. Para lo. Que nosotros. Habíamos programado. Nuestra aplicación. Y solo. Conviendo. Este comando. Y listo. Fíjate que al final. No fue tan complejo. Obviamente. Mi aplicación. Es chiquitica. Muy pequeña. Pero me servía. Precisamente. Para. Asesorar. Y ver. Cómo es. Que nosotros. Con este comando. Mágico. Ya podemos habilitar. Servers. Recuerda que con eso. Puedes. Obtener. Mejor resultados. En motores de búsqueda. Y segundo. También empezar. A optimizar. Tiempos de carga. Y vas a ver. Que hay otras características. Que vamos a poder. Empezar a implementar. Gracias al renderizado. Del lado del servidor. Por ejemplo. Hacer meta tags. Dinámicos. Hacer links. Que se puedan compartir. En redes sociales. Y generen un preview. Que eso se llama. Los open graph. Los open graph. Y ver. Que nuestro sitio. En angular. Genere. Estos open graph. Que esto. Solo se puede habilitar. Si nuestro. Nuestra aplicación. Es renderizada. Del lado del servidor. Ya tenemos la base. Ahora. Hay algunas preguntas. Ok. Por ejemplo. Que hacemos con. Por ejemplo. APIs. Que se consumen. Desde el lado del cliente. Una fácil es. Navigation. Navigation. Punto. Localization. Punto. Local storage. Todas esas APIs. Vienen del lado. De el. Del. Del navegador. Es decir. Solo tienen. Existencia. Prioridad. Solo van a existir. Desde el lado del navegador. Una API. Como. Geolocal. Localization. Como local storage. No está en node. No tiene sentido en node. Angular. Normalmente. Ya detecta esto. Y saben. Donde correr. Cierto valor. Pero. Voy a hacer un video. Un poquito más. Específico. Hablando de cómo. Cómo resolver estos escenarios. Normalmente. Angular. Creó unos. Hooks. Precisamente. Para correr. Cierto código. Solo desde el lado del cliente. Y eso lo vamos a ir viendo. Aquí también. Hay que notar. Que cuando tú ya estás. Ejecutando. Te sale este alert. Con referencia. A HTTP client. ¿Qué significa esto? Significa lo siguiente. Que tu aplicación. Normalmente. Cuando está. En el lado del cliente. Vemos. Que una vez. Ya. Está como. Interactuando. Desde el lado del cliente. Vemos que él puede hacer. Una petición. Es más. Acá hay algo interesante. Y es que la petición. Como ya no la entrega. Renderizada. Desde el lado del servidor. No vemos que haga. Como un get. A la API. Eso es bastante interesante. Veamos acá. Acá se hizo. Como. Como ya está. Todo del lado. Del cliente. Pues empieza. A ser. Una petición. Interactiva. Desde el lado del cliente. Pero recuerda. Que acá. Estamos conectándonos. A esta API. Una vez. Se ejecute. Desde el lado del servidor. En Node. Desde el servidor. También tendría. Que conectarse. A esta API. Precisamente. Conectarse. A los datos. Generar ese render. Y todo ese pre-render. Es generado. Desde el lado del servidor. Quiere decir. Que desde el server. También se están haciendo. Peticiones. A la API. Y acá. Lo que nos recomiendan. Es que es mejor. Y cuando tenemos. Server. Server. Render. Nos toca habilitar. Una configuración. Para que las peticiones. Se hagan. Con la función. Fetch. Nativa. De Node. ¿Cómo lo activamos? Pues vamos. Precisamente. A nuestro código. Vamos a ir aquí. A. El app. Config. El principal. Aquí. Precisamente. En donde tenemos. El provide. HTTP. Client. Vamos a. Obtener. Y vamos a decirle. Que lo haga. Con Fetch. Es decir. Vamos a activar. Y lo vamos a poner aquí. With Fetch. Lo ejecutamos. Y ya. Esto es lo que necesita. Y con eso. Ya no tendríamos. Como este. Alert. Y nos aseguramos. Que cuando. La aplicación. Corra. Desde el lado del servidor. Desde un backend. Con Express. Y demás. Las peticiones. Se hagan con la función. Fetch. Nativa. De Node. Y con eso. Se obtienen los datos. Desde el lado del servidor. Ah. Y nos falta. El comando. Recuerda este comando. Serve. Server. Server. Store. Este ya sería. El. El archivo. De ejecución. Entonces. Si tú. Tienes algún. Servidor. En Node. Por ejemplo. Con Docker. En alguna instancia. De AWS. O en Google Cloud. Cualquier instancia. Normalmente. Deberías ejecutarla. Con este comando. Literalmente. Ese es el archivo. Y ese sería. El comando. Que normalmente. Se inicializa. Desde el lado del servidor. La aplicación. Entonces. Tienes que tener. Muy en cuenta. Esto. Lo podemos ejecutar. Ejecutemoslo. A ver qué pasa. Vamos a. Por acá. Realmente. Ahorita. Estamos. Ejecutándolo. Pero en modo. Desarrollo. Si quisiéramos. Ejecutarlo. Ya. En modo. Producción. Pues. Tendríamos que hacer. Una. NG Build. Él ya. Genera. Los archivos. Ya. Para. Pues. Para poder. Ejecutarlo. Aquí. Tienes que tener en cuenta. Que si estás. Utilizando. El. Builder. De. Application. Él va a generar. Dos. Folders. Uno. Que es el del browser. Todo lo que es dinámico. Interactivo. Y otro que es el server. Precisamente. Este de Node. Si tú ves. Apunta. Hacia el server. Y apunta. A este archivo. Que se llama. MJS. Que es Module. JS. Básicamente. Es una forma de. Programar. En forma modular. Con otra extensión. Pero fíjate. Que todo lo deja. En ese formato. Acá. Vamos a ver. Este server. Dónde está. Acá. Este es. Pues es un archivo. Comprimido. Etcétera. Y. Literalmente. Si tú tuvieras. Una instancia. O. Tienes. Noción. De cómo ejecutar. Una API. Por ejemplo. Es similar. Literalmente. Tienes que ir a tu instancia. De tu aplicación. De Node. Y entonces. Dejarías corriendo. La aplicación. Con ese comando. Con este comando. O al menos. Apuntado. Hacia ese archivo. Vamos a correrlo igual. Para ver. Que tenemos. Desde. Aquí. Entonces. Hacemos un clear. Ya hicimos el build. Entonces. Pegamos el comando. Sería. NPM. Run. Y al final. Lo que debería hacer. Es. Literal. Realmente. Está levantando. Un servidor. En express. Que se está escuchando. En el puerto. Cuatro mil. Que realmente. Pues lo que hace. Es renderizar. Nuestra aplicación. Ahora. Recuerda. Que aquí. Este servidor. De express. Ya está haciendo. Pues. El server. Server. Server. Ser rendering. Y envía. Los archivos. De browser. Para que. La aplicación. Sea interactiva. Básicamente. Este sería. Nuestro. Servidor. Ya productivo. Un servidor. En Node. Un servidor. Que hace. El server. Server. Rendering. Y que también. Deja nuestra aplicación. Interactiva. Desde el lado. De el cliente. Acá por ejemplo. Pues estamos. Pues ya teniendo. La aplicación. Interactiva. Vamos a darle clic. Ahí está. Y si nosotros. Vamos a ir. Le damos. Ver código fuente. Recuerda que. Tenemos. El renderizado. Con. El contenido. Entonces acá. Están los estilos. Y por acá. Debe estar el contenido. El texto. Bueno. Absolutamente. Todo lo que representa. Esta página. Pero. Pues ya. Rendizado. Desde el lado. Del servidor. Así que realmente. Este. Sería el comando. Que deberías ejecutar. En tu aplicación. Productiva. En una aplicación. En un entorno. De Node. En un entorno. De JavaScript. Sea una instancia. O cualquier. Otra índole. Que estés utilizando. Para correrlo. Pero ya. Desde el lado. Del servidor. El siguiente video. Sería. Cómo. Si ya tenemos. El server. Server. Rendering. Entonces. Cómo lo desplegamos. Y lo voy a desplegar. En Cloud4Pages. Pero. Haciendo las configuraciones. Necesarias. Para que funcione. Con server. Server. Rendering. Y con. Ya no contenido estático. Sino realmente. Un servidor. En Node. Así que recuerda. Suscribirte. Estar pendiente del canal. Darle like. Dejarme en los comentarios. Qué te pareció esta guía. Si realmente. Ya le ves utilidad. A aplicar. Server. Server. Rendering. O no. Recuerda que hay algunos casos. En donde no. Por ejemplo. En donde realmente. No necesites. Indexación. De motores. De búsqueda. Pues. Si no necesitas esto. Pues. Te podrías ahorrar eso. Y todavía. Dejarla como una. Single page. Application. Simplemente no habilitar. Server. Server. Rendering. Pero también. Si quieres manejar. Tener un poquito más. De rendimiento. En tu aplicación. Pues. Es una buena forma. Habilitar el server. Side. Rendering. Así que. Bueno. Déjame en los comentarios. Te espero en el siguiente video. Para que aprendamos. Mucho más. De este mundo. Con Angular. Así que. Hasta la próxima.