 Hoy te voy a enseñar cómo utilizar Signals Inputs de forma definitiva, te voy a enseñar ciertos trucos para poderlo utilizar y sobre todo que los Signals vienen a mejorar el performance de tu aplicación y también la legibilidad de código. Se vuelve un código más sencillo, más fácil de mantener, menos verbose. Recordemos un poco para qué son los Signals, es el nuevo modelo de reactividad de Angular y los Inputs. Por otro lado, es la forma en la que yo comunico componentes. Normalmente, por ejemplo, si yo tengo un componente y tengo su componente hijo, normalmente están en un modo árbol, porque cuando hacemos aplicaciones web lo hacemos bajo el DOM, el Document Object Model, que básicamente es un árbol de elementos. Y cuando yo quiero comunicar cierta información desde un padre al hijo, utilizo un Input. Entonces el hijo va a tener un Input para recibir esa información del padre. Y gracias a Angular ahora podemos hacerlo con Signals. Entonces vamos a ver de qué trata, cómo migrar de los Inputs clásicos a los Signals, y ver cuáles son las cosas que debemos tener en cuenta para trabajar con ellos. Así que veamos el código. Aquí tengo una aplicación bastante sencilla. Acá tengo un componente padre que tiene algunos elementos que voy a estar cambiando. Por ejemplo, tiene un nombre, una edad. Tengo una lista de productos, tengo 50 productos. Y acá tengo su componente hijo. En este componente hijo quiero enviarle ciertos datos, de por sí le estoy enviando ese primer nombre, una edad y el array de productos. Y por acá tengo luego una lista. Y aquí tengo la lista de productos que vamos a ir viendo de qué trata cada uno de estos ejemplos y cómo nos va a ayudar a entender los Signal Inputs. Veamos el código de esta aplicación. Para esta aplicación tengo tres sencillos componentes. El parent, que básicamente va a ser el papá, valga la redundancia, de dos componentes. Bueno, de varios, pero vamos a reutilizar uno para renderizar varios productos. Pero en definitiva, básicamente lo que tenemos aquí es un parent component, el cual tiene un article y tiene básicamente aquí tres artículos. Y el parent component es el que va a ser el primer producto. Entonces, el parent component es el que va a ser el primer producto. Entonces, el parent component es el que va a ser el primer producto. Entonces, tiene un first name, una edad, un array de productos. Ese array de productos como que lo lleno de una API. Entonces, literalmente traigo los datos y lo lleno. Es un array de unos 50 productos. Y aquí manualmente voy a agregar un producto de forma como directa al array. Acá podemos ver un poco ya el HTML. Entonces, tengo un input para el first name, un input para el edge name, un botón que lo que hace es agregar el producto. Y por ende, pues el array de productos debería crecer. Luego, aquí es donde yo tengo al hijo. Y el hijo, ese componente hijo, recibe ¿qué? Recibe tres inputs. El first name, la edad y el array de productos. Si yo veo nuestro shield component, que va a actuar como componente hijo, pues básicamente aquí eso yo lo recibo con el decorador de input. Y eso es lo que vamos a cambiar hoy y empezarlo a migrar a un signer input y ver cuáles son los beneficios y cosas que debo tener en cuenta. Sobre todo también cómo empezamos. A ver el patrón de reactividad. Empezamos a quitar ciertas cosas de Angular para hacerlo más sencillo y volverlo más reactivo con los signals, etcétera, etcétera. Y luego aquí tengo un array de, pues un componente que representaría como un producto y también recibe un input. Así que, pues veamos básicamente de qué tal de cómo vamos a ir a migrarlo. Entonces empecemos por ver que acá estas dos variables, el first name, acá tengo first name y tengo el edge. Estas dos variables son dos variables normales. De Angular de toda la vida. Y vamos a ver cómo nosotros la empezamos a enviar al hijo. Acá básicamente lo recibimos, lo recibe como input y se imprime. Ok, lo primero que tenemos que tener en cuenta aquí es cómo reacciona esto al cambio. Nosotros normalmente enviamos ese valor, lo imprimimos, acá se imprime, pero cómo nosotros podemos vigilar cada cambio. Cada vez que cambie ese valor, normalmente lo hacemos en Angular, con un ng on change. Entonces cada vez que este input cambie, voy a tener como los cambios en general del componente y dentro de eso, pues precisamente el first name. Veamos un momento en la consola. Entonces aquí yo tengo el first name y cada vez que lo cambio, pues debería estar enviándolo de forma reactiva al shield name, al componente hijo. Entonces voy a poner Nicolás Molina. Y ahí fíjate que lo va renderizando. Pero aquí también. También estamos recibiendo varios cambios. ¿Cuál es el problema de pronto con el ng on change o de vigilar esos cambios de esta manera? Que el aquí estos cambios son generales, o sea, no son como granulares específicos. No es que si sólo cambia el first name me dice, o sea, si me dice que sólo cambia ese elemento, pero como que lo obtienen todo un objeto, entonces toca empezar a buscarlo. ¿A qué me refiero? Por ejemplo, si yo cambio la edad, entonces fíjate que acá ahora dentro de ese objeto tengo age. Entonces, ¿qué nos toca? Mirar, nos tocaba antes empezar a hacer preguntas como ok, el cambio que viene, digamos change, dentro de esos cambios hay un cambio en first name, por ejemplo. Entonces me tocaba como empezar a buscar si dentro de ese objeto viene un cambio dentro de first name. Y si eso es verdad, entonces yo puedo correr alguna lógica, por ejemplo, run logic. Voy a ponerlo literalmente. Entonces acá, roto completo y ahí está first name. Entonces si eso cambió, entonces yo quiero ejecutar esta lógica. Sólo si, sí, sólo si el first name cambió, pues corro el método run logic. Esta es la manera en que nosotros normalmente teníamos de vigilar cambios en los inputs. Entonces si yo tengo por acá Nicolás Molina, acá pues tengo la ejecución que sería lo que es este, pues este método de acá. Y si yo quisiera, vigilar sólo los cambios de la edad, pues tendría que ser algo similar. Entonces si cambia la edad, entonces corro pues alguna lógica referenciada que yo quiera, pues controlar, no? Eso sería la forma en como la forma de antes. Ahora vamos a ver cómo sería directamente con los signals. Entonces vamos a empezar a migrar esto a un signal, a un signal input. Entonces voy a poner aquí. En este caso, utilizaría input. Y esto viene directamente de angular core, entonces ya no es un decorador, es un método y con esto le estoy diciendo que yo voy a recibir eso como input y le puedo poner un valor inicial, pues que es normalmente pues un valor que viene por defecto. En este caso le voy a decir que es un string en vacío. Con esto yo puedo decir que esto es un y si lo miramos acá, esto es un input signal que es string. Si yo le pusiera. Un número por defecto, por ejemplo cero queda un sign, un input signal que es un nombre, entonces él ya infiere el tipado bien, vamos a cambiar este también la edad. Por un input. Y lo ponemos en cero y este productos también lo vamos a migrar, ya no va a ser eso. Sino que vamos a mirarlo a un input. Fíjate acá que como yo tengo una radio si realmente quiero. Que no solo sea una rai, sino sea una rai de que entonces acá yo le digo de productos, si no le hago esto y simplemente le dejo como una rai, pues me dice OK, es una rai con un tipo never que realmente no nos dice mucho, entonces yo lo que quiero hacer acá si es especificar el typing y le digo que por favor sea una rai de productos. Lo mismo puedo hacer acá, solo que ahí sí no me parece necesario, pero yo podría decirle OK, este es un nombre, es un y este también va a ser un string, por ejemplo. Bien y lo puedo dejar de esta manera aquí realmente, pues como ya lo asigné, voy a dejar el motor de inferencia de TypeScript y solo en este caso sí le voy a decir que es una rai de productos en específico. Haciendo eso ya también tenemos que hacer algunos ajustes, porque ahora si nosotros, por ejemplo, si solo hacemos esto no va a funcionar, veamos la aplicación. Entonces si yo hago esto, fíjate que ahora acá hay algo raro, si yo digo Nicolás Molina, primero parece que nos están comunicando. Ya no hay una comunicación. No hay una comunicación como tal y aquí me aparece como algo raro. ¿Por qué? Eso es porque básicamente los signups son como un contenedor de un valor y para obtener ese valor necesito suscribirme a ese signup. Para ello básicamente esto queda como un método que debemos ejecutar para podernos como suscribir a él y obtener su valor. En este caso entonces lo haríamos de esta manera, nos suscribimos a cada uno de ellos y si nosotros ahora vemos, pues básicamente, sigue funcionando sin mayor dificultad. Entonces por acá si yo digo Valentina, ahí tenemos la comunicación sin ningún problema y si yo cambio la edad y se agrega un producto, fíjate que acá se va, se va como literalmente aumentando. Todo bien, listo. Entonces esa es una forma fácil y sencilla de pasarlo, pero vamos a ver cosas que nosotros tenemos que tener en cuenta. Lo primero y algo muy interesante es que nosotros podemos. Esto también se puede hacer. Se puede hacer con los decoradores anteriormente, pero también podemos empezar a marcarlos como requeridos. ¿Qué significa este required? Que sí o sí este valor debe venir. Por ende, como siempre, como viene por defecto, no necesitamos inicializarlo. Entonces podríamos dejar de inicializarlo. Acá también no esperaríamos el array en vacío porque sí o sí debe venir ese valor. Esto de por sí era un problema porque antes si nosotros queríamos hacer esto de required en los inputs clásicos, lo podíamos marcar como required. Sin embargo, nos tocaba empezar a ver cómo inicializamos el valor o hacer ciertas cositas para no tener que para que TypeScript no me pide inicializar el valor. Vamos a ver, por ejemplo, un ejemplo acá. Por ejemplo, este es un input normal que recibe como todo el producto y acá yo quiero que venga, venga esa información, me lo envíen y para evitar que él me pida inicializarlo. Fíjate que acá está. Acá hay como un signo de interrogación. Si yo no se lo coloco, él me dice oye, necesito que me inicialices ese valor y yo como para escapar esa inicialización, pues simplemente le digo que no, que no quiero que se preocupe por él. Esto es como un truco chiquito que uno utilizaba en Angular para decirle oye, si quiero un input, no quiero inicializarlo porque yo espero que me lo envíen pues el padre. Entonces para ahorrarme ese valor inicial, lo que hacíamos es esto o inicializar el valor, que igual sería algo raro inicializar un producto. Y aquí tendríamos que como que llenarlo como con un producto con información falsa, como para que tenga algo y él me pues tenga un valor inicial mientras me envía, mientras el padre me envía ese valor. Entonces podríamos también resolverlo de esta manera, pero este me parece como la forma más conveniente. Entonces lo que normalmente hacíamos era simplemente utilizar este signo de pregunta que posiblemente lo hayas visto en varias librerías o en varios lugares como escapar esa inicialización. Ahora no necesitaríamos como. No estamos forzados a inicializarlo simplemente con marcar marcarlo como recuadro, pues el valor debe venir, o sea, no es que sea opcional, no es que tenga que inicializarlo, debe venir ese valor. Cosa muy interesante porque ya en el en el compilador en aquí, por ejemplo, si estás utilizando la extensión del angular, la web service automáticamente te va a detectar. Vamos a ver aquí, debería detectarme algún error. Vamos a ver si marqué todos como recuerdo que sí. Por ejemplo, aquí debería estar. Debe detectarme un valor, un error diciéndome oye, este apb child no está recibiendo un valor que es requerido, que es el fiel child. Vamos a ver por qué no vamos a ver si tengo la extensión habilitada angular. La web service. Si está habilitada, qué raro, si no me la muestra, debería mostrarla aquí ya por defecto, pero si no me la muestra, lo que sí debería hacer es mostrar un error en el compilador. Veamos, porque no debería dejarme compilar. Siquiera veamos en la consola me aparece algo aquí en la consola se me aparece. Debería ser un error algo de la extensión, pero al menos no me deja compilar y eso es bastante interesante porque entonces yo no puedo enviar esto a producción. No puedo no enviarle el valor, no puedo no enviarle el firs. Aquí me dice oye, hay un input que es requerido y hay un componente. Si el componente espera ese input y tú no se lo estás enviando y eso va a fallar en producción porque tú literalmente le dijiste al componente. Que esperabas ese valor, no ni siquiera lo inicializas con un valor porque literalmente esperas que se envíe. Entonces, pues bueno, si no te aparece el error aquí en la pues directamente como en el editor, pues simplemente debería aparecerte al momento de compilar aquí ya me deja compilar sin mayor dificultad. Ok, listo, entonces entendido eso tenemos ahora requerir sin ningún problema, no suscribimos y ya migramos esto a sign in inputs. Pero qué pasa con la lectura de cambios? Qué pasa con correr una lógica de negocio de acuerdo a si un input cambio o no? Veamos cómo esto sería en los sign in. Si te fijas bien, cada vez que cambiamos un valor, acá tenemos todavía como una impresión en terminal en la consola del navegador de esos valores, sólo que llegan como funciones porque es el grupper. Entonces vamos a cambiarlo, por ejemplo, acá si quiero el valor, entonces también debería no sólo suscribirme en el template. Sino también en mi lógica de mi componente, pues también debería suscribirme al valor. Entonces, por ejemplo, si yo digo Nicolás y cambio, fíjate que esto me sigue funcionando tal cual. Si yo hago este ajuste, me sigue funcionando. Esto es porque Angular es muy bueno haciendo retrocompatibilidad. Qué quiere decir que si yo lo migró, déjame ver, lo acomodo. Esto es browser, esto es código, browser, código, browser, código, perfecto, listo. Eso es porque Angular tiene retrocompatibilidad. Así nosotros migramos. Esto es un sign al input y nosotros estábamos leyendo cambios de esta manera. Él mantiene esa compatibilidad para que no se rompa nuestra aplicación. Entonces podríamos dejarlo todavía de esta manera. Pero si ya lo quieres hacer modo sign al, o sea, el estilo sign al, cómo realmente realmente leer estos cambios, pues nos ahorraríamos. Podríamos borrar estos engine change, dejar de preocuparnos como de esta manera de cómo leer los cambios y hacer esto. Y hacerlo más granular. Entonces ahora podríamos en el constructor. Simplemente poner un efecto que es un efecto, pues es una manera de vigilar precisamente los cambios de un sign. Entonces acá lo ponemos y por ejemplo, si yo quisiera que ejecutar una lógica, sí y sólo si el firsen cambia, entonces lo que hago es suscribirme a ese sign al dentro de una función llamada efecto. Entonces acá, por ejemplo, va a obtener el valor firsen es igual a esa suscripción. Y si esto cambia, entonces voy a ejecutar esa lógica de negocio. Entonces, por ejemplo, voy a ejecutar firsen, este run logic. Entonces podría, por ejemplo, ejecutar esto run logic. Aunque aquí ya hay una suscripción, entonces esta me va a valer. Entonces simplemente podría correr run logic. Y esto yo sé que sólo cambia si firs name. Tiene una suscripción. Básicamente la forma en la que esto corre es que si hay una suscripción dentro de ese efecto, pues ese método se va a correr. Vamos a ver si funciona. Entonces yo cambio acá a Nicolás Molina. Fíjate que sólo cambia cuando cambia ese valor en específico. Entonces si yo quiero tener otro efecto sólo para correr la lógica de la edad, entonces simplemente hago la suscripción o hago un efecto en donde en este método. Sólo me estoy suscribiendo a esa data. También podría hacer esto, pero. Pues acá estaría tendría un efecto con dos suscripciones, o sea, dentro de este efecto hay una suscripción a Edge y a Firsen. Entonces como que no correrían individualmente, sino que los dos están corriendo en simultáneo, digamos de alguna manera. Es mejor tener como cada uno de forma aparte y aquí básicamente para hacerlo más explícito. Lo que yo recomendaría es literalmente. Es literalmente. En el efecto tener como el valor como el nombre y de acuerdo al nombre o ya básicamente yo corro, por ejemplo, este run logic. Y lo podría cambiar como que recibo el valor. Esto es un string. Esto es un string y lo que hacemos es imprimir name. Listo, entonces de esta manera, casi que como que en el en el. Vamos a ver nombre, nombre. Esto es un no, qué raro que sea. Vamos a ver. No, no, no. Esto es interesante. Fíjate que acá me dice que no sabe qué es y tiene toda la razón, porque si bien lo cambiamos a requerido, no le dijimos qué typing es. Aquí sí ya sería necesario colocar el typing, porque como no lo estamos inicializando, él no puede inferir cuál valor es. Entonces aquí le puedo decir a tú eres un string y yo espero aquí también un nombre. Bien, acá sí se hace como necesario saber qué valor va a recibir, porque no lo estamos inicializando, entonces no lo puede inferir. Pero listo, aquí ya sabe que es un string. Listo y si yo quisiera, pues lo mismo para H. Acá tengo H y corro la lógica con ese valor. Listo y acá la recibo. Eso sería nombre y imprimo H. Listo. Perfecto. Entonces ahora tengo este como lectura de cambios de forma granular. Entonces, por ejemplo, esto debería seguir funcionando. Si yo hago cualquier ajuste. Entonces ahí está, pues el valor ajustado en forma de signer. Ahora bien, en YonChain será como la forma oficial y la más recomendada para leer cambios que venían, sobre todo cuando utilizábamos el decorador input. Entonces yo aquí ya te recomendaría utilizar el effect para leer de forma granular cada cambio. Entonces si algo cambia en FirstName, que sería ese input individual, pues con un effect puedes empezar a leerlo y correr alguna lógica en específico. Sin embargo, también había una forma que es un setter en el input a los que no nos gustaba. Por ejemplo, esto de recibir como todo el objeto y empezar a hacer un if para saber si vino o no el cambio. Esa no era como la forma más chévere, digamos, de hacerlo. Entonces una forma como granular de hacerlo con el como con la versión de input anterior es la siguiente. Acá no sé si habías visto de pronto lo habías visto de pronto en algunos otras bases de código. Que si uno quería tener un código. Como la lectura granular de un input, lo que hacía uno es listo, es decir, que vamos a tener un input, pero no es un input directo, sino va a ser un setter que tenía un nombre. Y entonces aquí recibíamos el valor. Entonces aquí es donde yo podría ejecutar cualquier lógica como run logic y pasar, por ejemplo, el nombre. Y esto me servía para hacer como esta detección granular, no tener que tener el engine change, sino por medio de un setter. Básicamente cada vez que se cambia ese valor ejecutaron alguna lógica, pero es algo verbose. Tocaba crear como igual una segunda variable porque el first en cada como setter y entonces en donde guardó el valor. Entonces normalmente empezamos a tener patrones de este estilo. Si tú tenías lecturas de cambios granulares con el engine change o con este forma, pues básicamente ya simplemente puedes borrar toda esta forma de hacerlo y ya queda súper específico con el efecto. Y sin duda. Sin ningún problema te va a funcionar y este sería como la forma reactiva de hacerlo. Ahora sigamos y hagamos un ejemplo muy interesante que también se puede empezar a hacer. Entonces digamos que yo tengo un. Tengo algo que se llama doble, que es básicamente duplicar la edad. En este caso, digamos que le voy a decir que es cero y ni siquiera va a ser un sign. Simplemente va a ser un valor y ya cero. Y acá fíjate que yo lo que quiero hacer es cada vez que haya un cambio en la edad. Quiero correr alguna lógica. En este caso, aquí en la lógica de la edad, lo que voy a hacer es decir que doble doble es la edad por dos. Entonces aquí es donde yo puedo tener esa lógica. Entonces aquí puedo tener doble. Doble. Y pues imprimir el valor. Esto como no es un sign, puedo imprimirlo. Directamente. Entonces cada vez que. El valor de la edad cambie, lo voy a multiplicar por dos y pues entonces lo voy a asignar y pues eso simplemente se me va a mostrar en pantalla. Veamos si funciona. Acá tenemos doble. Si yo le pongo dos, entonces acá tengo un cuatro. Si yo le pongo cien, pues acá tengo un doscientos. Si bien es una forma muy interesante, lo primero que yo haría es pasar esto a un sign al normal para seguir manteniendo como los patrones de reactividad. Entonces lo inicializan cero. En este caso. Entonces me suscribo a la señal y entonces cada vez que cambie lo que yo haría es aquí un set. Cada vez que cambie lo multiplico por dos. Entonces va a tener el mismo efecto, sólo que con sign al. Entonces vamos a ver. Es más, fíjate que acá aparece algo muy interesante. Esto de por sí es una como un flag que tienen los sign al en decir que dentro de un sign al yo estoy editando o ejecutando un sign al. Esto hay que tener delicadeza. Con eso en donde dentro de un sign al o dentro de un efecto yo estoy modificando otro porque esto puede causar un ciclo infinito. Es decir, si al final el efecto está para leer cambios, pues ahí mismo estoy haciendo el cambio dentro del efecto. Estoy haciendo el cambio, pues esto podría producir cambios y cambios infinitos. Hay que tener delicadeza con eso y precisamente ese es el flaco o el error que nos sale acá. Oye, está seguro que quieres hacer eso? Está seguro que quieres hacer un cálculo dentro de un efecto? Entonces yo le digo si todavía. Entonces le digo oiga, si permita que dentro del efecto se puedan editar o escribir otros sign al. Entonces simplemente le pongo en true. Si lo pongo en true, me deja dar el error y me sigue funcionando sin mayor dificultad. Ahora, si lo volvemos a ver, realmente fíjate que él también te está dando una recomendación. Por ejemplo, lo voy a volver a pasar a false. Es más, lo voy a quitar para que me salga el error. Y ya está. Entonces, si lo volvemos a ver, realmente fíjate que él también te está dando una recomendación. Y me dice oye, escribir sign al no está permitido dentro de un computer o dentro de un efecto por defecto. De por si esto creo que ya lo van a quitar y en la siguiente versión ya se va a poder hacer. Sólo que hay que realmente tener delicadeza con eso. Por favor, tengan mucha delicadeza porque pueden causar ciclos infinitos. Sin embargo, si te fijas, esto es muy interesante en cuanto a que ok, listo. Yo puedo en código correr a la mano. Y yo puedo correr algo de lógica si alguno de esos inputs cambió. Y eso es interesante porque yo puedo correr, por ejemplo, una API. Puedo correr, hey, si este valor cambió, entonces tengo que ir a correr un método que está en un servicio para obtener cierta información. Y pues hacerlo de forma reactiva. Sin embargo, aquí no estamos haciendo eso realmente. No estamos yendo a declarar un servicio. No estamos haciendo un fetch a una API. Simplemente estamos transformando o computando. O computando un valor más. Y para eso mejor, entonces yo te recomendaría que utilices un computed. ¿Qué es un computed signer? Es básicamente la forma en la que yo puedo transformar o calcular un nuevo valor a partir de otro. Todo con base a signer. Entonces este computed básicamente lo que voy a hacer es que me deje ejecutar un método. Acá está el método. Y lo que voy a hacer es suscribirme a la data. Entonces le meto el número. Me suscribo a ella. Y lo multiplico por dos. Fíjate que acá no necesitaría del effect. Literalmente. Acá podría evitarme, literalmente, escribir. Acá podría comentar esta lógica. Solo la voy a dejar por efectos de que miren que se puede. O sea, podemos vigilar un effect y correr alguna lógica en código. Sin embargo, si al final esto no va a un servicio ni nada, sino simplemente computa un valor. O transforma un valor. Pues simplemente sería un computed. Es decir. Con base a un input que se está recibiendo. Me voy a suscribir. Y lo multiplico por dos. Esto como ya es una señal. Entonces se va a suscribir. Y ya. Entonces fíjate que tenemos el mismo efecto. Si yo pongo un 20. Acá tengo un 40. Si yo tengo un 100. Acá tengo un 200. Entonces esto queda mucho más limpio. Y hasta literalmente podríamos. Este código podría quedar sin effects. Que haría así. Literalmente. Tenemos ciertos inputs. Tenemos un double edge. Que se calcula a partir de otro signal. Que viene de por si desde el padre. Etcétera. Ahora obviamente si tú quieres vigilar ciertos cambios en un input. Y correr alguna lógica de negocio. Como llamar a otro servicio. Etcétera. Pues lo más recomendable es que si ya te suscribas con un effect. Y simplemente tengas en cuenta. Evitar de pronto escribir allí otros effects. A manera que realmente lo quieras de forma intencional. Pues tendrías que habilitar esa opción. Para hacer ese set. Ahora bien. Signal también viene con algo interesante. Y es que nosotros como ya manejamos toda la reactividad con esta primitiva. Podemos empezar a habilitar algo que antes era un poquito raro. Y que por si en futuras versiones de Angular. Ya no vamos a tener que habilitarlo. Sino que va a venir por defecto. Si y sólo si utilizamos Signal. Y es marcar los componentes como onPush. Básicamente es una forma en la que le decimos a Angular. Que sea mucho más granular al leer los cambios. Eh. Basados en los cambios de los inputs. Y sobre todo basado en la reactividad. Pero en este momento la reactividad está manejada con Signals. Entonces podemos como con toda confianza marcar ese componente como onPush. Eso significa que vamos a tener una mejora de rendimiento. Porque no va a estar como checando. Realmente cada vez y renderizándolo. Por cualquier cambio en el DOM. Hay bastantes cosas por hablar. Simplemente onPush es una forma como. Más granular de leer el Change Detection de Angular. Y básicamente esto con Signals. Es una pareja muy interesante. Y no hay que hacer tantos trucos. Si uno empieza a habilitar esto como. Con la manera clásica de Angular. Como que hay que tener varias como conocimiento. Para saber que estás haciendo las cosas bien. Y que no vas a tener algún problema. Pero si tú estás manejando Signals. Casi que lo puedes habilitar sin problema. Sin mayor dificultad. Si bien estás utilizando todo con Signals. Si lo tienes así. Habilítalo. Yo te recomiendo que lo habilites. Porque va a mejorar el rendimiento de tu aplicación. Si, sólo si. Ya toda tu aplicación está manejando. O al menos ese padre e hijo. Están manejando Signals. Como patrón de reactividad. Entonces a qué me refiero. Yo voy a mejorar el rendimiento de este componente. Marcándolo con un Change Detection. Stragity onPush. Significa que vamos a mejorar el rendimiento. Si quieren. En un video mucho más. Específico acerca de esto. Les digo cómo funciona el onPush. Pero simplemente ahorita es. Mejorar el rendimiento de este componente. ¿Listo? Entonces para eso. También voy a marcar el padre como un onPush. Entonces aquí también le voy a poner un Change Detection. Y le voy a decir que esto lo quiero. Pues traer del Angular Core. Y también lo voy a poner como onPush. Aquí la gracia es que tanto el hijo como el padre. Pues tengan Signals. Entonces esto también lo va a transformar a un Signals. Esto como no lo estoy recibiendo de ningún lado. Entonces en este caso. Si voy a tener un Signal normal. Es decir no es un Input Signals. Si no es un Signal directo. Porque no lo estoy recibiendo de ningún lado. El es el que lo está poniendo. Acá tengo la edad. Y por ejemplo acá también voy a tener este Signal. Creo que ahí ya estaba. Como una red de productos que inician vacío. Perfecto. Aquí ya todo lo pasé a Signals. Entonces tanto el padre como el hijo. Están manejando Signals. Como patrón de reactividad. Ok. Acá tengo que hacer unos ajustes. Por ejemplo. Pues la forma ya de asignar un valor. Ya no sería directo. Tendría que ser por un Set. Entonces pues. Allí cada vez que la API me dé productos. Pues con un Set lleno sus valores en el Signal. Y acá por ejemplo. Al momento de agregar un producto. Entonces lo que ya no puedo hacer un Push tan directo. Sino que lo que tendría que hacer. Es de pronto apartar. Y hacer. Normalmente empezamos a utilizar métodos de programación inmutable. Que eso es bastante interesante. Y bueno de por si es uno de los patrones de Redux. No cambiar el estado original. Sino crear nuevos estados. Entonces aquí literalmente voy a tener el nuevo producto. Ahí está. Y como yo lo voy a agregar. Entonces dentro de mi Signal. Que es un Productos. Lo que puedo hacer. De por si esto está mal. Lo que me sugirió está mal. Esto debería ser un Update. Exacto. Entonces lo que yo voy a hacer es una actualización. Una actualización lo que me hace es entregar el valor anterior. Y con el valor anterior. Yo hago alguna modificación creando un nuevo estado. Eso es muy similar al patrón de Redux. Y eso se aplica acá en los Signals. Que no estamos mutando el estado original. Si no estamos creando uno nuevo. En este caso el estado anterior. O el estado actual del Signals. Podemos decir que es el Value. El Pressed Value. Ese es el valor anterior. O el Current Value. También podría ser. Si lo queremos ver de alguna manera. Como el valor. Recuerden que esto es solo Naming. Solo estoy cambiando el nombre. Pero si vemos que es el Current Value. Pues básicamente es el Array de Productos. Yo con Update le estoy diciendo. Oiga. Quiero actualizar el valor que hay ahí. Y como lo quiero actualizar. Dime que es lo que tienes. Cual es tu Current Value. Cual es tu Array actual. Entonces ese Current Value. Pues es un Array de Productos. Y lo que hago es retornarle un nuevo valor. Y lo que hago es retornarle un nuevo valor. Quiere decir que es un Array. En donde yo pues básicamente. Estoy pasando todos los elementos. Y agrego uno nuevo. Esa sería como la forma. En Inmutabilidad. De agregar un nuevo Producto. No estoy haciendo un Push. Entonces no modifico. Un estado. Sino creo uno nuevo. Creo un nuevo Array. Con un Producto al final. Entonces esa sería la forma. Entonces ahora ya. Los dos están marcados como. Un Push. Tanto el hijo como el padre. Entonces debería funcionar. Sin ningún problema. Y si tu haces esto. Obviamente aquí tengo solo dos componentes. El papá y el hijo. Y aquí no es como que. Vayamos a ver un aceleramiento. Así súper fuerte de rendimiento. Pero ya en una aplicación. Que tiene muchos componentes. En una misma. Como en una misma vista. Como un Dashboard. Como filtros muy complejos. Aplicaciones complejas. Que tienen como muchos elementos. Muchos sub componentes. En una misma vista. Pues ahí. Si de pronto vamos a ver. Una mejora en el rendimiento. En donde. Vamos a ver. Si de pronto. Vamos a ver. Una mejora en el rendimiento. En donde. Vamos a ver. Un nuevo Producto. Y aquí. Vamos a ver. Un nuevo Producto. En donde. Si yo. Todo lo manejo. Con el patrón de Signals. Y ya lo puedo marcar. Como On Push. Pues voy a tener. Un aceleramiento. En rendimiento. Bastante significativo. Ahora. Aquí ya pasamos. Como toda. Nuestra lógica de negocio. A Signals. Pero empieza a haber. Un problema. En el Template. Fíjate que acá. Mi plugin. El Angular Language Detection. Ya ahora. Si me está detectando. Como errores. Y acá. Obviamente. Hay unos problemas. En donde me dice. Que no tengo. Un aceleramiento. Y obtener. El punto. Link. Acá. También me dice. Oye. Si bien es. Un. Signal Input. Básicamente. Nosotros. Debemos suscribirnos. Y pasar el valor. Entonces. Lo vamos a suscribir. Aquí también. Los Productos. Listo. Ahí ya está bien. Y acá. Obviamente. Al ser el For. También tenemos. Que. Pues. Suscribirnos. Y listo. Aquí. A ver. Voy a recargar acá. A ver si ya. Ahí está. Vamos a abrir nuestra. Inspeccionar. Listo. Entonces. Ahora ya tenemos. No tenemos ningún error. Por acá. Entonces. Nicolás Molina. Acá le llega el cambio. La edad. Entonces digamos. Que yo pongo varios. Acá está. Si ya le hago. Un producto. Acá tenemos. El producto. 51. Que sería. Pues. Ese elemento más. Que agregué. Listo. Pero fíjate. Si bien. Acá. Me tocó. Como suscribirme. Al sign al. Para enviarle. Ese valor. Como input. Fíjate. Que el ng model. No me pidió. Pues hacerlo. De esa manera. Y acá. Me soporta. Y es algo. De pronto. Que no todos. Muchos saben. Y. Está bien. Que lo sepas. Por eso. Está en este video. Y es que ahora. El ng model. Soporta enviarle. Un sign al. De forma directa. Y si. Vamos a sign al. Le enviamos. Ese sign al. Y él sigue. Funcionando. Sin problema. Entonces. Tú estás manejando. Algunos patrones. De reactividad. O estás. Utilizando. El ng model. Y quieres hacer. El data binding. O la conexión. O el enlace de datos. Precisamente. Con este. Con el sign al. Se lo envías. Y ya. Fíjate. Que aquí. No me tocó. Hacer ninguna migración. Aquí. Literalmente. Está el número. Ahí está cambiando. Sin ningún problema. Y nosotros. Lo que le enviamos. Es directamente. Un ng model. No sé. Si ya sabías. Déjame en los comentarios. Si sabías. Que el ng model. Ya soporta enviarle. Un sign al. Directamente. Entonces. Simplemente. Puedes empezar. A. Verlo. De esta manera. Y de por sí. Fíjate. Que cada vez. Que cambia. El first name. Como esto. La impresión. Entonces. Podríamos estar. Leyendo. De forma reactiva. Cualquier cambio. Por ejemplo. Para un buscador. O cosas así. En donde yo necesito. El valor. Y a medida. Que se va actualizando. Ir enviando. Eso a una API. Para obtener. Pues la búsqueda. No. Entonces. Yo como que voy. Escribiendo. Y voy. Obteniendo. Ese valor. En un efecto. Que va. Y se conecta. Con una API. Para hacer la búsqueda. Ese sería. Lo que. Debe ser. Ahora. Yo no soy tan fan. Del ng model. Me gustan más. Los reactivar. Pero. Pues el reactivar. Depende mucho. De. Rx. Y angular. Como que. Está queriendo. Sacar. O no sacar. Pero básicamente. Que su primitiva. De reactividad. No sea. Rx. Si no. Se dan. Entonces. En algún momento. Vamos a tener. Como los formularios. También. Ya soportan. Un signer. Y ya. Y hace todo. Su patrón. De reactividad. Para los formularios reactivos. Esto va a cambiar. Todavía no sabemos. Muy bien. De qué manera. Va a cambiar. Pero igual. También. Lo podrías acoplar. A un formulario reactivo. Y que apenas. Recibas. El valor. Pues vas. Haciendo. Un set. De. El valor. Que quieres. Como. Ahora vamos. Por la parte final. En donde. Miramos. Acá. Literalmente. Tenemos este input. Que me pide. O me. Que básicamente. Tengo este truco. Aquí. Para que no me pida. Inicializarlo. Si yo me lo quito. Me pide. Inicializarlo. Pero. Pues. Miremos. Entonces. Acá. Básicamente. Sería. Un producto. Y ahí. Está. Es requerido. Esto. Sería. Un input. Entonces. Lo importó. Product. Product. Product. Product. Product. Y. Ahí. Ya. Me funcionaría. Sin embargo. Si te fijas. Es como. Raro. Como. Estar. Suscribiéndome. No sé. Cuántas veces. Cuatro veces. Me estoy suscribiendo. Como. Al mismo sign out. Para obtener. Pues. Cada uno. De sus atributos. Y. Pues. Para eso. Ahora. Es. Así. Let. Detail. Es. Igual. Product. Listo. Fíjate. Que. Solo tengo. Una suscripción. La guardo. Acá. Y aquí. Entonces. Ya podría. Simplemente. Utilizar. Detail. Detail. Y no. Tengo. Tantas. Suscripciones. Sino. Una sola. Y. Listo. Acá. Tengo. La. Información. Y. Ya. Listo. Ya. Entonces. Acá. Tengo. Una. Información. Y. Ya. Listo. Acá. Tengo. La. Información. Y. Ya. Listo. Acá. Ya. Ya. Entonces. Acá. Tengo. La. Información. Lista. Para. Empezar. A. Mostrar. Y. Listo. Acá. Precisamente. Pues. Tenemos. Que. Nuestro. Array. De. Productos. Sigue. Funcionando. Sigue. Literalmente. Recibiendo. El. Producto. De. Esta. Manera. En. Signals. Va. A. Funcionar. Muy. Bien. Y. Le. Dar. Como. Una. Mejora. De. Rendimiento. Bastante. Significativa. Sobre. Todo. De. Nuevo. Para. Aplicaciones. Que. Ya. Tienen. Muchos. Componentes. En. Donde. Pues. Si. Ya. Todo. Lo. Manejamos. Con. Signals. Signals. Tanto. En. El. En. El. Padre. En. Donde. Es. Un. Signal. Y. Todo. Se. Va. Mutando. En. Donde. Tenemos. Un. Signal. En. El. Padre. Como. En. El. Padre. Como. Primitiva. Pero. Luego. También. Los. Hijos. Como. El. App. Product. O. El. App. Shield. En. Todo. Usar. Signals. Signals. En. Todos. Los. Reciben. Como. Signals. Y. También. Estamos. Leyendo. Sus. Cambios. De. Forma. Granular. A. Partir. Del. Efe. Que. A. Partir. Del. Comp. P. D. D. D. D. Episodio. Legal. Es. 15 bend� dependá. Qué. Te. M. Es. M. Real. Te. Me. Me, Ven. Si. El. Me. Es. Tu. vez. Cada. Cada. Semana. Comprloe. Y. La. tienen ciertas cosas no sólo deberíamos migrar por migrar en rx sigue siendo útil en muchos escenarios pero digamos que tú quieres manejar signals igual puedes manejar rxgis para ciertas cosas pero a lo que voy es que quieres quitar y que todo el patrón de reactividad sea a partir de signals de forma granular y quitar songis hay una forma en la que tú ya puedes decirle a la aplicación que deje de leer o que deje de utilizar songis como patrón de reactividad y que sólo se fije en signals pero eso implica que entonces tú manejes todo como signals que marques todo como ombuds que el pues manejes esas primitivas y esos valores como signals y que entonces por ende los inputs también sean signals entonces como que no sólo podemos habilitarlo sino que realmente debemos hacer esos ajustes en la aplicación luego en otro vídeo te enseño como literalmente ya salir de songis pero eso implica hacer este tipo de cambios que ya manejes signals en los inputs manejes signals en los componentes para mutar el estado etcétera etcétera dejame en los comentarios qué tal te pareció como lo ves te parece bueno te parece malo te leo en los comentarios y ya suscríbete a este canal recuerda que estoy subiendo bastante contenido acerca de pues de angular de IA sobre todo IA basada en la web etcétera hacer así que suscríbete déjame un like compártelo y nos vemos en la próxima