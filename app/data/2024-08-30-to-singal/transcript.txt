 ¡Hey! Hola, bienvenido a un nuevo video en mi canal y en esta ocasión te voy a enseñar acerca de 2Signal, una función bastante interesante que nos permite precisamente transformar algunos observables a Signals directamente para como abrazar este nuevo modelo de reactividad del Angular. Ahora, si bien no se trata de migrar todas Signals, pues esta función nos va a ayudar precisamente a los observables que ya tengamos o toda la lógica de negocio que ya tengamos con RxJS, mantenerla, dejarla tal cual, si lo tenemos en los servicios, si lo tenemos en algunos aspectos, pero de pronto con esta simple función, con 2Signal, simplemente usarla y al menos al momento de renderizar toda esta transformación, lo hagamos en modo Signals. Entonces, es una función bastante interesante que nos va a ayudar como a esta transición, que nos va a ayudar a reusar código que ya tenemos en la aplicación y abrazar Signals como modelo de reactividad. Así que no siendo más, vamos a empezar. Vamos al código y veamos si aprendamos acerca de esta función. Vamos allá. Aquí te voy a mostrar precisamente un ejemplo, un ejemplo bastante interesante y como más típico que pronto podríamos encontrarnos. Y es que, por ejemplo, acá tenemos un servicio que normalmente utiliza HTTP Client para conectarse y normalmente esto devuelve un observable. Aquí podemos ver que esto devuelve un observable porque se conecta a un API, porque HTTP tiene RxJS por defecto, pero esta función precisamente... 2Signal, voy a hacerle un poquito de zoom. Eso, aquí. Esta función 2Signal me permite transformar un observable en una señal automáticamente y empezarla ya a utilizar. Por ejemplo, acá ya me suscribo y empiezo a hacer el renderizado. Entonces, se nota bastante interesante esta función, la forma en la que podríamos empezar a jugar con la... como con toda la base de código que ya tenemos con RxJS, pero abrazar el modelo de reactividad con esta función. Este ejemplo va a ser como el último que voy a llegar. Luego de haber aprendido... bastantes cosas interesantes y unos ejemplos muy prácticos que, pues, te tengo preparados. Así que veamos el primer ejemplo. Listo, empecemos como con algo en vacío para empezar a ver cómo nos funciona esta interoperabilidad entre RxJS. Entonces, lo primero que vamos a hacer es declarar un observable. Normalmente voy a declarar como observables que nos van a servir como de ejemplo, pero estos observables son los que precisamente ya tienes en tus servicios o los tienes conectados a un formulario reactivo o algo del tipo. Entonces, lo primero que vamos a hacer es crear un observable. Y este que voy a crear acá es como un ejemplo y es el que voy a empezar a ir transformando con tu signal y las diferentes formas que tiene tu signal de manejar un observable. Entonces, lo primero que vamos a hacer es crear un observable. Este es un observable básico que va a tener un number. Y luego, normalmente, lo que podríamos hacer es tener un método que voy a llamarlo shing. Shing value me parece interesante. Y aquí lo que vamos a hacer es... A este observable vamos a emitir un valor con next. Es más, aquí voy a poner un new value. Este va a ser como siempre nuestro template. Y luego, simplemente vamos a ir cambiándolo de a poco. En este caso, creo que lo voy a manejar mejor como string. Entonces, pongamos el string por acá. Esto va a ser un string. Y simplemente voy a transmitir ese string que enviamos por acá. Y listo. Ahora, normalmente tenemos este observable. ¿Cómo nosotros normalmente lo manejamos? En el render. Pues simplemente vamos a poner aquí... Yo creo que con un h1 está bien. Un h2. Y empecemos a usar... Pues a renderizar este observable. ¿Cómo normalmente lo hacemos? Pues ponemos state. De por sí una convención muy normal en ver observables es como ponerles un signo peso al final. Entonces, voy a seguir manejándolo para distinguir esto. Y le voy a decir que esto pues es state. State. Dos puntos. Listo. Vamos a ver acá, por ejemplo. Tengo la suscripción. No tengo nada. No tengo ningún valor. Y es más. Si yo miro aquí, pues me dice que eso es... Pues que normalmente él debería devolver un string. O los valores que este observable normalmente va a tener dentro es un string. Ok. Entonces, ahora vamos a poner un botoncito que llame a la función. Acá, change value. Le dijimos que haga clic. Entonces, por acá hacemos un clic. Change value. ¿Cómo le enviamos un valor? Recuerden que esta función espera un string. Ok. Entonces, posiblemente aquí puedan poner un input. Lo voy a crearle aquí una variable en el template. Y luego voy a utilizar esa variable con input. Punto value para obtener el valor de este, pues de ese string como tal. Listo. Entonces, voy a abrir aquí la consola. La voy a poner como por aquí abajito. Console. Acá. Sí, la voy a limpiar. Y guardarle aquí para que lo podamos ver claramente. Listo. Acá tenemos nuestra consola. Y vamos a ver. Entonces, si yo hago un cambio. Le hago change. Pues acá tenemos el cambio porque al final me suscribí con una sign pipe. Y pues obtengo el valor que estoy suscribiéndome, etc. Este es un observable básico. ¿Y cómo vamos a empezar a transformar este observable en un sign up con esa función? En automáticamente no borrar nuestra lógica de negocio, sino mantener esa lógica de negocio que tenemos en RKGS. Y empezar al menos en el render a mostrarlo, a renderizarlo en forma de sign up. Que es donde tiene un gran beneficio. Porque sign up al final es un patrón de reactividad que nos ayuda a tener como este renderizado granular. Entonces, está bien que el servicio tenga RKGS, que tengamos la lógica de negocio allí. Pero a mi punto de vista, pues precisamente tiene sus beneficios ya al momento de renderizar ese valor. Al momento de renderizarlo, estamos utilizando una sign pipe. Pero vamos a cambiarlo en sign up. Entonces aquí, por ejemplo, yo crearía state. Y acá precisamente es donde llega esta función. To sign up. Entonces esto viene del paquete de RKGS interop. Y precisamente lo que hace es tener un observable, que es el que yo tengo acá. Y transformarlo directamente a un sign up. Y ya. Y simplemente un observable se lo mando allí y lo transforma a sign up. Entonces aquí, por ejemplo, puedo imprimir otro h2. Le digo que esto es el estado normal. Y como esto ya es un sign up, no necesito una sign pipe. Sino simplemente me suscribo con ejecutar la función. Ya que al final es precisamente un sign. Un patrón de reactividad que para obtener el valor necesito ejecutar la función. Entonces vamos a ver si están conectados. Entonces yo hago un cambio y le digo change. Fíjate que tanto el observable que tenemos sigue funcionando tal cual. Pero ahora podríamos, literalmente podríamos quitar este h2. Y dejar de un sign up directamente en el render. Simplemente cualquier observable que tengamos en nuestra lógica de negación. Lo pasamos a un to sign up. Y listo. Y ya podemos empezarlo a utilizar. En el render como un sign up directamente. Entonces si yo voy por acá, por ejemplo. Y hago esto. Listo. Ahí tengo el observable. Y ya no me estoy. Ya estoy utilizando el patrón de sign up directamente en el template. Y no el assign pipe. Sin embargo, miremos algunas cosas que hay que tener en cuenta. Y es lo que vamos a empezar a ver. Cositas que hay que tener en cuenta. Y cómo utilizar de forma muy muy profesional este to sign up. Entonces, por ejemplo, hagamos un estado como computado. Es decir, quiero. A partir. Acá el ejemplo clásico es como repetir un estado. Por acá lo tengo. Double sign up. Entonces fíjate que esto va a ser un computed. Y digamos que acá lo que quiero hacer es algo como lo siguiente. Quiero obtener el estado. Lo que hay en el sign up. Y quiero repetirlo dos veces. Por ejemplo, podría utilizar la función repeat de JavaScript. Para repetirlo dos veces. Pero fíjate en algo muy interesante. Aquí. Aquí. Él me da algo como. Como. Una especie de error. Y me dice. Oye, esto puede ser un define. Y por qué esto es un define. Porque esto puede ser un define. Es más. Si miramos acá también. El typing que le da al transformar las sign up. Nos dice. Mira, esta señal puede ser. Puede venir un string. O puede venir un define. Y es interesante. Y hay que tener esto muy en cuenta. Porque es esto. Y es más. Si nos suscribimos. A esta señal. Double stage. Acá. Acá. Listo. Por acá también nos va a decir. Oye. Este. Esto posiblemente sea un define. Entonces nos toca empezar a hacer el knowledge collection. Por ejemplo. Para poderlo utilizar. Y si lo cambio. Vamos a ver. Ahí está. Pues repite el valor. O sea. Si yo le pongo dos. Repite el valor. Ahí está. Dos, dos, dos. Lo repite. Acá lo estoy repitiendo cuatro veces. Lo voy a repetir dos veces. Entonces si yo le hago dos. Debería repetir ese valor dos veces. O sea. Veintidós. O si yo hago. High. Pues. Lo repito dos veces. High, high. Perfecto. Pero yo no quiero tener esto. No quiero. Que el. Precisamente. Utilizar este knowledge collection. No quiero que esto. Literalmente. Me diga. Que puede ser un define. Porque está raro. Está raro que. Pues me diga. Que es un define. En algún punto. Sin embargo. Posiblemente tengamos este caso. Este caso muy peculiar. O este caso. En donde tengamos un observable. Que inicialmente. No imita ningún valor. O sea. Que inicialmente. No tenga nada. Por eso es un define. Sino que luego. Que como que uno le empuja un cambio. Ahí sí dice. Ah ok. Ahora sí tengo un valor. Entonces. Ese es el string. Que quiere. Que lo transmitirá. Cerca de ese observable. Pero como no tiene. Pues un valor inicial. Entonces. Pues. Tenemos este pequeño. Como problemita. Que puede ser un define. Lo puedes dejar así. Lo podrías decir. Bueno. Utilizo el knowledge collection. Puedo hacer preguntas. Y decir. Si viene o no viene. Pero se vuelve un poco. Raro estar haciendo un if. De saber si viene o no. Y aquí es donde entonces. Vamos. La primera utilidad. De este to sign. Al to sign. Si yo lo suscribo. A un observable. Que no tiene un valor inicial. Entonces. Yo. En el to sign. Si le puedo. Poner un valor inicial. Acá. Por ejemplo. Le pongo. Initial value. Entonces. Este initial value. Va a ser el valor. Precisamente inicial. Que va a tener. En caso que. El observable. No nos lo dé. Entonces. Como tenemos un valor inicial. Fíjate que acá. Ya el typing nos dice. Oye. Este sign. Va a ser un string. Seguro va a ser un string. No va a ser un define. ¿Por qué? Porque yo tengo. Un valor inicial. Entonces. Aquí ya no me sale. El problema. Por ejemplo. De. Que. Cuando me suscribo. Al state. Pues puede ser un define. No. Ya sabe que es un string. Que aseguro. Va a venir un string. Al menos uno inicial. Y luego. Ya cuando el observable. Empieza a emitir valores. Pues va a empezar. A enviarnos. El string. Respectivo. De ese observable. Pero al menos. Tiene un valor inicial. Y con eso. Podemos al menos. Ya salvarnos. De este primer error. Y simplemente. Cuando tengamos este caso. Observables que no emitan. Un primer valor. Por ejemplo. Una petición. Htpp. No nos emite un valor. No tiene un valor. Por defecto. Pues primero. Se conecta. Y luego. Ahí si viene. La respuesta. Pero no tiene como. Algo por defecto. Entonces ahí. Es donde. Precisamente. Esta nueva bandera. O esta opción. Dentro del to signal. En el momento. Que lo estemos convirtiendo. Nos va a servir. Para ese valor inicial. Entonces fíjate. Que por acá. Tenemos el initial value. Luego tenemos. El double stage. Que es un estado computado. Es decir. Como que depende de otro. Entonces lo opera. Le hace como ese. Por dos. Y por ahora. El sign. El observable. Original. No tiene ningún valor. Pero apenas. Yo ya lo emita. Entonces digamos. Acá tengo. Emit. Y lo cambio. Pues ahí ya empieza. A funcionar. Y si ese observable. Empieza. A emitir cambios. Simplemente. Los empieza. A transformar. Pero no tenemos. Esta. Como este. Primer. Primer error. De tener. Un define. Listo. Entonces empezamos. A transformar. El observable. Y sign. Y hemos visto. Como este primer flag. Que nos permite. Usar. Un initial value. Que nos permite. Precisamente. Ponerle ese valor inicial. Sin embargo. Hay otro. Hay precisamente. Otros. Que nos van a permitir. Jugar con. Los diferentes tipos. De observables. Que tengamos. En nuestra lógica. De negocio. Y por eso. Vamos a ir. Al siguiente. El siguiente flag. Que es. Require sign. Este precisamente. Si. Es el caso. En donde tenemos. Observables. Que si. Hay casos. En donde tienen. Un estado inicial. Así que. Veamos. Como sería este. Listo. Ahora. Si vamos viendo. El código. Acá vamos a tener. Como con base. Al código. Pues anterior. Del initial value. Vamos a transformarlo. Un poquito. Entonces. Pues recuerda. Esto era para. Observables. Que no te emiten. Un valor inicial. Pero ahora. Si hay observables. Que te emiten. Un valor inicial. Por ejemplo. Si estás utilizando. Patrones como. Redox. Si normalmente. Te piden. Un estado inicial. Observables. Que te pidan. Un estado inicial. Posiblemente. Por ejemplo. Tengas. Varios. Behavior. Subject. Y aquí. Es donde. Ya no. Utilizar. Subject. Sino. Un behavior. Subject. Acá. Voy a ponerle. Behavior. Subject. Y por ejemplo. Behavior. Subject. Que deberíamos tener. Un estado inicial. Entonces. Acá. Ahora sí. Le voy a poner. Init. Por ejemplo. Y como le puse. Un string. Que automáticamente. Pues el observable. Queda como un string. Esto puede ser. Varias cosas. Y por si. Este es el que yo. A veces. Mucho utilizo. O el que más utilizo. Para crear. Mis propios observables. Donde siempre. Les pongo. Un estado inicial. Puede ser. Por ejemplo. Un estado de sesión. Porque no es como. Que un estado de sesión. Inicie. On define. On null. Normalmente. Tiene que tener un estado. El usuario está. O no está logueado. Entonces. Inicie. Por defecto. En false. Luego. Tú haces algún check. De. Hacia la API. Si el usuario. Tiene sesión. Si no. Pero normalmente. Inicia con un estado. En este caso. Por ejemplo. Lo más común. Es que tengas. Vg. Bors object. En varios servicios. En varias lógicas. O cualquier observable. Que tenga un estado inicial. Entonces. Cómo lo manipulamos. Cómo podemos empezar. A trabajar. Como con ese estado inicial. Entonces. Vamos a ver. Aquí. Por ejemplo. Ya lo cambié. Fíjate. Que no cambia mucho. Mi lógica de negocio. Sigo utilizando. El. El. Se sigue suscribiendo. Voy a guardarlo. Por ejemplo. Y fíjate. Que acá pasa algo interesante. Acá. Ya por defecto. Por defecto. El. Como ya el observable. Tiene un estado inicial. Y es más. Aquí voy a empezar a. Poner un constructor. Para. Ir leyendo. Como. Cada cuanto cambia. Entonces. Acá. Tengo un efecto. Y acá. Voy a ponerle. A este console. Punto log. Que esto fue un efecto. Me. Suscribo. Y. Cada vez que. Como que. Ese estado cambie. O el observable. Me emite un valor. Pues aquí. Yo debería leer. Ese cambio. De forma reactivo. Pues para eso. No sirve el efecto. Ok. Entonces. Fíjate. Que. Hay algo raro. O peculiar. Acá. Y es que. Claro. Como el observable. Ya nos envía. Un estado inicial. Ya. El initial value. Es descartable. Ya esto. No va a ser tomado. En cuenta. Porque precisamente. Tenemos un observable. Que si. Emite un estado inicial. Y por acá. También lo podemos ver. En consola. Acá. Tenemos un effect. Que nos dice. Oye. Mira. El estado inicial. De ese sign. Que fue. Como transmitido. Desde. O fue transformado. Desde el observable. Recuerda. Que acá. Estamos manejando. Observable. Si estamos viendo. La forma. En transformarlo. A sign. Pues con la función. To sign. Bien. Entonces. Pues literalmente. Acá tenías. Este observable. Y lo estás transformando. Esto ya no sería necesario. Porque. Literalmente. Ya. Tiene el valor inicial. Entonces. Podríamos. Que. Quitarlo. Que si lo quitas. Vuelves a tener. El problema. Del. Undefined. Dice. Oye. Esto puede ser. Undefined. Y por qué. Tenemos otra vez. Ese error. Porque otra vez. Nos enfrentamos. A ese error. Si literalmente. Ya. Cambiamos. A un observable. Que si. Emite un estado inicial. Pues precisamente. Porque nos falta poner. Una bandera más. Y es. Cuando el observable. Cuando nos estamos conectando. A un observable. Que si. Tiene un estado inicial. Acá tenemos que ponerle. Recuerda. Sign. En true. Que. Que significa. Que literalmente. Se va a sincronizar. Con el estado inicial. De ese observable. Entonces. Recuerda. Teníamos. El initial value. Que es para cuando tenemos. Observables. Que no nos envían. Un estado inicial. Pero cuando nos conectamos. A un observable. Que si tiene un estado inicial. Lo que hacemos. Es poner la bandera. La banderita. Require. Sign. Para. Literalmente. Como mantener. Sincronizados. Con el primer valor inicial. El observable. Con el sign. El que estamos. Ya transformando. Entonces. Al final. Todo se volvió. Simplemente habilitar. Esta bandera. Ya no. Tenemos el problema. De lo. Defined. No tenemos que hacerle. If. O cosas raras. En el template. O. Inclusive. La lógica de negocio. Si no. Ya sabemos. Que. Tiene que estar sincronizado. Y que el valor inicial. Si o si. Debe ser. Init. Acá. Por ejemplo. Ahora. Como tenemos. Ese valor inicial. Acá. Pues tenemos. Nuestra lógica. De negocio. Funcionando. Si yo. Le hago. Un cambio. Acá. Le hago. Sinc. Fíjate. Que acá. Pues. Lo transmite. El cell signal. Lo estoy manejando. De esa manera. Entonces. Esta sería. La forma. De transformar. Este tipo. De observables. Ahora. Una cosa. Que tienes que tener en cuenta. Es que puede. Puede. Que tú tengas. Un estado inicial. O pues. Que ese observable. Tenga un estado inicial. Pero que por alguna lógica. De negocio. Digamos. Que tienes. Otro observable. Que deriva de este. Entonces. Voy a poner un. No sé. Que ponerle. State dos. Porque. No. No se me ocurre nada. Entonces. Digamos. Que tenemos. State dos. Que es un observable. Porque se suscribe. Al. Estado. En forma de. Pues de. RxJS. Se suscribe. Al estado uno. Y luego. Digamos. Que empieza a hacer operaciones. Que es también normal. Tener como. Un pipe. Entonces. Digamos. Que acá yo le pongo. Un delay. Y acá puedes tener. Varias operaciones. Por ejemplo. Acá un map. Podemos tener un filter. Y eso lo puedes hacer. Literalmente. Al final. La gracia es que tengas. Un observable. Si ese observable. Tiene. Varia lógica de negocio. No importa. Pues simplemente. De eso se trata. De reutilizar. Esta lógica. Y luego. Simplemente. Pasarla. Hacia. Un sign. Entonces. Acá. Por ejemplo. Voy a decirle. Que tenemos. Alguna lógica de negocio. Como esta. El map. Me parece válido. Digamos. Que acá. Tengo esto. Digamos. Que realmente. Queramos. Que estemos. Que tengamos. Que tengamos. Este. Este map. Que sería. Como la forma. En RxJS. Pues de. Multiplicar ese valor. Por dos. Sería como la versión. Del double stage. Pero en RxJS. Es más. Este podríamos decirle. Que es el double stage. Pero en versión. Pues de. De RxJS. Entonces acá. Por ejemplo. Yo podría. Tener el double stage. Y suscribirnos. Y pues al final. Me da un poco. Lo similar. Pero esta sería la forma. De hacerlo. En RxJS. Esta. Si nos fijamos bien. Pues sería la forma. Hacerlo en Signals. Pero queda un poquito. Más bello. Queda un poquito. Más legible. Y sobre todo. Tiene más que legible. Pues también. Tiene un patrón. Que ya viene integrado. Angular. Que es tener. Pues reactividad granular. Con mejor rendimiento. Etcétera. ¿No? Pero. Bueno. Mi ejemplo. Iba a que. Bueno. Si bien. Podemos suscribirnos. Y podríamos también. Entonces. Pasar esto. A un Signals. Que lo voy a pasar. Digamos que ya. No quiero hacer este computed. Sino que quiero pasar este. Utilizar tu Signals. Y. Pues pasarlo. Acá. Entonces fíjate que. Acá lo que estoy haciendo. Es pasar esta lógica. A esto. Ya no va a ser computado. Porque supongamos. Que queremos. Utilizar como la lógica de negocio. Que ya está integrada. A una RxJS. Que sería este. Acá lo transformo. Fíjate que acá. ¿Cuál sería la opción? Pues bien. Si bien. Viene de un. De un Observable. Que tiene. Un estado inicial. Podríamos utilizar también. El RecordSync. Para que. Pues. Recibamos ese valor inicial. Entonces acá tenemos. Int. O sea. Sigue funcionando. Como de. La misma manera. Si yo le digo. 3. Por ejemplo. Todo debería conectarse. Ahí está. 3. 3. 3. Bien. Pero mi punto. También va. En que tengamos cuidado. Que cuando tengamos. Por ejemplo. Tenemos este. Este Observable. Que tiene. Un estado inicial. Pero sin embargo. De pronto. Luego lo cruzamos. Por operadores. Por ejemplo. ¿Qué pasa? Si yo le coloco. Un delay. Delay. De 500. De 3 segundos. Digamos. Un delay de 300 segundos. ¿Qué va a pasar? Empieza como a ver. Como algunos errores. Porque yo le dije. A este DoubleStage. Que sea RecordSync. Pero realmente. Si bien. Parte. De un Observable. Que tiene un estado inicial. Explícitamente. Le dije. Que el valor. Lo demore. Cada valor emitido. Dentro del Observable. Lo demore. Unos 3 segundos. Por ende. No tiene un estado inicial. Literalmente. Por más. Que tenga el RecordSync. Pues le estoy diciendo. Que demore. Esa emisión. De ese valor. Por ende. No lo va a tener. Entonces. Cuando tengamos esto. Pues ahí. Podemos simplemente. Decirle. Bueno. Yo sé que. Este valor. Si bien viene. Y parte de un Observable. Yo aquí. Ahí explícitamente. Lo estoy diciendo. Que lo demore. Entonces. Podemos utilizar un ToSignal. Y decir. Un Init. Un Init. Init 2. Por ejemplo. Y aquí. Problema solucionado. Aquí deberíamos. Ya tener. Pues. Arreglado todo. A ver. Vamos a. Ah bueno. Aquí me voy a suscribir. A Sign. Que es donde está el componente. Listo. Ahí está. Entonces. Fíjate que acá. Por ejemplo. El valor de DoubleStage. Fíjate que. 3 segundos. Llega el valor. ¿Ves? Ahí como que. Tenemos. Un valor inicial. Que sería como el. Default. Voy a poner. Default. Fíjate que acá. Este Signal. Tiene un valor inicial. Y hasta que se emite el valor. Pasado 3 segundos. Ahí si llega. El Init. Porque pues. Explícitamente. En la lógica. Le puse un Delay. Entonces. Para limpiar un poco. Nuestro código. Digamos. Que tenemos. Este. Esta operación. Lo tenemos en un servicio. Lo tenemos en. En alguna lógica. De un componente. Tenemos algo. De esta manera. Entonces. Digamos que. Simplemente. Simplemente. Necesito un estado. El Double Stage. Aquí voy a borrar este. Aquí voy a borrar este. Este. Digamos que si. Lo quiero seguir utilizando. Acá. Pues. Voy a quitar. Los. Assigns. Me va a quedar. Solo con el Double Stage. Y listo. Entonces. Fíjate que nuestra lógica. Quedaría algo de esta manera. Simplemente. Tengo. Solo una suscripción. En modo Signals. Hacia el Template. Si yo lo cambio. Por ejemplo. Dos. Entonces. Aquí. Ah. Vamos a ver. Si. Si. Emitió el valor. Shing. Ah. Bueno. Claro. Lo estoy demorando. Tres segundos. Me asusté un poquito. Pero. Claro. Si yo le digo. 55. Cambio. Estoy emitiendo. Este valor. En este Observable. Pero como. Tengo este Double Stage. Que es un. Un. Pues. Una lógica de negocio. Que tengo acá. De. Pues. De transformarlo. Y luego. Demorarlo. Entonces. Vamos a ver. Shing. Uno. Dos. Tres. Y ahí llega el valor. Ya. Pues. Con la operación. Entonces. Fíjate que acá. Esta sería la forma. Entonces. Simplemente. Tienes como. Esta lógica. En algún lado. Simplemente. La transformas. Tienes que. Pues. Literalmente. Ser. Muy. Consecuente. De. Si. Tu Observable. Pasa por alguna lógica. Que hace que se demore el estado. Entonces. Le pones. Un Initial Value. O. Precisamente. Pues. En el caso. Que. Simplemente. Esto no vaya. Acá. Como resumiendo. Y. Lo transformamos. A State. Acá. Pues. Simple. Acá. Entonces. Utilizaremos el Recall Shing. En True. Para. Estos Observables. Que. Si. Directamente. Tienen. Un valor. Inicial. Y. Pues. Ahí está. El Initial. Ahí llega. Y. Perfecto. Entonces. Así sería. Y. Esta sería la forma. De utilizar el Recall Shing. Para estos Observables. Que tienen un valor inicial. O. Recuerda. Tener en cuenta. Si tienen alguna lógica. Y. Pues. Seguir utilizando. El Initial Value. Ya vimos. Dos de estos Flags. Interesantes. Y. Nos empieza. A. Alumbrar. Como podríamos. Empezar a transformar. Observables. En Signals. Recuerda. La gracia. Es no solo migrar. Por migrar. O. Simplemente. Transformar. Toda tu lógica. De RxJS. A Signals. Eso sería. Un poquito complicado. Esta función. Llega. Precisamente. Para eso. Recuerda. Después. Seguir teniendo. Toda tu lógica. De negocio. En RxJS. Pero. Al momento. De ya. Renderizarlo. Al template. Pues. Puedes utilizar. Tu Signal. Viendo. Algunas. De estas banderas. Cuál se acomoda mejor. Para ti. Un Initial Value. Un Record Sign. Lo que más se acomode. Y. Precisamente. Ahora. Vamos a ver. Otra. Tercer. Flag. Que es. Reject. Errors. Que pasa. Cuando. Tengamos. Tenemos. Un Observable. Tenemos. Una lógica. Una suscripción. A una. A un. Request. Por ejemplo. Con HTTP. O. Tenemos. Alguna lógica. Que tiene. RxJS. Y. Está. Dentro. Pues. Manipula. O. Maneja. Errores. Y. Hay un error. Dentro. De toda la emisión. De ese Observable. O. De ese valor. Cómo. Se trata. Cómo. Podríamos. Tratarlo. Cuando lo pasemos. A. Cuando. Estemos. Utilizando. La función. To Sign. Pues. Precisamente. Vamos a ver. La. La bandera. Reject. Errors. Para ver. Cómo. Manejar. Esto. Cómo. Se comportaría. Veamos. El código. Listo. Acá. Tengo un template. En vacío. Porque. Voy a iniciar. Otra vez. Entonces. Voy a decirle. Que quiero un Observable. Counter. Pero. En este caso. Voy a utilizar. Lo que es un Interval. ¿Qué es un Interval? Precisamente. Es un tipo de Observable. Y este. Es interesante. Porque. No tiene un valor inicial. Es. Es. De los que no tienen un valor inicial. Sino que. Luego. De cada. Un segundo. Cada tres segundos. Pues. El valor que yo coloque acá. Me va a emitir un valor. Entonces. Yo podría. Aquí. Tener un. Un H2. Suscribirme. Acá. Con el AssignPipe. Recuerda. Que la gracia es. En cierto momento. Dejar de utilizar el AssignPipe. Sino que. Todo siempre sea un AssignPipe. Y. Simplemente. Nos suscribamos. Pero por ahorita. Por el ejemplo. Pues. Sigo utilizando el AssignPipe. Entonces. Fíjate. Que tengo acá. Ah. Bueno. Y le voy a poner acá. Counter. Counter. Para saber. Qué es esto. Ya. Fíjate. Que por ahora. Es más. Si le coloco tres segundos. Por tres segundos. No tengo ningún estado inicial. Eso va a ser un Defined. Y luego. Tres segundos después. Empieza a llegar. Un valor. Entonces. Tres segundos después. Empezó un cero. Luego. Un dos. Bueno. Etcétera. ¿No? Si lo pongo en un segundo. Se ve un poco. Pues. Más rápido. Porque llega un valor. Cada. Cada un segundo. Fíjate. Que el primer valor. Es. Defined. Luego un cero. Luego uno. Luego dos. Etcétera. ¿Cómo podemos empezar a transformar esto? Quitar este Assign. Y manejarlo. Todo. Con Signals. En el Render. Que es un poco. La gracia de este. ToSignalt. Entonces. Pues. Otra vez. Utilizamos nuestra función. Counter. Queremos. Ya no utilizar eso. Como Observable. Puede que la lógica. Si esté en un servicio. Que la tengamos aquí. En el. En el componente. Pero al momento de renderizar. Pues. Lo queremos siempre mostrar. Como Signals. Porque tiene un mejor patrón. De reactividad. Etcétera. Etcétera. Entonces. Acá tenemos esto. Por ejemplo. Entonces. Ya transformé este Signals. En un ToSignal. Entonces. Me puedo igual. Suscribir. Esta vez. Ya sería el Signals normal. Me suscribo. Es más. Ya podría dejar. De hacer esto. Para removerlo. Y simplemente. Lo transformé. Tenemos la misma peculiaridad. De que. Pues. Simplemente. Transformado. Cumple con la misma función. Empieza a. Emitir el valor. Lo único raro. Es que. Claro. Si yo. Por ejemplo. Aquí pongo. Quiero leer el estado. Leer el estado. Y. Decir. Quiero. Saber el valor de Counter. Y acá. Lo imprimo. Pero. Fíjate que. Esto lo estoy haciendo. Como una función. O sea. Como para. Cliquear un botón. Y leerlo. En un momento específico. Entonces. Voy a ponerle. Wit. Y voy a llamar. A. Click. Igual. A. Wit. ¿No? Entonces. Que es la. La función leer. ¿No? Y. Lo voy a demorar un poquito más. O sea. Como. Cinco segundos. Listo. Entonces. Fíjate que. Cuando yo le hago Wit. Esto es un Define. Y nos toca tener cuidado. Porque. Otra vez. Como. Es un valor que no emite. Pues. Literalmente. Vamos a tener un Define. En el. En los primeros valores. Hasta que esto empiece a emitir. Pues. Cosas. ¿No? Por ejemplo. Ahorita están dos. Y yo le hago Wit. Ahora sí me da un valor. Dos. Porque es el estado. En ese momento. ¿No? Es el valor que tiene. En ese momento. Entonces. Por ejemplo. Uno podría hacer cosas como. No sé. Value. Hacer un. Quiero hacer algo con este valor. Como por ejemplo. Multiplicarlo por dos. No podría. Porque esto. Me dice que puede ser. Undefined. Me dice. Digamos que yo quiero. Hacer una operación. Y me dice. Oye. Pero recuerda que esto puede ser. Undefined. Porque todavía no tiene un valor. Entonces no lo puedes todavía multiplicar por dos. En fin. Acá me dice. Ten cuidado. Con esto. Porque pues. En algún momento. Puede ser undefined. Y al multiplicar un undefined por dos. Pues te da una duda. Entonces bueno. Aquí es donde empezamos a utilizar. Acá yo lo podría hacer. Bueno. Ya. Yo sé que. Tenga un initial value. Y que el initial value es cero. Perfecto. Entonces todo empieza a funcionar bien. Ya tiene un valor por defecto. En lo que envía el valor. Que sería cinco segundos después. Etcétera. Pero qué pasa. Si. Si. Si durante eso. Que este observable. Me está emitiendo valores. Cada cinco segundos. Programo un error. Que por ejemplo. En el. En la. En la vez número cinco. En la iteración número cinco. Haya un error. Que eso pasa. Y tenemos observables. Que por ejemplo. Pueden emitir. O tener un cache. Y un error. Entonces qué pasa. Como con toda esta lógica. Vamos a verlo. Entonces por acá. Por ejemplo. A este counter. Le voy a poner. Pues un pipe. Y aquí voy a utilizar un tab. Entonces. Aquí básicamente. Vamos a ver. Acá. Voy a lanzar un error. Voy a cerrar aquí. Sí. Ahí está bien. Listo. Acá voy a tener el valor. Que sería como. El número de veces. Que. Que me está emitiendo el valor. Y acá voy a ponerle un if. Literalmente. Cuando. Cuando el valor. Sea. No sé. Cinco. Cuando llegue a cinco. Voy a lanzar un error. Literalmente. Voy a lanzar un error. Listo. Y. Voy a demorar esto. Como cada. Cada un segundo está bien. Entonces quiere decir. Que cuando pasen cinco segundos. Esto debe tirarme un error. Vamos a ver qué pasa. Por ahí llegó a cinco. Y pum. Por ahí tenemos el error. Por acá. Ya empieza a decir. Que. Y mira. Error. Error. Que es acá. Acá le podría poner. Ups. No. Ups. Un error. Entonces cuando llegue a cinco. Uno. Dos. Tres. Cuatro. Cinco. Ahí tengo un error. Pero qué pasa con este read. Recuerda que este read. Lo que hacía. Es. Pues leerme el estado actual. Ya le puse. Le pusimos un initial value. Para. Para esperarlo. Mientras ya emite valores. Pero qué pasa. Cuando está. Cuando tiene un error. Vamos a verlo. Entonces. Fíjate en lo siguiente, voy a leerlo, en este caso es 1, en este caso es 2, en este caso es 3. ¿Qué pasa después del error? Fíjate que si yo lo leo después de que hay error, le hago read, lo que hace es leer literalmente la última emisión, que en este caso la última emisión de ese pipe o lo que tiene ese observable es un error. Entonces es como que cuando yo lo leo también me produce un error. Bien, esto es importante tenerlo en cuenta porque puedes tener observables que en algún momento hayan lanzado un error y entonces el valor como por definición el valor de ese signer no sólo queda con los valores o con el valor que se está transmitiendo, sino también con el error. Si tú quieres evitar esto, precisamente está la función rejectErrors que básicamente le dice al tu signer, hey, suscríbase, pero si hay un error. ¿Cómo? Como que no lo tenga en cuenta. Aquí sale el error, pero es este, el del observable. Pero si yo voy y leo el estado, hago read, lo que va a hacer es perdurar el último valor antes del error. Entonces fíjate que cuando yo hago read, pues literalmente aquí me está diciendo, mira, el valor emitido, el último valor como que fue válido sin el error fue 4. ¿Por qué? Porque el error se produjo cuando llegó hasta 5. Entonces si yo quiero simplemente confiar en el toSignal y decirme, mira, descártame cualquier error y déjeme el último valor que fue correcto, que en este caso fue el 4, y rechace los errores, pues puedo tener aquí el rejectErrors. Entonces esto es un escenario bastante interesante. Si no lo quieres así, sino que literalmente el signer tenga el valor del error, inclusive pues el error per se cuando llegue, pues esto sería false, que está por defecto así. Entonces recordemos, cuando llegue a 5, fíjate que acá lo leo, leo el valor, esperemos que dé error, que es hasta 5, ahí está 5. Cuando yo lo leo, fíjate, pues tenemos un error. O sea, está leyendo el error que produjo. Se quedó ese signer con el error. Y ya, entonces eso básicamente es el rejectErrors. ¿Se recuerda? Simplemente si quieres rechazar los valores y tener como un signer limpio con el último valor que fue válido o correcto, pues está este rejectErrors. De nuevo, si lo leemos, pues ya no nos da error, nos queda con el último valor emitido, que pues fue correcto sin el error. Bien, bien, bien. Entonces ahora te voy a enseñar un poco más de cómo se puede hacer esto. Entonces ahora te voy a enseñar un poco más de cómo se puede hacer esto. Ahora tienes tres flags interesantes para trabajar cuando quieras empezar a... Listo, entonces ya tienes tres flags, tres, digamos que banderillas que le puedes enviar a este toSignal de acuerdo a tu caso de uso, ¿no? Y puedes combinarlos. Por ejemplo, el initialValue con un rejectErrors, que fue el que tuvimos ahorita. Lo que sí no puedes combinar es el initialValue con un requireSign. De por sí, TypeScript te da un error. Dice, oye, o uno o lo otro. O le das un valor inicial o lo mantienes sincronizado con el valor inicial del observador. En fin, eso para que lo tengas en cuenta. Lo bueno es que si lo intentas ahorita, digamos, en el código lo intentamos de nuevo. Pero él mismo te dice, no, no puedes utilizar las dos cosas al tiempo. Pero en fin. Entonces ya tenemos tres flags interesantes del toSignal. Y quiero finalizar con uno que normalmente no es un flag más, pero sí es algo a tener en cuenta. Porque normalmente yo estoy utilizando mucho este toSignal para... Normalmente lo que más tenemos o lo que más por defecto tenemos en nuestras aplicaciones. De Angular sobre todo, si estamos manejando peticiones, es que todos los servicios de HTTP Client son un observable. Entonces casi que estoy volviendo a esos observables que venían como request hacia Signals. Y quiero enseñarte algunas cosas, algunas ventajas, que es donde de pronto ya lo puedes utilizar de forma directa en alguna aplicación que tú tengas. Ahora, de nuevo, recuerda que depende al tipo de observable, al tipo de lógica, pues ya puedes utilizar cualquier tipo de observable. Pues ya puedes utilizar cualquier tipo de observable. Y vamos a ver las combinaciones anteriores. Un toSignal con un InitialValue, con un RejectedError, con un RecordSign. Ya depende mucho de lo que tengas. Y vamos al ejemplo ya de utilizarlo con una petición, un request hacia un servidor. Llegamos por fin a este ejemplo, ya aplicando un poco el conocimiento que aprendimos con los demás componentes, con los demás ejemplos de los observables que fuimos creando. Fíjate que acá yo tengo un servicio, un servicio que se conecta a una API. Esta API es fake, que simplemente me da tres locaciones como random, de acuerdo a una coordenada. Entonces, cada vez que le hagas un request, simplemente tienes coordenadas random. Estoy trabajando en esto porque quiero hacer como un ejemplo con Google Maps y Angular. Pero, pues luego te lo muestro. Estás pendiente del canal cuando llegue ese video. Pero, me pareció una buena oportunidad, precisamente por si este video salió, de que en la aplicación, o en el demo que estoy haciendo para utilizar Google Maps con Angular, voy a utilizar un toSignal. Y literalmente es esta línea de datos, que es la línea de datos que yo tengo. Es una línea de código, pero no quería simplemente decir, bueno, utilizamos toSignal y transformémoslo, sino quería como enseñarte, bueno, ese toSignal que tiene por dentro, que no es simplemente ponerlo y darle un initial value, sino de pronto qué casos más me puedo enfrentar, un required sign, un rejected error, etc. Como para no pasar esto de largo. Entonces, literalmente solo por esta línea me surgió todo este video del toSignal. Pero listo, entonces ya tenemos este toSignal, pero sin embargo, voy a mostrarte también algunas cosas interesantes, o de los beneficios que podemos ver un poquito claramente al utilizar el toSignal. Bueno, entonces por acá, por ejemplo, yo le metí un delay también de forma intencional. La API no se demora cinco segundos en darte ese valor, pero acá yo sí le puse un delay. Es decir, hace el request, se demora, demora en emitir el valor cinco segundos. Quiere decir, quiere decir que este observable no tiene un estado inicial, sino hasta que se conecta. Es más, hace el request, se demora, demora en emitir el valor cinco segundos. Quiere decir, quiere decir que este observable no tiene un estado inicial, sino hasta que se conecta. Si yo le quito el delay, tampoco tiene un estado inicial. Si yo lo dejara así y ya, pues me emite el valor, pero sin embargo, se demora un cierto tiempo en traer el request. Este observable, por ejemplo, no tiene un estado inicial. Entonces lo que hacemos es conectar el servicio. Este sería la forma. Entonces lo que podríamos hacer acá es, ok, creo un observable pertinente de esto, de por si getLocations. Esta función me trae un observable que no tiene un estado inicial. Entonces aquí lo puedo tener y convertirlo. Esto me parece un poco más fácil de leer así, pero si tú quieres, en teoría podrías hacer cosas como esta. O sea, para evitar crear una variable, un atributo dentro de la clase. Podrías tener algo como esto ya y literalmente estás transformando de tu servicio. El método que es getLocations lo estás ejecutando. Realmente no lo ejecutas, pues simplemente tienes allí la función que es un observable. Y tu sign-in va a ejecutar esa suscripción de acuerdo al modelo de reactividad y listo. Pero creo que es más fácil de leer cuando lo tenemos así. O sea, sé que tengo un observable que no lo tengo suscrito en el template, así que no va a tener issues de performance. No tengo que utilizar el assign pipe, sino simplemente ya lo tengo en locations. Le tengo un valor inicial que es una radio en vacío, que es el valor inicial y empiezo a operar. Pero listo. Vamos a ver algo interesante y de por si voy a hacer la comparativa con un, como si yo tuviera esto también con una sign. Y ver unas cosas interesantes que pues vimos allí. Entonces déjame ver. Voy a ver aquí porque esto me da error. Ah, pues lo estoy, obviamente estoy duplicando esto. Entonces acá se va este, este let. Lo que tendríamos acá es lo siguiente. Por ahora, por ejemplo, voy a dejar este aquí en nada. Luego vamos a ver qué va a pasar con este cálculo del tamaño con la iteración. Pero digamos que entonces yo quisiera realmente utilizar el clásico assign aquí. Y pues me suscribo con un pipe. Epa, ¿dónde está mi? Palito. Listo, acá está. Assign, listo. Entonces fíjate que este sería locations, pero pues en forma assign. Fíjate que literalmente yo no estoy teniendo un, como un delay. O sea, ya acá es lo que se demora el API. Pero sin embargo, algo que no me esperaba así como directo, tan directo. Es que fíjate que el pipe se suscribe primero o tengo la respuesta primero que location. Ok. Entonces fíjate acá. Si notas que llega primero el valor de este lado que de este. Fíjate otra vez. Siempre, siempre llega primero, ¿ves? Siempre llega primero, siempre llega primero, siempre llega primero este. Entonces casi por definición podríamos tener ya un aumento de rendimiento chiquito de simplemente tener el sign. Es más, aquí voy a hacer esto solo para evitar este let. Si no has visto este let, te dejo un video de qué significa este let. Pero solo para que no nos perdamos. Acá tengo dos suscripciones. Es decir, tengo la suscripción a locations, que es un array. Entonces le puedo hacer punto link y mostrar este numerito acá. Pero también ya luego me suscribo o tengo los valores y simplemente entonces pues lo itero. Entonces fíjate que acá es como si tuviera dos suscripciones. Que realmente no son dos suscripciones. Ahorita vamos a andar un poco en eso. Porque también es bastante interesante. Realmente no estoy ejecutando dos veces la función. Simplemente estoy obteniendo el valor que ya obtuvo. Y pues le digo, bueno, el array de los valores que ya obtienes, dime cuál es el tamaño. Es decir, 5. Y luego ya lo itero con un for. Bien, entonces fíjate que acá está. Ahí está. Y algo muy interesante es que ya por definición esta se renderiza primero. Así que si ya tienes tus signals, pareciera que en rendimiento se suscribe mucho más rápido de esta manera. ¿Qué uso? Utilizando el assign pipe. Bien, el request demora exactamente lo mismo porque es el mismo request. No es como que un request esté demorando más o no. Pero obtenemos el valor más rápido utilizando o transformándolo a tus signals. Pero listo. Aparte de esa cosa muy interesante que noté aquí. Es también algo que puede causarnos errores o de pronto que no sabías con el assign pipe. Que podemos caer en errores. Y es que fíjate algo. Entonces aquí voy a poner el network. Acá voy a dejarme ver. A mi consola que quiero que no haya el timeline. Acá quiero desaparecer este overview. Listo. Para solo ver los requests. Listo. Ahí tengo los requests. Listo. Entonces fíjate que acá tengo dos requests. Claro. El assign cuando se suscribe ejecuta el get location. Es decir, hace un request. Y acá el que realmente se va a suscribir es tu signal. O sea, dentro de la lógica de un tu signal. Se suscribe a su observable y deja esos valores dentro de location. Dentro de. Pues el sign. Pero fíjate que acá estoy en teoría suscribiéndome dos veces que realmente no es una suscripción. La suscripción realmente ocurre acá y luego obtengo los valores obtenidos luego que ya me suscribí. Entonces puedo hacer esto. Pero si yo llevara esto, por ejemplo, yo quiero calcular igual el tamaño como el punto de. De forma observable. Entonces digamos que yo quiero hacer exactamente lo mismo que tengo al otro lado. Fíjate que acá si yo hago esto y. Como que. Intento calcular el punto de. En que el tamaño con una sign pipe. Entonces por acá le pongo un punto de. Y aquí ya tengo ciertas cosas raras porque acá me dice oye, pero esto puede ser un de fine. Claro, porque no tiene un valor inicial, pero lo bueno de pasarlo con tu signal es que ya tenemos un inicial value. Entonces aquí no con el tu signal ya tienes una ventaja. Bueno, tienes la primera ventaja. Hay unas que aparentemente renderiza más rápido. Se suscribe más rápido en el mundo. Y aquí tienes un modelo reactividad de angular en cuanto a monta el componente. El segundo es que como ya le pones un inicial value, pues fácilmente puedes hacer un punto link sin decir esto. Mientras la pues mientras esperamos por el servidor puede venir un de fine. Pues no, ya tienes un valor inicial, cosa que en la aquí en la sign pipe no tienes. Porque pues claro, tiene que esperar el valor. Puede venir un de fine. Entonces tienes que colocar este como nullish collection. Y segundo, si tú quisieras hacer lo mismo como un poquito. Lo que tienes acá, que es. Dos tienes location dos veces y haces el asing. Este cada vez que tú hagas una sang directamente en el template, realmente se está ejecutando el se está ejecutando el request. Entonces casi que estás haciendo dos request y esto puede ser algo perjudicial si no sabes cómo funciona, porque cada asing te está ejecutando la lógica o está haciendo una petición. Eh? Y es más, te lo puedo mostrar acá. Voy a comentar este código. O sea, como aquí este html. Fíjate que si yo comento este código. Algo interesante es que vamos a tener tres peticiones. Por qué? Porque la suscripción ya nos de los al menos con el to sign al no se hace en el templo, sino se hace cuando se ejecuta este to sign. Entonces realmente si yo no quiero esta petición, pues deberíamos también comentar esta parte. Listo, es decir, yo quito casi todo el sign al. Entonces lo que tengo es dos asing. Y como tengo dos asing. Pues se están haciendo dos request. Entonces fíjate que aquí me tocaría utilizar algo como raro normalmente para que sólo se haga una petición. Pues claro, yo podría entonces. Bueno, para no tenerla en pay, pues podría entonces tener un suscribe y pues entonces lo recibo el valor y lo asignó una rai, etcétera. Eso también es válido. Lo único es que pues de pronto se pierde un poquito la simplicidad del código, la elegibilidad, pero es válido que tengamos en el en Gionini. Entonces tengamos. Un suscribe. Lo bueno es que aquí nos nos olvidamos del en Gionini porque sabemos que la sampa y se va a ejecutar realmente cuando el componente ya se está renderizando. Entonces no nos toca utilizar el en Gionini. Ya sabemos que la sampa se suscribe cuando es necesario. El único problema es que tenemos aquí un lecho lexin que cada vez que hagamos una sampa y literalmente está haciendo dos request. Entonces algo que podríamos utilizar como para. Para no hacer eso. Si se quiere solucionarlo en modo a sampa. Ip. Sería hacer un. Suscribirnos sólo una vez. Hacer como esto. Y si no estoy mal con una. Le ponemos location location exacto. Entonces aquí no suscribiríamos una sola vez y luego ya utilizamos location. Acá tenemos location y acá tenemos location. Bueno acá ya no te no podríamos confiar en el punto link y ponemos todo esto acá. Lo que ya. Lo que ya. Acá obviamente está en necesitar la sampa y por qué ya no es un observable. Y ya entonces fíjate que si quisieras evitar eso aquí ya sólo tenemos un request. Está bien, pero no tuvimos como que asegurarnos que nosotros que ejecutamos ese hasta en país ponerle un asociación y pues trabajar con él realmente con el nuevo let. También podríamos ahorrarnos esto. Podríamos tener un let. Con lo que. Es. Lo que data le va a poner data. En modo así y podríamos tener esto un solo asang. Para evitarnos este if y entonces acá quito este if quito este if y tengo de ira. Acá y de ira no estoy seguro si me deje con este. A ver algo estoy acá el punto y como me falta perfecto. Listo acá tengo esto. Sin embargo, fíjate que por acá estoy teniendo el. Escolectivo porque puede venir un de. Entonces me toca colocar acá esto listo. Entonces aquí la única forma de que sólo se haga un request es asegurarnos de que sólo lo hagamos de esta manera. O sea, sólo un payback sang se está ejecutando con antes sólo tenemos un request y luego ya utilizamos pues lo que se obtuvo de esa sang varias veces. Bien aquí con el punto link o aquí para hacer la iteración. Sin embargo, la gracia es utilizar signals. Entonces, pues simplemente pues. Si yo quisiera sólo eso, pues tenemos lo que teníamos inicialmente. Lo pasamos a saber con un valor inicial. Y aquí no habría problema de simplemente llamar dos veces al alzainal porque la suscripción ocurre acá, no en el templito. Y pues en la lógica de negocio de. Del pues el de la forma en que angular le de los cambios o que monta un componente. Él ya sabe que esto lo tienen que ejecutar casi cuando el componente esté listo, que es como hacer una enión y ni automático. Sabemos que esa suscripción o ese método se va a ejecutar sólo cuando el componente esté listo para renderizarse. Entonces nos olvidamos de alguna manera de tener que hacer un enión y ni y decirle a mira cuando estés listo componente, haz la petición. Porque lo clásico que tenemos que es válido es tener algo como esto. No está. Tenemos el suscribe y el suscribe. Entonces acá tenemos la data y la data la ponemos en una raíz. Es más, podríamos hacer esto. Podríamos. Tener un sign al y entonces así. Entonces. No sea un sign al aquí con la data y hacer un punto. Hacer un punto usted de eso y listo. No, esto sería la forma clásica y está bien, no está mal. Al final tienes un poquito más de control. Sabes lo que está pasando, pero pues. Con tus años ya como que empiezas a hacer cosas como automáticas un poquito más limpias, pero igual es válido si lo quieres tener con una niñita. Listo, entonces acá ya tienes location. No te preocupas de si estás ejecutando doble o si estás ejecutando. No te preocupes de si estás ejecutando doble o si estás ejecutando doble. No te preocupes de si estás ejecutando doble o si estás ejecutando doble. No te preocupes de si estás ejecutando doble o si estás ejecutando doble. Es la suscripción. Sabes que esto es tu sign al. Solo lo va a ejecutar una vez y es más, si te molesta igual tener esta doble suscripción, igual puedes utilizar un let. No es necesario, pero también a nivel de forma de lectura de código también está bien simplemente ejecutarlo una vez. Y acá tenemos data normal, digamos. Y acá tendríamos data. Y data. Entonces. Acá sí se corren dos dos request. Uno porque uno se está ejecutando. Acá y uno que es la sign que se está ejecutando acá. Dos suscripciones, dos veces. Entonces fíjate que acá de nuevo si hago request. Pues tengo este comportamiento por defecto que pareciera que el sign al se ejecuta más rápido. Entonces casi que si ya eliminamos todo lo que sea la sign pipe, nos queda un poco el código que teníamos hace un momento. Déjame ver por qué no me está. Ah claro, eliminé el div acá. Listo. Entonces si ya vuelvo a mi código inicial, que es el que literalmente tenía inicialmente. Es esto. Literalmente esto es un código que es muy, tiene muy buen rendimiento. Se suscribe sólo cuando es necesario. Casi que se suscribe cuando el componente está listo, que es lo que normalmente hacemos con el ngOnInit. Pero ya lo tenemos listo sin necesidad de hacer como varios trucos. Sin necesidad de utilizar el sign pipe dentro del template y de pronto ver que cada vez que nos suscribamos se está ejecutando. No. Tenemos varias ventajas. Tenemos un initial value, etc. Este sería nuestro código final y es precisamente lo que desató este video. Porque yo podría simplemente decir bueno, tengamos esto y convertámoslo a tu sign al y démosle un valor inicial y ya listo. Acá iteramos. Pero quería pues hondar en qué es el status sign al, cuáles son estos casos, cómo podemos empezar a trabajar con ello, etc. Y listo. Eso fue todo. Espero te hayas gustado este tutorial. Creo que me quedó un video un poquito largo, pero la gracia es como explorar como estas diferentes formas de hacer. Como estas diferentes formas de empezar a reutilizar la lógica que ya tenemos en RxJS. No borrarla. Pero sí con tu sign al podemos empezar a utilizar este nuevo patrón de reactividad que tiene un mejor rendimiento en Angular. Que promete mucho que tiene una interoperabilidad con todo lo que está preparando Angular con los sign al inputs, con los query en forma de sign al, etc. Angular está como abrazando sign al. Y tu sign al es una forma de no borrar todo tu código reactivo en Angular. No borrar todo tu código reactivo en Angular. No borrar todo tu código reactivo en RxJS. Porque sigue funcionando, sigue siendo funcional. Si tienes pipes, si tienes lógica ya muy fuerte con RxJS, la puedes mantener. Y si quieres utilizar sign al ya para renderizar esos valores que te dan esos observables, pues ahí es donde nos ayuda mucho tu sign al. Y por eso quise hacer como todo este video, como con diferentes observables, diferentes tipos de observables, diferentes banderas que nos permite tu sign al. Y ver cómo ya lo podemos utilizar en el día a día. Así que recuerda que si quieres ver más videos como este, no olvides suscribirte a nuestro canal. Así que recuerda suscribirte a este canal. Déjame en los comentarios si te gustó. Espero no haya sido algo complicado. Realmente trabajé como en estos componentes para tener diferentes escenarios y cómo podríamos utilizar estos sign al. Y finalmente llegamos a ese último, que es como en donde yo los estoy utilizando más. Que es simplemente una petición que tenía con... Y esa petición o ese método en ese servicio, que es el de catalogations, puede tener un pipe con lógica. Con cosas que normalmente tenemos en el servicio que ya están en el sistema. Que ya están en RxJS. Y simplemente utilizo esa lógica y cuando lo conecto al componente, lo paso en tu sign al de esa manera con un initial value y ya. Pero pues quería ahondar mucho en las diferentes formas en que podemos encontrarnos de pasar observables a sign als con esta función. Así que comparte este video, suscríbete. Bueno, me harías feliz si comentas, etc. Así que nos vemos en la siguiente. Hasta la próxima.