 Hola, hoy te voy a enseñar acerca de una nueva novedad en JavaScript que se lanzó recientemente, quizás no la conozcas, pero ahora se pueden declarar métodos y propiedades privadas directamente desde JavaScript, sin necesidad de TypeScript. O sea, esto ya lo soporta directamente el lenguaje, es decir, directamente JavaScript. Lo hace de una forma un poco rarita, con un hashtag al inicio de las variables, pero precisamente te voy a enseñar cómo, cómo precisamente lo podemos diferenciar de cómo lo hace TypeScript, si trabajas con TypeScript y cómo ya lo aplicamos en algún proyecto. Así que, iniciemos. Y podemos ver acerca de esta nueva opción en la documentación acerca de JavaScript, sobre todo lo más normal que es la de Mozilla. Y aquí podemos ver que ya se pueden declarar variables privadas, también métodos, se pueden declarar directamente dentro de JavaScript, sin necesidad de ningún preprocesamiento. Ahora, fíjate que la forma de... Voy a declararla, y aquí es donde de pronto no me gusta tanto la forma en la que lo utilizaron. Yo me hubiera quedado, por ejemplo, con la variable private, porque ya nos tienen muy acostumbrados TypeScript a esto, pero aquí literalmente la convención, la forma de decirle a JavaScript es gracias a un hashtag antes de la variable. Esa sería la forma de decirle, oye, esta variable es privada. Y no solo en las propiedades, en los atributos de una clase, sino también en los métodos. Si yo le pongo este hash al inicio de un método, significa que la forma de acceder a ese método, a esa propiedad, va a ser de forma privada. Para entenderlo mejor, vamos directamente al código. Por ejemplo, acá yo tengo una clase de ejemplo, te la voy a explicar rápidamente, pero la verdad no es nada del otro mundo. Acá tengo una clase llamada ProductService, que va a ser como aparentemente una clase que me va a ayudar a resolver cosas con los productos. Y fíjate que acá tengo la forma directa en TypeScript. Acá tengo la palabra reservada de TypeScript, private, en donde le digo, mira, tú tienes un límite que es number, un array de productos que ahorita es como un array de string. En el constructor los inicializo, es decir, envío esas propiedades. Y luego fíjate que acá tengo un método. Este método, por definición, si yo no le coloco ningún acceso, es público. Es decir, por defecto es public. Pero si yo no se lo coloco, igual es public porque es el by default. Sin embargo, acá, literalmente, cuando yo... Yo agrego un producto, voy a checar el límite, es decir, si el tamaño del array sigue siendo menor al límite de productos que tengo. Pero fíjate que este, este método sí es privado. Entonces, si esa condición se cumple, entonces yo puedo insertar ese producto, ese nuevo producto a la lista. Y si sí o si no, si lo puedo insertar o no, igual siempre retorno a la lista de productos. ¿Ok? Entonces, por ejemplo, probemos estos accesos desde el lado de TypeScript. Y veamos un poquito cuál sería el cambio. Si lo haríamos desde el labro nativo de JavaScript. Aquí, por ejemplo, entonces ya para utilizar esta, pues esta instancia. Entonces acá yo podría crear una constante. Y le voy a decir... Voy a correr un poquito por acá. Listo. Entonces le voy a decir que quiero una instancia en New Product Service. Ahí está. Y fíjate que, pues lo inicializo como con un array de dos productos. Y dice que el límite va a ser de cinco. Perfecto. Entonces ahora yo puedo o yo podría simplemente agregar un producto. Por ejemplo, Orange, ¿no? Como un nuevo producto. Y esto literalmente debería retornarme a la lista de productos. Entonces yo le podría hacer un console.log. Console.log. Y puedes ver qué onda, ¿no? Ver como, hey, ¿cuál sería el resultado? Según mi autocompletador, que muchos me han preguntado como qué utilizo para autocompletar código. Esto es GitHub Copilot. Es la IA de GitHub en la cual infiere un poco el contexto del código que estoy haciendo. Y me va autocompletando. Entonces según él, esto va a ser la respuesta. Y sí, y va a ser verdad. Y luego si quieres, déjame en los comentarios si quieres un video acerca de GitHub Copilot. Me parece una herramienta, una IA muy interesante que he estado utilizando. Pero listo. Veamos qué es esto. Veamos un poco qué pasa con esto. Fíjate que si yo como, como límite y productos son privados, yo no podría hacer cosas como ir a la array de productos, ¿no? Es más, ni siquiera, ni siquiera me autocompleta. Porque el único método al que yo puedo acceder. El único método público es addProduct. Si yo hiciera products y tratará de como, por ejemplo, reiniciar toda la lista y dejarla en cero, él no me deja. Me dice, oye, este método es o esta propiedad es privada y no se puede acceder. El único que tiene el permiso, digámoslo de alguna manera, de acceder es la misma clase porque es privada. Entonces aquí ya me da un error y no me dejaría compilar mi código. Bien. Esa es la función de private. Tampoco podría hacer. Por ejemplo, acceder a checkLimit porque igualmente es privada. Entonces si yo es más, si lo llamo a ejecutar como que lo ejecuto igual tampoco me permite porque este método sólo se puede ejecutar en el contexto directo de la clase. Pero como es privado, pues no lo puedo ejecutar desde afuera. El único método público es addProduct. Listo. Entonces esto es como ya funcionaba TypeScript. Veamos cómo funciona ya directamente dentro de JavaScript. Pero antes de eso igual hay que recordar. Voy a comentar un poquito este código. Entonces voy a comentar esto por acá, por acá, por acá. Hay que recordar que al final TypeScript es un superset, pero los navegadores no entienden TypeScript. No entienden como tal el typing. Si bien hay una iniciativa para hacer para agregar el tipado directamente en JavaScript, aún está en trabajo. Todavía no se ha progresado mucho con ello. Entonces todavía no tenemos tipado en JavaScript. Entonces realmente todo esto de lo que es JavaScript. Es realmente todo esto de los tipos y este private realmente cuando nosotros construimos o pasamos esto a JavaScript puro, pues realmente sí se puede acceder. Veamos un momento a lo que me refiero. Acá, por ejemplo, entré al playground de TypeScript. Entonces voy a copiar mi código. Este es el de acá. Y vamos a ver un poquito cuál sería la como el producto ya después de pasar de TypeScript hacia JavaScript, que es lo que soportan los navegadores. Si yo realmente miro todo lo que es el tipado se perdió. Y todo lo que es private también se perdió porque realmente eso no existe dentro de JavaScript. No es nativo de JavaScript, así que no lo podría como poner allá. Entonces nosotros cuando transpilamos este código en JavaScript va a quedar de esta manera. Perdemos obviamente esta forma de acceso private porque no es nativa. Entonces casi que products quedaría pública y checklimit también queda pública. Recuerda también que tú puedes cambiar cuál es tu target. Por ejemplo. Algo que sí soporta ahorita JavaScript son las clases. Antes no. Por ejemplo, si yo llego a cambiar esto a una versión viejita de JavaScript, lo más normal es que lo que haga es utilizar funciones. Porque antes de pronto si vienes de la vieja escuela de JavaScript, antes no existía una clase como tal en JavaScript. Entonces lo que hacíamos es utilizar como el mundo de las funciones para aparentar el funcionamiento de la programación de objetos. Entonces acá hacíamos una función y utilizábamos el prototype. Y bueno, y un montón. De como de hacks que se hacían en JavaScript para poder utilizar como el patrón de programación en el estado de objetos. Pero si yo ya lo cambio allá, pues al más moderno, realmente el único cambio aquí que nosotros vemos es que el typing no está porque eso sí no lo tiene JavaScript aún. Y este forma de acceso el private no existe aún y es lo que precisamente te va a mostrar hoy. JavaScript ya lo habilitó y de forma nativa. Igual voy a hacer un ejemplo ya con el código. Pues compilado o transpilado más bien por TypeScript y veamos que sí puedo acceder. Entonces voy de nuevo a mi código. Listo, ya sabemos que TypeScript nos soporta y no nos deja acceder gracias a esta palabra reservada private. No nos deja acceder a estos y es más, si yo no logro acceder aquí ya me dice que hay un error. Si yo hago esto me dice y no compila mi código, no me va a dejar compilar mi código. Por ejemplo, ahorita pues yo estoy utilizando mi Visual Studio Code. Y me alerta, pero qué pasa si yo trato de compilar este código o transpilar este código. Veamos, entonces, por ejemplo, si yo corro el transpilador que es de esta manera aquí debería decirme oye aquí hay un error. No te puedo dejar, pues transpilar ese código porque no se podría acceder. O sea, estás haciendo algo indebido. Entonces, bueno, pues eso está bien. Perfecto. Lo comenta. Voy a volverlo a intentar transpilar. Ahí está. Vamos a ver. Listo, se transpiló. Veamos el resultado. Por aquí esto queda en la carpeta dist. Y vamos a abrirlo por aquí como para tener el antes y el después. Entonces, fíjate que pasa un poco lo que pasaba en el pre-learn. Creo que lo voy a poner aquí nomás. El pre-learn y es que pues perdemos el typing, perdemos el private. Y acá está nuestro código. Esto fue la forma en la que al final esto quedó convertido en JavaScript puro. Que es realmente lo que leen los navegadores. Los navegadores todavía no soportan TypeScript. Ahora lo que sí hay y lo que sí ha habido un poco más de avance es que los runtimes de JavaScript sí están soportando ahora TypeScript. Node ahora el runtime o dentro de Node podríamos ya hacer TypeScript directo y él lo soporta sin necesidad de transpilarlo o sin utilizar TS Node, por ejemplo. O servidores como Dino, como BoomJS ya soportan TypeScript by default. Entonces no hay que transpilarlo. Y ya directamente ni siquiera utilizaríamos JavaScript, sino directo TypeScript. Sin embargo, el navegador sigue siendo JavaScript puro. Así que no podemos correr archivos TypeScript. Entonces aquí ya quedó nuestro archivo. Luego ya de utilizar TypeScript al final se transpila. Y ese es el archivo JS que normalmente los empaquetadores como Webpack, como es Build, pues también hacen este proceso de transpilado de nuestros archivos TypeScript. Luego los hacen más procesos, los modifican, hacen optimizaciones. Y finalmente es lo que nosotros distribuimos a nuestros usuarios. Pero veamos que si yo le quito este comment. Literalmente yo sí en JavaScript podría reescribir productos, podría acceder a CheckLimit sin ningún problema. Porque realmente TypeScript lo que me hace es prevenirme antes de transpilar. Una vez transpilado yo puedo igual tener los archivos JavaScript. Y poder hacer un test. Y ya utilizar como las cosas que, por ejemplo, acceder a estas variables que no están protegidas. Por ejemplo, de nuevo, yo puedo resetear los productos o llamar a CheckLimit sin ninguna restricción. Porque Private no existe dentro de JavaScript aún. Pero igual ejecutemos este archivo. Porque precisamente si nosotros esperaríamos que el resultado sea. Es más, acá deberíamos tener el resultado. A ver, ¿cómo es que era? Ah bueno, debería ser Apple, Banana and Orange. Pero aquí como yo pude acceder, lo reseteo así que solo debería tener un producto. Si yo ejecuto este archivo JS en Node, veamos a ver qué pasa. Entonces voy a tener Node, voy a ir a mi carpeta Disk, que es donde quedó mi archivo. Y voy a llamar a service.js, lo ejecuto. Y fíjate que el resultado es Orange. ¿Por qué? Pues porque acá tenemos ese console.log. Entonces este Orange, pues no es lo que esperábamos. Porque nosotros aparentemente queríamos proteger products. Y literalmente lo pude acceder fuera de la clase. ¿Esto por qué? Porque literalmente ya estoy tocando los archivos transpilados de JavaScript. Y los estoy como modificando. Normalmente esto nunca lo hacemos porque si estás trabajando con React, Vue, Angular. Estos archivos quedan súper, o sea, no solo se transpilan, sino hacen otro tipo de cosas. Hacen chunks, entonces los parten en diferentes partes. Hacen optimización, hacen obfuscación. Así que sería muy difícil ir al archivo JavaScript, ver dónde queda nuestro service. Y empezar a modificarlo como un poco hacking, digámoslo de alguna manera. O pues tratar de modificar ya el archivo JavaScript. Que sin embargo también sería contraproducente porque cada vez que haga un nuevo build, se vuelve a reescribir eso. Entonces como que no podría. Pero pues podría ser una opción. Yo podría ir a los archivos JS finales. Y introducir algo ahí raro. Por ejemplo en este caso acceder directamente a products. Porque literalmente no debería poderse acceder. Pero pues en JavaScript no existe eso aún. Y es lo que te voy a enseñar. Cómo ya existe esto en JavaScript. Entonces listo. Ya tenemos acá el ejemplo con TypeScript. Cómo funcionan ahora las variables privadas directamente en JavaScript. Nativamente en JavaScript. Pues realmente lo único que tenemos que hacer es cambiar la palabra private. Por el hashtag. Que si me preguntan a mí. No me gusta mucho el hashtag. No sé por qué no se llegó a utilizar el mismo nombre private. Sé que también puede ser por compatibilidad. Por no chocar precisamente con lenguajes ya establecidos con JavaScript. Y cambiar el comportamiento. Entonces lo que decidieron fue utilizar el hashtag. Aquí tienes que utilizarlo. Cuando veas esto no es que es una convención. Es que vamos a llamarla de esta manera. Porque normalmente nosotros a veces tenemos convenciones. Por ejemplo una convención muy normal en observables. Es que si yo tengo un observable. Tengo un un listar por ejemplo. Yo le pongo un signo pesos al final. Y fíjate que esto ya lo reconoció. Como que yo quisiera declarar un observable. Y pues acá está definiendo un tipo de observable. Esto sería una convención. Como cada vez que creemos un observable. Pongámosle como un signo pesos al final. Porque como que lo podemos identificar. Porque dentro del equipo podemos identificar. Que eso es un observable y no una variable. O un atributo normal de la clase. Pero este hash no es una convención. Es literalmente la forma de darle un acceso. Público o privado a este atributo. Entonces obviamente aquí pues ya la forma de acceder. Sería igual con el hashtag. Entonces acá está el hashtag. Fíjate que acá si yo quiero acceder a products. Como es privado. Pues debería utilizar el hash. Y retornar acá al hash. Ahora fíjate que. Bueno acá también tendría que poner el hash. Y ya lo estoy pasando. Ya no estoy utilizando private. Sino es literalmente el hash. Que sería la forma nativa. Que lo puede hacer. Y fíjate que lo estoy haciendo dentro de TypeScript. O sea no estoy haciendo JavaScript. Todavía estoy utilizando TypeScript. Solo que al transpilar. Pues al final yo puedo utilizar. Recordemos que al final TypeScript es un superset. O sea le aumenta habilidades. O sea de las que ya tiene. Le aumenta habilidades a JavaScript. Como el typing. Como los modificadores. Pero cuando ya existe este feature dentro de JavaScript. Pues no es necesidad de aumentarle. Ya simplemente utilizamos lo nativo de JavaScript. Y no es necesario utilizar private. Pero podemos seguir utilizando TypeScript. Básicamente en conclusión. Cualquier nuevo feature que utilice JavaScript. Pues igual ya lo podríamos utilizar en TypeScript. Con todas las mandadas que ya nos da TypeScript. Después del typing y demás. Pero listo. Acá entonces. Acá también los métodos. Si yo los quiero privados. También les pongo un hash. Y por ende también los llamo como hash. Listo. Entonces aquí literalmente ya lo transformé. Entonces ya estoy utilizando la forma directa. De utilizar private en JavaScript. Que igual lo puedo tener. Y lo puedo ya unir con mi código de TypeScript. Entonces que pasa si yo vuelvo a hacer el mismo comportamiento. Fíjate que. Bueno aquí ya me va a dar un error de. Oye eso no es. O sea literalmente ya no es un error de acceso. Sino que esto no existe. Bien. Products. Acá dice. Oye. La la. El atributo products o la property products no existe. No estoy llamando algo que no existe. Y yo le digo. Ah yo sé que no existe. Porque está con hashtag. Pues no. Literalmente acá dice. Oye. Listo. Ya le diste a la que ves. Eso sí existe. Pero eso no es accesible. Esto es private. Entonces igual no puedes acceder. No podrías acceder a ese atributo. Entonces. Igual lo voy a comentar. Para luego ver que en JavaScript. Nativamente. Si tampoco voy a poder acceder. Entonces pues. Veámoslo. Entonces. Acá. Ya sé que en TypeScript. Tengo el mismo comportamiento del private. Normal. O sea. Me deja. No me deja acceder. Pero. Veamos si en JavaScript. Ocurre lo mismo. O sea si. Literalmente. Pues ese sería el punto. Entonces voy a volver a transpilar. Entonces voy a ir acá. Voy. Voy. Transpilo. Hago ts. Listo. Veamos cuál fue el resultado. Aquí. Aquí está mi. Y fíjate que acá. La transpilación. Pues lo que perderíamos. Es el typing. El typing. Si todavía no es soportado. De forma nativa. En JavaScript. Pero este hashtag. Si. Lo puso. Y no es un naming. O sea. Literalmente. No es como. No es que así llamamos a las variables. Así es la cultura del equipo. Para llamar a ciertas variables. Literalmente ese hash. Dentro de JavaScript. Va a tener un behavior. Un comportamiento especial. Que es proteger esas variables. Del acceso. Público. Entonces. Antes. Si yo. Utilizaba el hack. Y decir no. Pues realmente. Yo puedo ir a JavaScript. Y modificar ese comportamiento. Porque. Private. En JavaScript no existe. Pero ahora con este hash. Sí. Fíjate que. Literalmente. Si yo ejecuto esto. En nativo. En JavaScript. Esto si no me deja hacerlo. Y si yo lo ejecuto. Ejecutamos el archivo. Con note. Entonces. Si yo voy. Ejecuto el. El archivo. Service. Service. Y listo. Acá. Literalmente. Ya tengo un error de ejecución. Directamente. En note. Que es el runtime. Que está ocurriendo ahorita. En JavaScript. Me dice. Oye. Products. Está declarado como privado. No puedes acceder a él. De forma nativa. No puedes acceder a él. Entonces. Ya es. Es una forma nativa. De proteger. Pues. Propiedades. Métodos. Y realmente. De tener private. En JavaScript. Y así vemos. Como por ejemplo. Nosotros. Tenemos. Ya. Ya tenemos. Tenemos. Una nueva. La nueva. Lengua. Es. Una nueva. Lengua. De forma. далinera. Necesitamos. Una nueva. Lengua. De forma. De forma. Necesitamos. Nuevas. Características. Que. Si bien. Utilizamos. TypeScript. Como. Super. Set. Como. Una forma. Esto viene de JavaScript, al final TypeScript es un superset, así que también lo podríamos utilizar por definición en TypeScript. Entonces te invito a que abra la conversación, por ejemplo, en tu equipo de, mira, ya existe una forma nativa de hacer private en los métodos, en las funciones, en las propiedades de nuestras clases. Si realmente queremos protegerlo, no solo en TypeScript, pues también ya lo podemos hacer en los archivos transpilados, que al final son en JavaScript, en el archivo real, en la ejecución real, en el entorno de JavaScript real, pues allí también lo estaríamos protegiendo, no solo en TypeScript. Aunque con TypeScript era suficiente, pues normalmente uno no va y modifica ese archivo directamente. Es muy difícil que alguien tenga acceso a los archivos o al servidor donde se están desplegando esos archivos, al CDN, como para hacer modificaciones. Si bien también lo podemos como medio encontrar en nuestro navegador y tratar de hacer alguna modificación, realmente no podemos hacer mucho con ellos, pero igual es una forma interesante de que ya JavaScript tiene la potencia de hacerlo. Y si tú estás utilizando TypeScript, pues ya sabes que también ya lo puedes hacer nativamente y quedas protegido por los dos lados, por TypeScript como tal, porque igual no se puede acceder utilizando este nuevo hashtag o esta forma nativa de declarar variables privadas, pero también en el archivo transpilado que es JavaScript. Ahora, si de pronto estás corriendo en un entorno ejecución donde por definición es TypeScript, como Tino, como Boom.js, por ejemplo, que directamente ellos ya como que soportan TypeScript by default y no JavaScript, entonces pues allí podrías seguir utilizando private o el hashtag igual es un supersat de JavaScript, o ya en entornos en donde si utilizas el archivo JS en algunos servidores de Node, por ejemplo, o en el navegador, pues ya tendrías esa protección extra de los dos lados. Ahora, un bonus extra, sobre todo si tú estás utilizando Angular, pues realmente no es tan bonito, porque es exactamente ver cómo esto se comporta en Angular, pero pues quería dejar el ejemplo, pero si tú utilizas React o Vue, pues igual ya puedes y si tienes programación orientada a objetos, pues ya puedes empezar a protegerlas de esta manera, pero veamos un ejemplo chiquito en Angular de que simplemente podemos cualquier variable que antes teníamos con private utilizar al hashtag y en Angular pues sigue funcionando todo bien. Veamos. Ahora, por ejemplo, esto es un proyecto de Angular normal en donde, por ejemplo, normalmente tenemos servicios. Acá, por ejemplo, tengo el producto. El producto service ya como en forma o con las convenciones del framework de Angular. Acá tengo un injectable con un decorator, pero acá fíjate que yo tengo una inyección de dependencias que es de HTTP y acá tengo private. Entonces, literalmente ya podría empezar a ajustar esto y simplemente utilizar este hash. Obviamente aquí me tocaría empezar a donde lo llame, pues utilizar el hash. Pero ya. Lo podemos utilizar, o sea, literalmente cualquier persona que se utiliza en el producto service no podría acceder a HTTP porque sigue siendo privada tanto en TypeScript como ya en el archivo transapilado. Entonces, por ejemplo, veamos quién utiliza producto service. Normalmente debería ser el módulo de productos. Entonces, por acá tengo un componente, acá tengo la tabla. Ahí está. Acá tengo. No, este no lo inyecta. Product. Debe ser este de acá. Tanarán. Miremoslo. Acá, product service. Fíjate que acá tengo esa inyección de dependencias. Acá tengo también private. Fíjate que tengo varios private. También podríamos empezar a decir, hey, pues todo esto es privado. Y recuerda, esto no es una convención. Es la forma en que JavaScript ya nos dice, pues cómo realmente empezar a hacerlo. Entonces, obviamente aquí me tocaría empezar a decir, bueno, este router viene de esta forma. El UI service viene de esta forma. Product service de esta forma. Categories de esta forma. Ahí está. Y pues ya todas esas variables privadas quedan de esta manera. Ahora, de pronto, de nuevo, a mí me parecía mucho más explícito el private porque alguien lo puede leer y decir esto es privado y ya. O sea, literalmente es elegible. Aquí como que uno se empieza a preguntar por qué le pusieron un hashtag al variable. Será una convención del equipo para ciertos tipos de atributos. O sea, como que toca explicar. Ah, es que. Esta es la forma en que JavaScript ahora soporta cosas privadas. Yo creo que también mientras todos acogemos de pronto esta nueva función o esta nueva característica, pues va a chocar un poquito. Como por qué hay un private? Por qué ese hashtag? Ahí quitemos esto. Por qué esto está ahí? Alguien podría sin el conocimiento decir qué carajos es esto? No sé por qué están haciendo eso. Pero tenemos que recordar o de alguna forma decir, oye, es que lo que pasa es que ahora esto es la forma. Por ejemplo, en los code reviews decir no. O al equipo ya expresarle. Miren, ahora vamos a usar esto porque esto nos da una protección extra, tanto en TypeScript como en la transpilación. No? Y lo que tenemos que acostumbrarnos es este. Ahora también he visto mucho en TypeScript que ya sabiendo que esto es private y que tenemos el hashtag aquí. Yo he visto muchos que empiezan antes a utilizar el read only. Entonces no solo le dicen que es privado, sino que es. Es solo lectura. Entonces yo no puedo hacer modificaciones a esa variable, sino que es solo read only. Yo he visto mucho, por ejemplo, en el contexto de Angular, que entonces casi que cambiaron la palabra reservada private por read only o muchos de por sí ya tenían como el doble read only private. Es más, creo que entonces esto es antes para hacerlo doble. Ahí está. Entonces tenían como el doble, doble protección. Una que es la privada, que es el formato. Y si soy otro, rid only, que es básicamente que yo no puedo empezar a hacer modificaciones a esta instancia. No puedo reescribirlo, no puedo. Solo es de lectura. Una vez ya esté la declaración, que sería normal en una clase, en una inyección de dependencias. O sea, como yo, porque voy a modificar o reescribir ese esa inyección o esa instancia aquí. Entonces le poníamos un rid only. Aparte de que solo se podía acceder de forma private. Entonces ahora pueden quedarse con las dos. Rid only y esta sería la convención, digamos, oficial. Entonces ahora le pongo rid only y más el private, que ya sería nativo de JavaScript. Ahora entonces sabes que como desarrollador de JavaScript o TypeScript, pues ese hashtag significa el forma de acceso. No es ninguna convención, no es nada de eso. Es literalmente la forma de darle el acceso, de proteger el acceso a ese método, a esa variable directamente en JavaScript. También lo puedes ya hacer. En TypeScript y tienes la protección desde ambos lados, desde TypeScript y desde ya el archivo transpilado. Entonces ya tienes una doble protección por los dos lados. Y eso es bastante interesante. De pronto nos va a costar un poco al inicio, pues como acogernos a esta nueva forma, porque realmente private era más fácil de leer. O sea, literalmente cualquier, cualquier persona que leyera nuestro código y vea private, pues él ya se daba cuenta que esto es privado. Es más, si vienes de otros lenguajes. Como .NET, como Java, literalmente ya como que es fácil llevar este conocimiento y decir, ah, mira, esto es privado. Este método es privado. Este atributo es privado. Ahorita como que este hashtag, pues nos va a costar un poco que cualquier persona diga, tal vez es una convención. Tal vez es algo que el equipo tiene para llamar ciertos atributos. Pero no, realmente es la forma de decirle qué forma de acceso tiene eso, si es privado o público. Pero pues precisamente es mientras yo creo nos acostumbramos. Luego ya en un futuro es como que cualquier persona que esté leyendo TypeScript, al menos TypeScript o JavaScript, sabe que esto es una forma de expresar variables privadas. De pronto para alguien que esté en otro lenguaje, si le va a costar y decir por qué, qué carajos es ese hashtag al inicio de las variables. Le toca preguntar al equipo y no sea tan intuitivo como leer la palabra private en tus atributos o en tus métodos. Pero así es, así literalmente es, así decidieron. Literalmente esto no está en beta, literalmente ya está dentro de JavaScript. ¿Viste qué? Por ejemplo, cuando yo le dije que en Node ya se soportaba sin ningún flag, nada. Esta posibilidad de proteger las variables de forma directa o nativa de JavaScript ya está habilitada. Ya, o sea, como que ya esto no lo van a cambiar. No es como no, pero es que esto está todavía en desarrollo. Posiblemente le cambien la forma. No, esto ya quedó con hashtag al inicio para declarar las variables privadas. Así que déjame en los comentarios saber qué te parece, si te gusta, si no te gusta. Desde algún punto, por ejemplo, me gusta. Pues obviamente que JavaScript esté evolucionando. Que ya necesitemos cada vez menos de TypeScript para tener estas ventajas poderosas dentro de JavaScript. Sin embargo, sigo muy fiel a TypeScript y su inferencia, sobre todo su typing. Es una cosa que espero que llegue a JavaScript también en su momento. Pero mientras tanto, pues simplemente vamos a esperar pacientemente. Y también empezar a aprovechar estas ventajas que pues va teniendo el lenguaje. Y pues es un signo de que está madurando y yendo hacia un buen camino. Déjame en los comentarios. Qué te parece si te molesta también el naming como a mí o si igual no importa. Simplemente lo tenemos que acoger, evangelizar y ya pues compartir dentro de nuestros equipos. Así que recuerda suscribirse a este canal. Si te gustó, dale like, compártelo. Déjame en los comentarios saber tu opinión y nos vemos en la próxima.