 Este es el post oficial en donde literalmente el líder, Minko, el que ahorita lidera a Angular, nos trae todo como un blog super extenso de las nuevas actualizaciones y vamos a ir desminuzándolo uno a uno. Una de las cosas que podemos ir viendo es aquí que nos dicen que está preparado para velocidad, o sea, básicamente piensan mucho en el performance y básicamente nos comenta acerca de que ellos ya habían hecho como cierto partnership con un equipo interno que hay en Google que se llama el equipo Aurora. Este equipo normalmente está conformado pues como el riesgo de estas tres personas, pero básicamente lo que hacen es que dentro del equipo de Chrome o de web development de Chrome, empujan hacia cómo hacen para que los frameworks tengan mejor rendimiento, sobre todo que esta parte, los coreware vitals, estos coreware vitals, tengan un buen performance sin importar a qué framework tú estés desarrollando. Normalmente es un equipo transversal, sin embargo, pues trabajan muy de la mano con equipos como Angular, como Ness y parte de este partnership fue sacar cosas como el defer, cosas como el NGRC para optimizar. Imágenes, pero precisamente en este punto vamos a ir a ver qué Angular tiene una cosa más a avanzar y es lo que nos traen en esta versión es un incremental hydration. ¿Qué es el incremental hydration? Acá tenemos un demo muy interesante en el cual nos muestran como ciertas partes de la aplicación que están como oscuras, como que están en gris, no es porque así esté, es como intencional para que veamos cómo funciona el incremental hydration. Y aquí estamos hablando de server-side rendering. ¿Qué significa? Que normalmente nosotros tenemos toda la aplicación renderizada del lado del servidor y para este tipo de productos que es un e-commerce, tú necesitas o vas a necesitar que tu aplicación esté renderizada del lado del servidor. ¿Por qué? Porque tú necesitas optimizar SEO, que es básicamente la optimización para que los motores de búsqueda te encuentren. Tal vez si manejas aplicaciones de tipo dashboard, no le saques tanto el jugo, digamos, a esta característica. Porque normalmente este tipo de aplicaciones sí se renderizan totalmente desde el lado del cliente. Y ahí es donde había una disyuntiva en Angular. En Angular siempre se vio muy involucrado como en aplicaciones enterprise, en dashboards, en formularios, como muy enterprise. Pero ya aplicaciones que van a un público masivo, como por ejemplo un e-commerce que tiene muchas visitas y que realmente no es como que yo entre a través de un login a mi aplicación, sino que es el público en general. Ahí es donde Angular de pronto no era tan chévere, tan bueno. Y ahí veníamos cosas como Astro, veníamos cosas como Nest, pero precisamente ahora Angular le está poniendo mucha atención al server side rendering. Y una de esas cosas que, por ejemplo, no tienen es que es una de las cosas que en el ecosistema de hoy día que están tratando de solucionar con los server side components. Pero aquí básicamente tenemos una forma de renderizado. A ver si... Ahí. Una forma de renderizado en el cual renderizamos todo. Entonces, el usuario va a tener que hacer un clic en el lado del servidor y a medida que el cliente o que nuestro usuario va como clickeando, esos componentes van cobrando vida, que es el high vibration. Porque normalmente nosotros en Angular construimos aplicaciones altamente interactivas. No es como que va y renderiza. Normalmente tenemos efectos, tenemos que si le damos clic aquí, esto interactúa con esto de forma reactiva. Pero toda esa interacción solo se habilita cuando el usuario empieza a navegar. Y eso no es un problema. Eso nos ahorra un montón de peso en la aplicación. Porque normalmente la estrategia por defecto es renderizar todo el contenido. Y si queremos hacer high vibration, que es como por ejemplo lo hace React, él como que hidrata toda la página. Como que le da vida desde el lado del cliente cuando llega al browser. Aquí lo que nos está mostrando Angular es que lo va a hacer de forma incremental. A medida que el usuario va clickeando, va poniendo como que vida a ese componente en específico. Haciendo que el performance de nuestra aplicación funcione bastante bien. Entonces, esto es una de las novedades. Digamos que se parecen algo al Resumability de Quick. No es exactamente igual, pero sí tiene un buen símil de realmente hidratar o activar el JavaScript que realmente es necesario cuando se necesita. Bien. Y eso viene de la mano con otras de las características. Que es el Event Replace. De por sí, bueno, si ustedes quieren habilitar esto dentro de sus aplicaciones. Obviamente tendrían que habilitar la función de Server Server Render. Y cuando le decimos Provide Client Hydration. Habilitamos que queremos con Incremental Hydration. Entonces normalmente, por ejemplo, acá tengo alguna aplicación. Déjame ver si me encuentro por acá. Acá tengo una aplicación. Acá. Sí, acá está como la configuración, digamos. Acá el config. Acá. Podemos ver varias cositas acá. Déjame las organizo. Acá, acá, acá y acá. Perfecto. Entonces aquí vemos como varias cositas que están pasando acá. El Sound Detection. Bueno, varias cosillas allí. Pero acá básicamente tenemos el Width y el Event Replay. Y también entonces podríamos habilitar. Vamos a ver si me autocompleta. El Width. Vamos a ver. El Width Incremental Hydration. Lo podríamos habilitar. Aquí lo importamos. Y ya. Entonces como con esta banderilla. Implementamos el Incremental Hydration. Si lo ves necesario. Esto aumenta mucho el performance. Y como les digo, es menos JavaScript para nuestro cliente. Eso va de la mano con el Event Replay. Que ya como lo vieron por defecto. Por ejemplo, esta aplicación yo la inicié por defecto con la versión 19. Y el Event Replay básicamente es un algoritmo. Que hace. Básicamente que ya está habilitado por defecto. Que literalmente es esta magia de leer los clics un poco dentro de nuestra aplicación. Y cuando realmente ese JavaScript lo necesitamos cargar o interactúa. Pues ahí es donde se va a cargar. Y como que el algoritmo, por ejemplo, se llama Event Replay. Acá tenemos como un blog en específico acerca de él. Que es algo de lo que se trata también de Wix. Wix es este framework que se utiliza internamente en Google. Por ejemplo en aplicaciones como Google. Que es google.com. El buscador directamente utiliza Wix. Porque pues es una de las páginas más visitadas del mundo. Y necesitan que cargue súper rápido. Y ahí utilizan un framework llamado Wix. Y Wix y Angular están trabajando en conjunto. Y una de esas primeras cosas que se traen del framework de Wix. Y empiezan como a colaborarse entre sí. Por ejemplo los de Wix dijeron que se trajeron para YouTube. Se trajeron todo lo que es el patrón de Signals a Wix. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y luego se trajeron a Google. Y el performance funciona mucho mejor en YouTube Web. Como el responsive de YouTube. No en aplicación móvil per se. Sino en el website de YouTube para mobile. Y así como Angular se trajo el algoritmo de Event Dispatcher. Event Dispatcher. Event Dispatcher. En donde leen de forma mucho más granular cada cambio. Y eso lo ajustaron al modelo de hidratación. Entonces aquí pueden leerse un poquito más. Qué es lo que significa este algoritmo. Cómo funciona un poquito más a fondo. hacer algún en otro streaming solo hablar de esto y enfocarlo y ver un poquito cómo funciona, pero esa es una de las cosas que también trae el Event Replay, ya va a estar por defecto, obviamente en las aplicaciones que inician desde cero, pero si ustedes lo quieren habilitar, si tú lo quieres habilitar, básicamente tienes que ir aquí a esta parte de acá e implementar que ahora la lectura se haga pues como con ese algoritmo y también le puedes incluir a eso el incremental halvation, ¿bien? Bien, ahora vamos a ir por acá, esto es un poquito más de como les digo cómo funciona, simplemente cuando realmente el usuario interactúa con esa parte en la interfaz, realmente va y se carga ese JS para que se vuelva interactivo del lado de nuestro cliente. Obviamente en esto hay normas, hay reglas, por ejemplo, yo puedo meter este defer, que significa que yo sí quiero que ciertas partes de la aplicación no esperen a una interacción del cliente, sino que... Sí quiero que cargue, porque no sé, porque es algún punto que yo sí quiero que esté cargado, pero por ejemplo hay varias formas de como de decirle que se haga esa hidratación, por ejemplo en el viewport, en el viewport una forma es decirle cuando entra a una zona activa del usuario o en hover, que hover es cuando realmente hace clic, aunque en mobile es difícil porque en mobile no tenemos el hover, no tenemos como el touch, pero bueno, ahí vamos implementando ese tipo de reglas. Vamos a ver, acá este, este, y seguimos hablando dentro de server-side rendering, y es el router-level render mode. Ahora, ¿qué significa esto? Esto me parece bastante interesante porque también es un cambio de approach de cómo nosotros venimos trabajando con Angular, y si estás trabajando con server-side rendering, esto te va a interesar bastante, y es básicamente que ahora nosotros también podemos definir, o sea, no todo es blanco y negro, realmente podríamos tener una sección en la página que sea single, sí, una single page application o que sea renderizado por el cliente, ¿no? Una que sí solo sea renderizada por el server y de pronto tener esta forma dinámica de incremental hydration, y otra que sea estática o que sea pre-renderizada. Entonces realmente no es como que si yo le habilito server-side rendering a la aplicación, ya toda va a tener como esta ingeniería, nosotros de forma granular, podríamos decirle cuál sí o cuál no con esta configuración. Entonces ahora yo le puedo decir, mira, lo que es el login, el render mode, viene del servidor. Bien, lo que es el dashboard, que esto tiene todo el sentido, lo que les venía comentando, hay aplicaciones en Angular que normalmente pues ya cargan mucha interacción de datos, por ejemplo, una gráfica de datos que está protegida bajo un login, no tiene tanto sentido hacer el server-side rendering, porque, ¿no? Pues primero nadie va a acceder ahí desde internet a menos que yo digite mi usuario y contraseña. Entonces realmente cosas como dashboard tienen totalmente ese sentido que sí están renderizadas directamente en el cliente, pero ahora yo elijo, o tú como desarrollador tienes esa función de elegir. Es decir, ah, el login sí necesito que esté súper optimizado y que tenga un performance de locos y que, mejor dicho, cargue instantáneamente. Ok, entonces voy a hacer server-side rendering. Pero el dashboard... Pues que ya tiene una protección de autentificación y algo más, pues yo creo que ahí el render mode es el cliente. O un pre-render. Pre-render es básicamente que hace como un fetch desde el lado del servidor y luego ahí sí hace el hydration cuando llega. En fin. Otra de las características que tenemos en la versión 19 es que ya podemos tener de forma estable el server-side rendering. Y sobre todo que también sea compatible con el server-side rendering. ¿Qué significa esto? Normalmente el patrón de reactividad de Angular es stone, ¿no? Y el stone.js es este paquete que como que está vigilando todo el DOM o actividades que hay dentro de nuestra página para luego reaccionar, hacer como un algoritmo en donde va y verifica todo el árbol del DOM, mira que cambió y esa es la página que actualiza. Todo esto ya fue como reescrito a la reactividad granular gracias a los signals en el cual ya no es necesario son.js. Y por ejemplo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, si yo quiero que se vea el domo, y por ende las aplicaciones tienen mejor rendimiento por todo este modelo de reactividad granular que ahora ofrece con signals. Y por eso casi que Angular se está moviendo todo a signals por defecto. Como que se mueve a signals por defecto. Entonces, sonlets sigue siendo opcional, ¿bien? Sin embargo, cada vez más como que lo vamos sacando y se va volviendo opcional. De por sí, por acá creo que vi un tweet. Por acá, sí. Vamos a hacer un poquito más de son. En donde, por ejemplo, teníamos como esta configuración en el boosted module, en donde le decíamos como ng-son-nup, pues ahora también podríamos decirle que de forma experimental queremos sonlets-shade-detection. Es decir, que simplemente no queremos utilizar sonlets para la detección de cambios. Obviamente, eso hace que debamos tener... Pues si ya no vamos a utilizar sonlets, deberíamos entonces controlar los cambios con signals. Es decir, utilizar inputs en forma de signals, los view-child, todo ese tipo de cosas, ya pasarlo a modo de signals. Entonces, no solo es de pronto habilitar esta línea, porque si tú no has utilizado signals o la reactividad granular, pues tu aplicación va a empezar a fallar. Simplemente tendrías que ya utilizar signals como modelo de reactividad para empezar a usar, pues quitar son-js para la reactividad dentro de tu aplicación. ¿Va? Acá. Ahora, hay otro que es muy interesante y es el hotmodule replacement. Ese es uno de los que siempre la comunidad ha estado pidiendo. Yo creo que este es gracias también a que Angular ha estado trabajando muy de cerca con Byte. De por sí, Byte, no sé si hace poco, lanzó su versión 6. Hace, ¿qué? Un día lanzó la versión número 6. Y Byte es como este builder que se está volviendo muy famoso. Y con bastante performance. De por sí, creo que están trabajando con ROS para que corra muy rápido. Y ya no tenemos Webpack, ¿no? Angular básicamente tiene como un híbrido entre ESBuild, que es otro de los compiladores muy famosos, que este está en base a Go. De por sí, uno de los ESBuild es creado y mantenido por uno de los founders de Figma. Y por eso también tiene un alto rendimiento. Recordemos que Figma literalmente casi que es basado en la web, solo que con WebAssembly. Y uno de los creadores de Figma construyó ESBuild en Go. Sin embargo, Byte está ganando bastante, bastante popularidad. Están también reescribiendo algunas cosas en ROS, que ROS sigue siendo uno de los lenguajes para hacer compilación muy, muy rápida. Y una de esas características es el HotModule Replacement, que siempre ha sido como un dolor de cabeza para los usuarios. Y es que, bueno, es un tema que se ha hecho muy, muy rápido. Y no solo lo han hecho por los Ángulos Developers, pero gracias a que Angular está como trabajando con estos nuevos compiladores, ya no con Webpack, ya no con estos empaquetes, sino como con estas nuevas herramientas que se adaptan a las nuevas tecnologías, pues tenemos también o pueden ofrecer este nuevo tipo de características. Ahora, ¿qué es el HotModule Replacement? Yo, por aquí levanté una aplicación chiquita, que es esta. Tenemos que ashamed la levanto aquí en un local host. un localhost localhost 4200 es la aplicación de toda la vida el hello world normalmente cuando tú escribes código pues tienes el live reloading lo que conocemos como live reloading es decir si tú haces hello recargas vuelves acá pues simplemente se hace una recargada de lo que está pasando pero vamos a ponerle atención a algo en específico voy a poner esto por acá y voy a poner acá el código bien fíjense en algo en específico si yo escribo acá cualquier cosa lo guardo aquí no sé si alcanzan a ver obviamente estoy en versión de desarrollo y cada vez estos estas herramientas son mucho más rápidas pero no sé si se fijan pero hay una recarga hay una recarga o corre muy rápido pero aquí se logra ver que hay una recarga como tal como que hace un reloj de la aplicación bien ahora lo que es como el replacement es no hacer una recarga de la aplicación sino simplemente realmente actualizar ese pedazo de código que fue cambiado lo cual tiene un montón una ventaja muy interesante para cuando tú tienes cosas como estas digamos que tienes no sé si me ocurre ahorita para negi tienes algo como esto por acá quiero buscar un diálogo digamos que estás trabajando en algo como esto aunque aquí está un poquito roto el estilo pero bueno no importa y vamos que está trabajando en los estilos de un modal de un pop up que está ahí en pantalla cada vez que hagas un ajuste en los estilos de este modal pues obviamente al hacer will out como al hacer esto pues se va a perder ese estado y tienes que volver a clickear lo tienes que volver a hacer clic que también pasaría lo mismo como por ejemplo con este menú digamos que tú estás trabajando en los estilos de este menú de este menú lateral entonces haces un cambio, cualquier cosa de estilos y se recarga la página y tienes que volver a hacer click y ver si tu cambio ya se ajusta o no básicamente el hotmodel replacement hace que no tengamos como hay una recarga de la página mantiene el estado como tal de lo que esté abierto y solo cambia el pequeño pedazo de código o ajusta el pequeño pedazo de código sin hacer como el reload de todo, eso es bastante útil, de nuevo como para ese tipo de ocasiones cuando yo tengo estos estados, un side menu un modal, algo de ese tipo o varios pasos que tengo que hacer y solo por hacer la recarga pierdo el estado y me toca volver a hacer un par de clicks para volver a ese estado y ver si los ajustes que estoy haciendo pues se comportan bien entonces esto me parece una gran ventaja entonces vamos a probarlo, vamos a ver si funciona es decir voy a ajustar los estilos de este h2 y esperemos no recargue la página porque esto ya viene por defecto en la versión 19, entonces por ejemplo le voy a cambiar a color red vamos a ver ah bueno lo tenía subrayado entonces no se vio cambiamos el background, blue entonces fíjense que no hay una recarga, no sé si lo notan obviamente creo que debí preparar un ejemplo con un modal para que ver que el modal no se oculte, sino que se cambia y no tengo que volver a hacer click para abrirlo pero ahí vemos entonces aquí font 200 más chiquito, entonces fíjense que solo cambia ese pedazo, o sea lo que va implícito solo cambia ese pedazo, vamos a hacer otro ajuste, ahí se va cambiando pero literalmente no hizo un reload de la página, como si cuando yo por ejemplo hago esto y se ve que hay como un refresh aquí se alcanza a ver como que recarga en estos iconos de estado del navegador esto también está ya está por defecto, y de por sí el mismo ejemplo que les mostré es el que mostraban acá y ya está por defecto ya está por defecto en la versión 19 otra de esas características es el stand-alongs normalmente esto hace parte de hacer Angular más fácil, y es decir que ya no tenemos módulos, simplemente son componentes y uno ya los empieza a usar en donde sea debido, pero como tal no tengo que empaquetarlo en un módulo obviamente el patrón mental de organizar las cosas a nivel modular es bueno, pero ya no existe como tal el archivo module en donde tenemos que empaquetarlo, eso hace que ahora por defecto tengamos stand-alongs by default, entonces que quiere decir esto, que si yo tengo una aplicación por ejemplo esta, esta es una aplicación chiquita, por acá por acá, por acá, vamos a ver un componente no, déjenme la que creé ahorita, no, este no lo me perdí, y ¿dónde estás? ah, claro, es que lo había puesto acá, listo, entonces fíjate que acá tenemos este, normalmente para habilitar stand-alongs teníamos, pues una banderita que es stand-alongs true pero fíjate que en esta ya no hay, ¿por qué? porque ya es por defecto ya por defecto todos los componentes que vas a crear van a ser por defecto true, van a pensar en que no están acoplados a un módulo ahora, si realmente sí quieres acoplarlos a un módulo, ahora lo que hay que hacer es hacer lo que sería el viceversa, es decir decir que esto es false, que esto no es un componente stand-alongs sino que es un componente que va a pertenecer a un módulo en específico entonces ahora, lo explícito es que le digamos que no es stand-along, y lo implícito es que por defecto sea true ya no hay que decirle que es true, por defecto va a ser true bien, ahora esto nos da una ventaja y es que de por sí tú puedes poner en tu Angular compiler options que el streak stand-along, forzar a tu aplicación, esto de nuevo es opcional si lo quieres habilitar o no, si tienes una aplicación que todavía funciona con módulos pues no es bueno que lo habilites, porque esto te va a hacer que cuando compiles te va a forzar a que todos tus componentes sean stand-along bien, ese sería el by default sin embargo, si no, si no lo quieres pues simplemente no se lo colocas y ya, pero también te fuerza que las aplicaciones si ya hiciste la labor de estar utilizando stand-along components y salir de todos los módulos pues ya podrías dejar por defecto esta nueva funcionalidad para que por defecto si algún otro programador o algo quiere integrar algo e introduce módulos como que hey, wait, recuerda que esto ya por defecto es stand-along y te va a fallar el build, si no está por defecto, así que aparte de que ya vienen por defecto puedes obligarlo y ponerlo en el módulo estricto de la configuración de Angular, en el tsconfig.json entonces eso va a estar por ahí, vamos a hablar de reactividad también una de las cosas es que en la versión 19 ya sé normalmente ellos tienen un preview y aquí hay un proyecto muy bueno que creó la comunidad, que es este Angular course can use, es como el can use que tenemos de HTML, pero de Angular entonces uno puede ver qué cosas están en developer preview, qué cosas ya están estables qué cosas son experimentales y podemos ver un poquito el roadmap de cómo se ha venido evolucionando por ejemplo, toSignal toSignal es una función bastante interesante que si la vemos de algún modo llegó en la versión 16 el toSignal y el azul es que todavía está en developer preview como que toSignal podríamos decir que todavía no está estable algo les falta aparentemente por detallar, pero parece que todavía está en developer preview, es como las cosas que podrían cambiar, no son estables ¿no? aquí por ejemplo podemos ver los signal inputs aquí precisamente los signal queries signal model inputs, aquí vemos que esto se introdujo en la 17.2 en la 18 seguía estando como en preview, pero ya los puntos verdes son los que ya están estables, por ejemplo podemos ver el ciclo de vida de los standard components, fueron introducidos en la versión 14 y de por sí ya desde la 15 hasta la 19 ya se comportan como algo estable, es algo que puedes usar sin ninguna preocupación sin ningún miedo, ¿bien? entonces precisamente nos hablan de que estos APIs en donde ya utilizan signals para los inputs los outputs específicamente no son un signal, pero en fin, la API ya está madura, la de inputs, la de outputs la de los queries, ya están automáticamente pues puestos y estables y ellos nos hacen la vida más fácil y corriendo estos generates automáticamente el código se va a migrar si estás utilizando un input un input normal, el del arroba automáticamente lo va a migrar a un signal igual con los signals y con el output, entonces es una forma también de aprovechar esto y simplemente hacer estas migraciones de por sí de este si quiero hacer un video en específico, probablemente el siguiente streaming, en donde voy a tener una, no un proyecto pequeño, voy a tener un proyecto grande, en el cual voy a intentar correr estas migraciones tienen más de mil módulos o mil componentes, entonces vamos a ver qué tal corre esta migración y ver qué tanto si le acerto o no entonces, pues pendiente del siguiente streaming voy a hacerlo en una base de código grande, yo tengo algunos proyectos, pero son proyectos como pequeños y siempre a veces una de las comentarios es ok, pero en un proyecto grande de pronto es más complejo, entonces voy a correr un proyecto grande, voy a un proyecto que tiene más de mil, dos mil componentes y vamos a correr esta migración, vamos a ver qué tal qué tanto se demora y ver si resultamos con una migración buena o mala pero básicamente esta cliente o este código hace que pasemos automáticamente a Signals, bien y hay una este como que te migra si estás utilizando un input, lo pasa, pues a un Signal Input si es un query, lo pasa a un Signal Query, si es un output pasa a un output, pero si lo que me preguntaba hace poco si uno de los compañeros es, ok, y si mi aplicación todavía está utilizando la reactividad en base a Song.js, que es básicamente digamos, no tener Signals automáticamente esas cositas que están como con la antigua reactividad y lo pasa a esa nueva, es más, entendemos correr esta, no sé, no sé qué pase, pero entendemos correr, voy a por ejemplo, esto por ejemplo es este title, esto es en Song.js porque no es un Signal, y si yo lo cambio, si le pongo un ngModel intentémoslo, intentémoslo, a ver, vamos a ver qué pasa la magia del live, entonces voy a poner un input acá y... vamos a poner un Model, y pongo title y... vamos a ver, en teoría este componente debería fallarme, el ngModel porque no estoy importando el Angular form, igual corramoslo a ver qué pasa Por aquí, no se puede vender el ngModel porque, ok, si, lo que decía, el ngModel no hace parte del componente, entonces aquí básicamente, vamos a ir a forms, Y tenemos el for module ¿Dónde está for module? Ahí está Y lo implementamos, ¿no? Entonces ahí está Entonces ahora ya debería correrme Bien, todo bien Entonces en teoría si yo hago un ajuste acá Vamos a ver, vamos a ir a localhost 4200 ¿Así está corriendo? Sí Ahí está Entonces si yo hago un cambio acá, pues esto cambia acá Perfecto Sin embargo esto no tiene signals Esto es, pues la reactividad normal Vamos a ver si corriendo ese comando Me lo cambia a un modo sign Vamos a ver Y vamos a correrlo Control C Vamos a parar el proyecto Y vamos a correrlo, ¿no? NG Ya, entonces me dice que quiero convertir Los inputs, los view childs Aunque quiero convertir Ah, creo que aquí no es que lo cambie a signals Lo que me está Diciendo y leí mal es Que opcionalmente puedo Como habilitar, ¿no? Si quiero un signal input, bueno, también podría poner Un signal input, ¿no? Y vamos a ver qué le puedo decir Que quiero migrar algo de esto ¿Qué parte del código? Tú quieres, ah, sí, vamos a darle que sí Ahí va a empezar a hacer la migración Yo creo que no va a encontrar nada porque no tengo ningún Ningún input Sí, migró cero Vamos a ver si hay algún cambio No, realmente no migró nada Entonces intentamos hacer un input A ver cómo nos va con esa migración Yo creo que ese iba a migrar lo otro Bueno, entonces vamos a ver Title este, digamos, esto es un Aunque aquí Posiblemente va a fallar porque este es el AppComponent y el AppComponent Es el que renderiza y pues le estoy pidiendo Un input Podríamos tener un componente, queremos un componente chiquito Y miremos si lo migra Para pa, creamos un componente En generateComponent, aquí Pongamos un Button Listo, tan Por defecto vemos que este componente Pues al final, fíjense que ya nos está en Alant, perfecto, entonces vamos a poner aquí Un input, digamos que Si recibe este title, vamos a Hacer que reciba esto Perfecto, y por acá Nuestro componente Nuestro componente Aquí importa el button component Está, button component Y lo vamos a utilizar, no sé, vamos a Borrar todo esto, y vamos a utilizar Creo que debería ser AppButton, y ahí está El click, ¿no? Lo que yo le estoy enviando a ese componente, vamos a ver Ah, claro No he hecho ngServe, entonces Vamos a volverlo a correr Y luego corremos la migración A ver si migra ese input Este es otro, este es interesante Acá, esta es otra de las novedades Y es, fíjate que aquí Como yo estoy importando El router Acá, estoy importando El router outlet, pero realmente no lo estoy usando O sea, él me está detectando Que yo estoy importando algo Pero no lo uso, y eso también puede Ayudar mucho a aligerar el problema O a agilizar la carga, porque me estoy trayendo A router outlet, y realmente No lo utilizo, es como si me trajera Form modules y nunca utilizar los formularios O como si me hubiera traído este botón y nunca lo utilizo En mi template, entonces él es capaz De detectar esas cosas Y en este caso no me falla la compilación Pero sí me avisa, oye, mira Que el router outlet no está Siendo utilizado en el componente, eso es otra De las novedades de la versión 19 Entonces a veces importamos cosas que no necesitamos Y ahora nos va a empezar a alertar Eso es muy bueno para nuestra aplicación Entonces veamos Acá yo, pues le paso este clickme Y literalmente Yo debería recibir este Title, que ahorita está en vacío Vamos a imprimirlo Ya Entonces Obviamente le paso el clickme, entonces está imprimiendo El clickme, ok, pero ahora Intenté volver a correr la migración La que creí que migraba signals Pero realmente no, simplemente me dice Que quiero escoger Que quiero migrar, en este caso voy a Migrar un signal input Yo espero Creo que le puse mal el A ver, puedo volver a correr Le puse mal el Otra vez, eso Punto, eso, el signal Total, punto, perfecto Y le digo que yes Y vamos a ver Si esta vez es la migración Acá sí me dijo, uno, uno de uno, vamos a ver Acá, por ejemplo Ya veo que hay un cambio Ya no es una variable normal Es un signal, por eso la suscripción Veamos por acá Acá lo cambió, lo puso como Read only, interesante que le ponga Read only, lo cambió a input, que es tipo String, perfecto Y en teoría mi componente no cambió nada Sigue siendo un title que va a Que le envía ese input, ¿no? Entonces básicamente hizo la migración completa De esto, y hay otras migraciones Como las de inject y demás Entonces funcionan y funciona Bastante bien, de nuevo voy a hacer Una migración como en una base de código Más grande, pero funciona bastante bien Ah, y dentro de Visual Studio Code o utilizando El language service Que es el plugin que tenemos en los Pues en los IDs, VS Code, Cursor, Web Chrome, no solo también lo vamos A poder hacer como con línea de comando Sino aparentemente vamos a poder tener Como un click, y dándole Un click podemos migrar de pronto ese pedacito En automático, ¿va? Bueno, acá empezamos Con esto de los link design Esto es Súper interesante, los link design Es una forma de linkear Un signal con el otro, se puede confundir Con lo que es un computed signal Porque aparentemente Normalmente deriva de un Estado, pero tiene unos casos de uso Muy en particular, voy a hacer un video De esto en específico, o un streaming de Linkedin Signal en específico, porque me parece Que hay unos escenarios En el cual podemos comprender mejor como funciona Pero básicamente es como que si tú Tienes un Un sign-out options Y luego quieres, por ejemplo Por ejemplo, que Por defecto en un Select, ¿no? En una bandeja De opciones, en un dropdown, por defecto La opción 1 sea la escogida Tu choice, tu elección Pues básicamente lo linkeas Y es ok, mira, quiero Obtener todas las opciones Y de esas opciones quiero la La número 0, ¿no? Y entonces cada vez que cambie esto Pues yo puedo Reaccionar y obtener La primera opción, esto Literalmente también lo podría lograr con un computed Si yo le pongo aquí computed También funciona de esa manera Sin embargo el link design, el primero Es writeable, es decir Deja sobrescribirlo, el computed no me deja Sobrescribirlo, y segundo Tiene, creo que el mejor Valor agregado es que funciona tremendamente Bien con los inputs Los input sign-outs Ya he tenido un par de casos en que el input Entra y es de tipo sign-out Y yo quiero calcular una opción Y me toca hacer como un código extra Código extra que les voy a mostrar un poco Para que eso funcione Precisamente ahí es donde el link me Salva y puedo hacer ese linking Mucho más Eh Claro, sin tanto Portable, sin tanto código Entonces es bastante útil Y obviamente el de resource Que es el que nos dice que ahora Que es como el que va a reemplazar Pues una forma de ya no tener Cosas asíncronas Y que manejábamos para hacer Peticiones asíncronas, pues HTTP client, ¿verdad? Con RxJS Sin embargo resource ahora es una forma En la cual podemos también hacer Esas peticiones que son asíncronas En sign-outs Entonces por acá, por ejemplo Tenemos un user ID Entonces es un sign-out Entonces acá tengo ese request Y acá tengo un servicio User service, ¿verdad? Entonces ese user service Fíjense que acá tenemos una wait Ya no es un punto subscribe Pareciera que a Angular ahora sí le gustan Las promesas en vez de los observables Aquí este tipo de servicios Ya podríamos manejarla con una promesa Cosa que casi siempre la comunidad Había querido, pero ya Todos nos habíamos adecuado a Ok, no te gustan las promesas Vamos a manejarlo como RxJS Es decir, en subscribe, etc. Pero aparentemente con este resource Y en su parte quieren también Liberarse de RxJS Entonces ahora tenemos una forma Igual se puede hacer todavía con promesas Si lo quieres hacer Pero podríamos tener, digo con RxJS Pero puedes tener ya promises Obtenerlo Y obtener como esa señal Y esa reactividad Que es lo que vamos a hacer Y luego vamos a ver Que es lo que vamos a hacer Y luego vamos a ver Que es lo que vamos a hacer Y luego vamos a ver Que es lo que vamos a hacer Y luego vamos a ver Tiene unos estados derivados Que me parecen bastante interesantes Y espero probarlo en un específico Bueno, acá hablamos ya de Material Hay varias mejoras en Material Aunque si bien el equipo de Material Está pasando dificultades en Google Y casi que El equipo de Material dentro de Google Ya no está trabajando Sigue el equipo de Angular soportando ciertas características De Material Sobre todo Material versión 3 Que es el nuevo estándar Design System de Google Entonces podemos cambiar temas y demás Realmente yo no trabajo mucho con Angular Material Pero probablemente a alguien que sí trabaja mucho con esto Le va a servir un montón Y sobre todo hay unas nuevas Novedades Y es como por ejemplo dentro del CDK Que el CDK es una cosa Totalmente diferente A lo que es el Angular Material El CDK Es como Bueno, en teoría es Component Development Kit Es un kit Para desarrollar componentes Que es agnóstico a la UI Es decir, no tiene estilos Es solo funcionalidad Y de por sí eso sirve un montón Para crear componentes Arriba del CDK Entonces si tú quieres hacer un drugland Si quieres hacer un modal Pero no quieres hacer el modal Con los estilos de Material o con los estilos de Tailwind por ejemplo Sino que es En tu empresa tienes tu propio estilo Su forma, su design system Pues no tienes que hacer la ingeniería De cómo hacer un modal Y cómo eso tiene que ser accesible No, el CDK ya te da toda la ingeniería Para hacer eso Y tú ya le pones los estilos que quieras Es agnóstico a los estilos Y dentro del CDK precisamente Hay una forma de ya soportar Duck and drug Imagínate tú hacer esto O sea, solito sin Sin ayuda básicamente Claro, hay muchas librerías que hacen esto Pero no es un software que te va a ayudar a hacer esto Básicamente, claro, hay muchas librerías que hacen esto Pero no es un software que te va a ayudar a hacer esto Pero no es un software que te va a ayudar a hacer esto Pero no es un software que te va a ayudar a hacer esto No es que lo hacen, pero pues te atas a la UI De esa librería, ¿no? Si utilizas Tailwind, si utilizas Material Y de pronto tú no quieres Material Ni quieres Tailwind dentro de tu aplicación Entonces te atas a esa UI Pues el CDK te trae esta especie de funcionalidades de UI Pero sin estilo gráfico Sin una marca como tal ahí puesta Entonces pues ya tú lo estilizas Pero todo lo que es modales Un pop-up, un side menu Todo ese tipo de cosas Vienen como con marca blanca Que le llaman Y pues tú ya trabajas en los estilos Pero este tipo de cosas pues ya lo tienen Y algo que soportaron en esta versión Es el Dropdown en dos dimensiones Normalmente el Dropdown se hace como horizontal Pero aquí vemos que lo hacen tanto en vertical Como en horizontal De por sí esto lo utiliza el equipo de Google Cloud Google Cloud está hecho en Material Y precisamente aquí utilizando esta función Pueden mover de un lado al otro También hay nuevos pickers Hay algo súper básico Que no tenía en el principio Y es un picker para Time O sea, sí tenían como el calendario Pero cuando quiero un picker Que sólo tenga la hora y fecha Pues ahora tenemos esa opción Cosa que se agradece Porque creo que es muy útil Y no tenerlo era como Es algo de los componentes básicos Que de pronto otros SDKs de componentes Sí me ofrecen Como Ionic, como NG Prime Como Nebular Y que material lo tenga Pues está bastante bien El que les mencionaba El que nos salió ahorita de por sí en pantalla Ahora se puede reportar Cuando tú no utilices un Estés haciendo la importación De algo que no utilices Al final de por sí a veces importamos muchas cosas Y refactorizamos Y estamos trabajando y no nos damos cuenta De que ya algo no lo usamos Entonces ahora nos va a avisar Y eso optimiza nuestros componentes Y listo, eso es básicamente Este es muy bueno también No es que todo es bueno En la versión 19 lanzaron muchas cosas De por sí aquí dicen que este es uno de los issues O de los cards Que tienen como más peticiones Dentro de la comunidad de Angular Y es que uno pueda En el momento de hacer building Pasarle variables de ambiente Normalmente cuando trabajamos con equipos de ingeniería Equipos de desarrollo, de DevOps A ellos les encanta pasar Como este tipo de variables En el momento de building Normalmente y sobre todo en Angular No están muy acostumbrados A que pongamos las variables de entorno En el archivo environment.ts Nosotros sí porque pues Aprendimos Angular y dijimos que ahí De por sí si ustedes ven En los proyectos por defecto Ya no está el environment.ts Yo hice un video de cómo volverlo a habilitar Porque ya no está, ya por defecto no está Entonces ¿dónde pongo mis variables de entorno? Pues puedes utilizar ese archivo De por sí creo que yo tengo uno acá Por ejemplo acá yo tenía unos Como esta API Pero ahora no te fuerzan a tener Como estas variables quemadas Aquí en el código Sino que en el momento de building Se pueden definir Y esto yo creo que los equipos de DevOps Los equipos que están encargados de hacer deployment Lo van a agradecer Porque ya no tienen que de pronto Estar jugando con este archivo Y por protegerlo Estar inyectándolo y generándolo En tiempo de building A veces para no poner aquí Estas variables Porque a veces son sensibles Tienen keys y cosas sensibles A veces lo que estaban haciendo Es generar este archivo Como creándolo En cada build En donde el equipo de desarrollo No tiene acceso a estas keys Pero entonces en el entorno O en el ciclo de desarrollo Lo crean como de forma dinámica Hacen deployment Y luego lo eliminan Pues ahorita ya no tendrían que hacer Como estos hacks Sino literalmente cuando hacen build Se define y ya Y en el momento de hacer building Se va esa key Ahora si ustedes están haciendo Aplicaciones SPA Aplicaciones que se rendiza Por el lado del cliente Si o si es aquí Va a estar dentro del JS Porque al final Ese JS va hacia tu cliente Pero de pronto si ya estás En tu server server rendering Ahora si esas Esas keys pueden quedar De una forma más segura Voy a hacer un video de esto específico Porque me parece que realmente Soluciona como ciertos O mitiga ciertas cosas de seguridad Que a veces los equipos tenían Y que hacían como hacks Para poderlo lograr Y te voy a comentar igual Donde de pronto si o si Por más que utilices esa técnica O la anterior Igual tus llaves se van a ver Si estás utilizando Una single page application Bien Bueno y más características Pero creo que ya hace Ya mucho tiempo Ya una hora y cuatro Así que Muchas más cosas Como hemos visto Es un release lleno De características De novedades Es una de las versiones Que más tiene features Features interesantes Features que estabilizan cosas Así que espero que esto Los anime a actualizar Únanse a mi canal de Discord Para que allí escojamos Cuál va a ser el siguiente tema En cuál de las versiones De estos de pronto Vamos a profundizar Y hacer como un demo Un poco más enfocado A ese feature en específico Y ya