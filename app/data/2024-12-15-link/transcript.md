 En esta ocasión vamos a aprender sobre esta nueva primitiva que trae Angular en la versión 19, llamado Linking Signal. Esta vez básicamente lo que tenemos es que es una forma, es como una forma más organizada o más completa de hacer un Computer Signal y de pronto ahí puede haber una confusión, ¿cuándo utilizar un Computer, cuándo utilizar un Linking Signal? Y hoy precisamente te vengo con un ejemplo para que entendamos esto bastante bien. Así que no siendo más, vamos a pasar al código y veámoslo. Supongamos que tenemos un componente súper sencillo, que en este caso sería un Dropdown Component o estos menús o un menú de selección de opciones. Esto es súper sencillo y lo que voy a tener es un Signal que en este momento lo voy a llamar Options y lo voy a decir que es igual a un Signal, que es un Array de Strings y básicamente acá me dice que debo importar, entonces vamos a ver acá, vamos a importar Signal y vamos a ver que es igual a un Signal, que es un Array de Strings y básicamente acá me dice que debo importar, vamos a crear unas opciones por defecto, entonces vamos a poner Opción 1, Opción 2, Opción 3, nada fuera de lo común y voy a renderizar estas opciones, es más, esta opción va a cerrar los demás archivos y esto, voy al HTML y pues le voy a hacer una iteración. Entonces aquí por ejemplo voy a tener un ul y aquí me hace la iteración, literalmente aquí ya me auto completo el código, estoy utilizando Cursor como ID y tiene mucho contexto de lo que es un Signal. Entonces aquí por ejemplo voy a tener un Signal, que es el que estoy haciendo, entonces él sabe que si yo acabo de hacer opciones, normalmente quiero ir a renderizarlas. Y también ya tenía código un poquito preparado, entonces creo que está recordando lo que había antes. Pero bien, esto simplemente es Cursor con su inteligencia artificial. Va, entonces fíjense que tenemos algo muy sencillo, tenemos un Options, un Signal, nos suscribimos, lo iteramos, si nosotros lanzamos esta aplicación con un ng-serve, vamos a ver cuál sería el resultado, acá, por si alguien me dice que hay un error all import, ahorita lo checo pero básicamente pues tenemos unas opciones sin embargo drop down component creo que no se está renderizando vamos a ver si drop down component no se está renderizando acá, acá, justamente eso es lo que me está diciendo acá que no estoy utilizando ese componente entonces aquí literalmente voy a renderizar mi componente el de drop down que apenas no tiene nada de lógica ahorita vamos a ponerle lógica y a ver cómo funciona el link de ensayos acá ya literalmente tengo el app drop down y listo, literalmente lo puse como en un borde rojo para que pues pudiéramos como diferenciar cuál es el padre y cuál es el hijo entonces básicamente tenemos unas opciones opción 1, opción 2, opción 3, renderizado y ya pero vamos a poner un caso, vamos a poner así el caso de que por ejemplo yo quiero tener un app drop down que no se está renderizando y tener un selected quiero seleccionar unas opciones y guardar su estado entonces por ejemplo yo tengo un selected option aquí por ejemplo me sugiere que pues este signal puede tener un estado que puede ser string o nulo pues realmente no quiero guardar eso quiero que sea number, o sea guardar la posición y como no tengo ninguno por defecto entonces podría decirle que el estado inicial es menos uno ¿no? ese podría ser una opción y aquí ya me sugiere un método selected option es decir que yo voy a modificar ese signal de acuerdo a la opción seleccionada entonces vamos a ver cómo sería recuerden que apenas estoy haciendo como el ejemplo para luego entender bien el linkedin signal entonces básicamente acá tengo llamo a esa opción el selected option fíjense que hasta este método me lo puedo ahorrar ese método podría ahorrármelo porque al final es un selected option punto set y yo podría también hacer esto entonces podría ser selected option que es el déjenme ver cómo se llama el selected option ese es el signal selected option punto set y podría enviarle sin problema podría enviarle el index ¿no? porque pues estoy modificándolo ahí no habría ningún problema en hacerlo de esta manera pero pues también tenemos un método y si queremos seguir la parte de los métodos no está mal déjenme lo volveré a hacer aquí lo voy a poner como método pero lo podríamos llamar directamente en el pues en el template ¿no? entonces acá esta es la opción entonces por acá voy a poner un párrafo y le voy a decir cuál es la opción seleccionada ¿no? por ahora tendremos algo súper sencillo tenemos una red de opciones y un select que inicia en menos uno recordemos ese estado muy bien inicia en menos uno cuando no tenga una opción voy a iniciar en menos uno que es básicamente no hay ninguna opción preseleccionada sin embargo cuando yo ya le hago clic fijémonos que me guarda la opción por ejemplo recordemos que en Arrays de JavaScript y en muchas lenguas de programación pues empezamos a contar desde 0, 1, 2 ¿no? entonces básicamente acá tenemos que acabo de seleccionar la opción 1 o el índice en la posición 1 y si yo le hago clic por acá pues tengo la posición 2 y básicamente es un estado que me guarda cuál fue el que está seleccionado volviendo al código yo también puedo hacer un p select an option por ejemplo y de esa opción escoger el elemento ahora aquí lo que hacemos es por ejemplo yo podría también deducir la opción o sea realmente de acuerdo a esa posición pues saber cuál es esa opción que yo acabo de elegir entonces una cosa es digamos que este lo voy a guardar como position y luego la opción seleccionada que sería el elemento en esa posición en específico ¿no? entonces si yo voy y pues voy a menos 1 obviamente no hay nadie en menos 1 y si voy acá pues la opción la posición 3 es el 2 y así ¿no? entonces ahí va pasando hasta ahora nada, nada del otro mundo perfecto, listo, esto es lo que ya veníamos haciendo, esto es lo que como que ya veníamos trabajando con Sinus ahora, ¿en dónde es que cobra sentido? y aquí voy a poner un caso en específico digamos que yo quiero hacer un flujo basado en esta selección o que la opción seleccionada tenga una lógica de negocio en específico ¿cuál va a ser esa lógica? primero, si el array de opciones está vacío, si no hay nada básicamente pues debería estar como ahorita que está en menos 1 es decir, pues no hay nada, no tengo que seleccionar nada porque el array está vacío, pero si el array si viene con datos yo quiero que la opción por defecto, o sea que haya una opción seleccionada por defecto y va a ser la que esté en la posición inicial entonces yo podría decir que pues está en la posición 0, y por defecto sé que si hay un array pues entonces pues la opción 1 es la que está en la primera posición hasta ahí todo bien, pero ¿qué pasa cuando empezamos a tener reactividad? ¿qué pasa cuando por ejemplo yo hago un setOptions y quiero modificar las opciones y por ejemplo hacer un nuevo array con otras opciones, por ejemplo aquí voy a tener options y voy a obtener opción 4, opción 5 y opción 7, digamos que es más esas que me autocompleta hasta la 10, no, dejámoslo hasta la 7, ahí está quiero que cada vez que yo como que cambie ese valor de forma reactiva, pues ocurra la lógica de negocio que te estaba comentando por ejemplo, en este caso voy a ponerlo aquí en menos 1 pero como aquí yo sé que es un array que tiene opciones, podría poner un set0 y por ejemplo cuando tengo un mpOptions cuando es vacío, pues yo quiero que el selectOptions quede en menos 1 ahorita estamos poniendo esa lógica de negocio como en métodos muy específicos pero colocando reactividad vamos a encontrarnos con algunos problemas entonces acá voy a tener esos botones entonces voy a poner un botón acá el de setOptions y el de mpBudgets, entonces uno va a setear como las opciones con estas opciones 4, 5, 6 y 7 y otro simplemente lo va a poner en 0 y pues nuestra lógica de negocio la primera es que si está en vacío lo pone en menos 1 y la segunda es que si hay opciones pues lo pongo en 0, entonces vamos a ver entonces vamos a ver acá si yo lo pongo, acá está el estado inicial position menos 1, perfecto, si yo le hago setOptions, pues la opción, la primera opción se seteó a esas opciones es decir, ya son otras aún así me dejan la posición 0 y la posición 0 es la opción 4 y cuando es empty pues básicamente no rendir eso nada porque no hay ningún valor, pero igual la posición queda en menos 1, perfecto teniendo esa lógica como en mente ¿qué pasa si ahora resulta que aquí yo tengo options, pero options listo yo lo controlo aquí dentro del drop-down ¿qué pasa si estas opciones ya no vienen aquí, sino que me las va a mandar un componente padre, ahí es donde se pone más interesante la cosa, entonces digamos que yo ya no tengo un signer, sino tengo un input signer, entonces ahora es required y como es requerido, pues tienen que enviarme un valor, lo importo y algo aquí ya cambió, algo aquí ya nos da error, y es que por ejemplo un input signer no le puedo hacer set, literalmente entonces yo pierdo estabilidad, y tiene sentido, porque al final esas opciones deberían enviarse desde el padre, entonces realmente yo no podría hacer este manejo, y entonces esta lógica ¿dónde la pongo? ¿dónde pongo esa lógica? en donde de acuerdo a una condición, pues la opción seleccionada va a ser una o la otra, entonces primero vamos a enviar esas opciones, entonces aquí en el componente padre, básicamente tengo una radio opciones 1, 2, 3, 4, y también un set options y una empty, como lo mismo que teníamos en el hijo, pero ahora manipulado desde el padre, y básicamente acá tengo esos dos botones, pero ahora sí le voy a enviar las opciones como parte de sus inputs es algo que me pide ese componente, sin embargo vamos a ver cómo reaccionar de forma reactiva, y ver cómo añadimos esa lógica de negocio, y dónde es que el link de inside cobra sentido entonces primero ya sabemos que aquí esto no lo podemos hacer, entonces voy a comentar esto por acá y básicamente también los botones que teníamos por acá, pues realmente no puedo modificar las opciones dentro del componente, entonces ya no lo tendría que hacer desde ahí, entonces listo, vamos a ver qué pasa aquí, por ejemplo acá tengo el menos uno, pero ya dejo de tener literalmente la lógica que me seleccionaba como si es varios elementos, pues selecciono la primera, si no hay ninguno, pues debería quedarse en menos uno, etc. ¿Cómo creen ustedes que podríamos empezar a hacer esto? Lo primero que podríamos empezar a hacer por ejemplo, lo primero que podríamos ver es pues select option podría ser un computed un computed que de acuerdo, en vez de que esto sea un signall, de acuerdo a las opciones, porque un computed se básicamente da una dependencia de un signall, entonces yo podría hacer algo como esto oiga mira, cada vez que cambie las opciones porque las opciones van a estar cambiando de forma reactiva, entonces me suscribo a ese cambio, y si son mayores a cero, acá está la opción cero y menos uno, entonces este me podría servir el problema de un computed es que yo no le puedo hacer set y yo necesito que cuando yo le haga click a mi opción a la opción que estoy seleccionando pues ese estado quede guardado en un momento, entonces bien, computed me podría servir como para agregar esa lógica de forma reactiva es decir, que cuando cambie el input, cuando el input haga un cambio y el padre le envía esa información al hijo, pues de forma reactiva yo recalculo el select options basado en una lógica el problema es que un computed no es writeable es decir, no puedo sobrescribir no puedo empujar valores la única forma de que se escribe un valor en un computed es con base a esta lógica, entonces aquí yo pierdo estabilidad y ahí es donde precisamente entra el linkedin signall, y es ok, pues el linkedin signall es una clase de computed, pero que si puedo como reescribir, y es más, antes de que saliera el linkedin signall, ¿cuál sería otra opción? ¿cuál sería otra opción para resolver esto? entonces, por ejemplo la más clásica, o las alternativas que teníamos, era pues hacer un effect, ¿no? hacer un constructor, por ejemplo por acá suscribirme a las opciones acá me voy a me falta importar, a ver inteligencia artificial, autocompletamente ahí está, ahora sí, listo entonces acá, por ejemplo este effect podría servir, y literalmente esa era la alternativa antes del linkedin signall es decir, yo me suscribo a las opciones, podríamos poner las opciones por acá, comes options, me suscribo a las opciones y aquí yo puedo ejecutar esa lógica que te venía diciendo es decir, si el array de opciones es mayor a cero, entonces pues, es que elija la opción la opción la primera opción si no hay nada, pues que la opción sea menos uno, entonces fíjense que acá lo podíamos resolver con un effect pero los effects no son de tanto agrado, y hay ciertas cosas que uno debería evitar de por si por ahí el equipo de angular dijo eviten hacer effects obviamente son útiles, son parte de la API, pero en la medida de lo posible, evítenlo, y precisamente para evitar este comportamiento crearon esta nueva primitiva llamada linkedin signall que literalmente me deja manipular y es casi como un computed pero que me deja setear esa opción, entonces ahora hagámoslo y si yo corro este código funciona es decir, fíjense que por acá tengo opción 1, opción 2, opción 3 perfecto, y como el array tiene valores, pues entonces me va a seleccionar lo que esté en la posición, ah mira, y de por si acá hay un error, está en la posición, debería estar en la posición cero, déjame ver, porque está o sea, debería ser la posición cerrada, déjame ver si voy a colocarlo más está en la posición cero si aquí hay cero elementos y acá sí, ahí está bien debería decir que la selección la opción seleccionada es cero, ah claro, acá también tengo un estado inicial, bueno, son cositas precisamente que van a ir pasando aquí ya lo resolví, por ejemplo la opción 1, 2 y 3 ahí está la posición cero ahí yo tengo la primera opción, no? si seteo las opciones fíjense que sigue funcionando es decir, el padre envía unas nuevas opciones, reacciona de forma reactiva sin ser redundante como hay opciones, entonces selecciona la primera, que es la 4, pero cuando el padre envía un array en vacío pues tengo la lógica de que esa opción, o esa posición cambie en menos uno, y acá ya podría ser un if, como que selectedOption no salga, por ejemplo podría ser un if acá un if, de que si la selección es diferente a menos uno entonces, pues realmente me aparezca este label, no? y aquí creo que estoy haciendo selectedOption varias veces, podría crear un let, por acá para ahorrarme esa doble suscripción, que realmente no hay tantos problemas de performance cuando uno se suscribe dos veces a un signall, entonces acá lo podría pasar y listo, y acá, eso estaría perfecto, selectedOption acá creo que tengo un error, tengo un error ah claro, porque es la opción, déjame option, porque estoy repitiendo el signall con el valor listo, entonces acá ya tendríamos cuando está en vacío, pues simplemente, posición menos uno, no hay nada, perfecto, ahora, este effect es el que molesta, este effect es el que dicen, es una mala práctica, deberíamos evitarlo, no deberíamos suscribirnos a tantas cosas de esta manera y ahí es donde entra el linkedInSignall o esta nueva primitiva entonces vamos a borrar esto y ahora definir esto como un linkedInSignall, entonces el linkedInSignall lo que me permite es definir un source, es decir desde cuál señal va a estar jactada a esta señal, porque es literalmente de las en lazo, entonces se vuelve algo como reactivo, cuando este cambie, muy parecido al computed que se suscribe como a alguno en específico o sea que le digo cuál va a ser el source, le digo options luego en computation es donde yo le envío pues ya la lógica, y fíjense que por acá me dice ok, tenemos lo de la lógica acá tenemos los valores, computation es un método que me va a recibir los valores del signall, de ese signall al cual yo, o de esa cuenta a la cual yo estoy haciendo ese linkeo, y si las opciones son igual a igual a cero, entonces pues la opción va a ser menos uno es decir no hay opciones, y si no va a ser la primera opción ¿no? y fíjense en algo, y es acá acá hay algo muy interesante, y fíjense que acá no me deja ser o sea, literalmente si me deja ser set, pero no me deja ser set, o sea para no confundir, si me deja, pero acá este error que me está mostrando aquí, es un error de typing, ¿qué quiere decir? si yo veo acá computation, me dice que los valores que él va a resolver es cero o menos uno, cero o menos uno, y se quedó con ese typing, de por sí recuerden que el link en signall está todavía en preview, y yo creo que este es un error de typing que todavía hay que arreglar, sin embargo aquí si lo van a dejar así, la forma de arreglarlo pues si, si angular lo va a dejar así básicamente la forma de arreglarlo es que el typing, o sea que esta función, que me devuelve solo cero y uno, y él lo coge como typing en vez de decirle que solo devuelva cero y uno, realmente yo necesito que sea de tipo number, y ya, o sea que para que luego cuando yo haga un set, me deje poner cualquier número allí que no solo sea cero y uno entonces simplemente lo resolví con como expresar o poner de forma explícita el typing en la función de computation listo, entonces ahora no tenemos el effect que está visto como hay que evitarlo a toda costa a menos que realmente necesites algo como track the login a veces cuando necesitamos canvas hay con las cosas de manipulación del dump que de pronto necesitemos un effect no es que no podamos utilizarlo si se puede utilizar, pero a medida de lo posible y si hay algunas otras opciones pues linkedinsignal o computed están bien, de por si linkedinsignal yo creo que va a reemplazar a varios de esos effects que teníamos por allí, que era la única opción, y ahora existe esta opción que es mucho más pura, mucho más nativa, mucho más atractiva, y de pronto evitamos malas prácticas con el effect entonces, tenemos el cell adoption, recuerden que el computed no podíamos tetear la opción porque no se puede, un computed el cálculo solo me deja hacer el cálculo dentro de la expresión del computed pero no afuera, aquí si me está dejando hacer el set no estoy utilizando un effect y pues voy a tener esa lógica, entonces vamos a ver aquí vamos a ver si funciona, es decir acá está, tenemos una red inicial opción 1 2 y 3, cuando hay elementos en el array, entonces voy a tener que la posición 0 de ese array de opciones es la opción por defecto, o sea opción 1, y ahí está opción 1 perfecto, pero si el padre me comunica un cambio con otro array de opciones entonces acá comunica un cambio, cambiaron las opciones mi componente de drop down reacciona a ese cambio y hace el nuevo computed del selected option, es decir dice, ah ok, ese elemento realmente si tiene, pues hay opciones es decir, no es igual o igual a 0, entonces como no es igual o igual a 0, porque significa que tiene elementos pues va a obtener la posición 0 y ahí puedo calcular esa posición bien, también podría hacer algo, fíjense que acá está pasando algo interesante, déjame lo vuelvo a digamos acá yo, tengo la opción 2, y cuando le hago set options ahí empieza a hacer como ese recálculo y ese linking que ya se empieza como a enlazar de forma reactiva y simplemente cuando yo tengo empty, pues simplemente no hay opciones que realizar, la posición es menos 1 y ya no muestro la opción seleccionar, entonces esto debería evitar literalmente cualquier effect que tenías por allí para de pronto con base a un cambio de un signal poder hacer set de otro que si lo hacías con un computed, pues no podrías hacer set, porque un computed de nuevo no es writeable, es decir, solo es de lectura no es de escritura, solo nos deja leer a través de ese cómputo, pero el linking de un signal si nos deja hacer el set así que sin problema lo que tendríamos que decirle es utilizar esta forma de por si hay algo que están trabajando que es ponerle un equal que esto lo que podría hacer es literalmente de acuerdo a que si realmente no cambian las opciones pues no ejecutar este computation, es decir, digamos que el pad me vuelva a enviar las mismas opciones, exactamente las mismas opciones o de pronto las mismas opciones que tienen los mismos IDs, entonces yo podría calcular algo acá para saber que si son exactamente igual, pues no volvamos a ejecutar el computation sin embargo, esta opción todavía está como en desarrollo, todavía no funciona muy bien cuando funcione bien, se las muestro y se las comparto, pero por ahora si es que funciona el linking de un signal y esa es la forma en que podríamos evitar esos effects y hacer ese linking entre varios signals y seguir programando de forma reactiva utilizando esta API, así que espero les haya gustado así que recuerden suscribirse al canal para más de estas noticias