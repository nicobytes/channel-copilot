 En este vídeo vas a aprender acerca de los Conditional Edge en Langrath, que es lo que nos permitiría crear bifurcaciones en un sistema de agentes. Así que vamos al código y vamos a empezar a aprender este patrón dentro de Langrath. En un sistema normal de agentes nosotros podríamos tener este tipo de nodos. Es decir, yo tengo un nodo 1, nodo 2, nodo 3. De por sí nosotros o dentro de mi canal ya hicimos como un sistema de agentes lineal. ¿Qué significa que sea lineal? Pues significa que simplemente después que yo interactuaba con el nodo 1, pues sigo al nodo 2 y luego al nodo 3. Pero ahora cómo creamos este tipo de patrón que yo pueda bifurcar, que pueda de pronto correr en paralelo, a veces es necesario, a veces simplemente necesito que decida entre uno y otro. Entonces vamos a crear esto. Bien, entonces lo primero que necesitamos es abrir nuestro ejemplo. Yo por acá tenía un sistema chiquito de un agente. Esto es un nodo de agente como lineal. Voy al nodo 1. Voy al nodo 2. Voy al nodo 3. Pero quiero volver esto a un... Quiero usar el Conditional Edge. Primero vamos a crear un notebook porque me gustaría primero experimentar y luego que experimentemos, pues ya podemos empezar a implementarlo ya en algún servicio de nuestra API. Voy a crear rápidamente una carpeta que se llama en notebooks. Bien, y voy a crear solo para tener nuestro orden. Voy a crear un Edge. O bueno Edge. No importa. No, Conditional. Conditional. Y entonces esto lo creo como un notebook. Perfecto. Entonces aquí básicamente lo que tengo que hacer es primero ya me voy a conectar a un Language Model. Bien. Para poder empezar a dejarle esta decisión a un Language Model. Aunque realmente no es necesario para aprender el Conditional Edge, pero pues vamos a ir viendo si lo utilizamos o no. O si en algún otro video ya empezamos a meterle un Language Model. Pero lo interesante acá es... Empezar a... Podríamos crear nuestro sistema de nodos. Por ejemplo, este que está acá puede ser suficiente. Entonces vamos a importar acá este pedazo de código. Vamos a importarlo. Vamos a crear estos tres nodos. Perfecto. Estos tres nodos los vamos a crear. Y listo. Acá básicamente como tengo una notebook, recuerda que yo estoy corriendo mi entorno con conda. Entonces voy a seleccionar el entorno en el que estoy corriendo, que en este caso lo llame Agents. Pero si tú estás utilizando Docker, Virtualenv o los sistemas de ambientes de poetry, simplemente selecciona el que sea de tu preferencia. Bien. En este momento yo selecciono el mío. Quiere decir que yo puedo correr este agente. Es decir, acá este agente lo voy a correr en este notebook. Bien. Entonces voy a crear acá ya la parte de Build. Y algo interesante de este es que vamos a poder crear este gráfico que es bastante interesante. Para saber cómo está quedando nuestro modelo de agentes. Por acá está precisamente esta línea de acá. Entonces voy a importarme este script que es básicamente IPython que ya está integrado. Y luego simplemente vamos a llamar a este método para que básicamente genere una gráfica de nuestro sistema de agentes. Entonces acá básicamente generamos Image. Acá tenemos el grafo. Sí, ahí está el grafo. Obtenemos el grafo y generamos la imagen. Entonces para hacer esto vamos a correr este pedazo de código. Me dice que todo está bien. Todo está check. Si corremos este pedazo de código también nos dice que está check. Y si corremos este último, pues deberíamos generar la imagen. Y literalmente tenemos una imagen súper sencilla de nuestro agente, de nuestro primer agente que es un sistema lineal. Pero la gracia es que ahora vamos a convertirlo en Edge. Es decir, que el nodo 1 decida si de pronto quiero ir al nodo 2. O al nodo 3. Y luego finalice. Bien. ¿Cómo se hace eso? Básicamente lo único que necesitamos es crear una nueva función. Entonces por acá podríamos crear una nueva función. Fíjense que acá tenemos el nodo 1, nodo 2, nodo 3. De forma lineal. Acá lo que agregaríamos es una función. No la vamos a llamar nodo 4. Por ejemplo acá le llaman decide node. Que es como un nodo que va a ser. O lo que va a ser es funcional. Y aquí le vamos a poner un nodo. Y aquí le vamos a poner un nodo. Y aquí le vamos a poner un nodo. Y aquí le vamos a poner un nodo. Y aquí le vamos a poner un nodo. Y acá también recibe el estado. Pero hay algo muy interesante. Si bien recibe el estado. Un modo, un nodo que es un conditional Edge. No retorna, no debería retornar un estado. Así como estos si lo hacen. Entonces estos serían nodos. Y estos serían conditional nodes. Exacto. Básicamente podríamos decir que un Edge. Un Node Edge. Siempre retorna un estado. Pero un conditional Edge retorna. Literalmente retorna un string. Pero básicamente lo que retorna es. El nombre del nodo al que tiene que ir. ¿Vale? Entonces si bien tiene acceso al estado. No retorna como tal el estado. Sino el nodo al que debería ir. Entonces acá por ejemplo. Lo que hacen es decirle que va a retornar. Un literal que básicamente es. O es esto o aquello. O sea solo tiene dos opciones de. Como de retornar algo. Esto es lo que se conocería como un. Union Time en TypeScript. Y lo sacan de aquí. El typing de literal. Entonces lo voy a importar por acá. Es más voy a crear este. Este como nodo de decisión. Como en este notebook aparte. O sea como en este bloque aparte. Va. Entonces acá quedan nuestros. Como nodos normales. Y si lo queremos dividir. Voy a crear otro bloque por acá. Solo como para dividir. Entonces básicamente acá tenemos. El estado. El estado de nuestro agente. Luego tenemos la definición de los nodos. Ahí está. Luego tenemos nuestro nodo que es un. Conditionalet. Que aquí básicamente no debería retornar al estado. Debería retornar el nombre del nodo. Al que quiero ir. En este caso digamos que. Quiero que vaya al nodo 2. ¿Vale? Entonces corro esto. Esto es una función. Al final es una función. ¿Vale? Sin embargo tiene acceso al estado. Yo puedo. Recordemos que mi estado. En este ejemplo. Tenemos dos cosas. Que es como una variable. Que es un string. Y el nombre del cliente. Que también es un string. Normalmente en un estado normal. Tenemos acceso a la. A los mensajes. ¿No? Como mensaje del usuario. Mensaje del sistema. Pero también podríamos tener. Otro tipo de. Como de cosas que almacenar. En ese estado. No solo los mensajes. En este caso tenemos estas dos. ¿Vale? Bueno. Entonces. Listo. Con base en ello. Entonces fíjense que yo agrego. El builder. O nuestro nodo. Sigue siendo. El mismo en cuanto a que aquí. Agrega un nodo. Sin embargo vamos a ver. Cómo se agrega ese. Edge. Entonces acá ya hacen la construcción. Acá por ejemplo. Agregan los nodos. Normal. Pero ya. En la lógica de decisión. Como básicamente saber. En dónde yo tengo que agregar. El. Ese Edge. Ese Conditional Edge. Básicamente lo hacen por acá. Entonces vamos a. Agregarlo. Entonces. Acá básicamente le decimos. Ok. Vamos a agregar un Conditional Edge. Entonces. Empezamos desde el Start. Desde el nodo 1. Y el nodo 1. Tiene que ir a. Llamar a Design Mode. ¿Vale? Design Mode. Básicamente. Lo que hace es. Y este de acá ya lo eliminamos. ¿Vale? Y lo que haríamos. Es que el nodo. 2. Obligatoriamente. El nodo 2. Y el nodo 3. Obligatoriamente. Tienen que ir al final. ¿Sí? O sea. No voy a desencadenar. Otro proceso. No importa si es nodo 1. O nodo 2. O nodo 3. Siempre van a ir al final. ¿Listo? Entonces aquí. Si yo lo compilo. Vamos a ver. Si no tengo ningún error. Vamos a generar la imagen. Ya que hay algo interesante. Fíjense que. Ahora. La forma. Me queda diferente. Tengo un nodo 1. Que al final. Tiene que ir al final. Y al final. Tiene que ir al final. El nodo 1. Va a ir. Como que. Internamente. Tiene. Una función. Que es la que cumple. Como condicional. Y esto va a retornar. Si va al nodo 1. O al nodo 2. Realmente. Si yo realmente corro esto. Siempre va a ir al nodo 2. Porque no le estoy diciendo. O sea. Si aquí le estoy diciendo. Que puede ir al nodo 1. O 2. Como que puede ser. Pero ya en mi lógica. Le estoy diciendo. Oiga. Usted siempre vaya al nodo 2. Entonces. Literalmente. Lo que va a hacer es. Ir a start. Ir al nodo 1. Ir al nodo 2. Y el nodo. 2. Va. Y finaliza. Que va. Y termina en el end. Pero aquí es donde. Yo puedo colocar. Alguna especie de lógica. Puede ser random. Puede ser. Con base a algún estado. Puede que el. Language model. Diga. Oye. De acuerdo a los mensajes. Que hay en este momento. Por favor. Deriva esto. A. X. O Y. Entonces ya es un poquito. De prompting. Por ejemplo. O de estado. O una call function. En donde yo diga. Si lo mando aquí. O allá. Entonces. Acá lo puedo hacer. Con un if. Normal de programación. Pero también. Aquí es donde. Podría también. Tener un language model. Acá. Qué hacen. Vamos a ver. Qué hacer. Por acá. Literalmente. Ejecutan un random. Entonces. No vamos a saber. En algunos puntos. Va a ser como. El 50 por ciento. De probabilidad. Que vaya al nodo 1. O 50 por ciento. De probabilidad. Que vaya al nodo 2. Y listo. Entonces. Fíjense. Aquí vamos a importar. Este. Random. Import random. Y entonces. Básicamente. Si es. Men. Si la probabilidad. Es menor a 0.5. Fíjense. Que acá. Retornamos. El nodo 2. Pero si no. Entonces. Retornamos. El nodo 3. Entonces. Ahora sí. Ya. Sería un poco más. Randomico. Como que. Siempre antes. Estábamos. Si o si. Retornando. El nodo 2. Le estábamos diciendo. Por typing. Que puede que. Puede que. O las opciones. De retorno. Es nodo 2. O nodo 3. Pero ya. Aquí. En forma programática. Pues le decimos. Como. Con un random. Bien. Si lo corremos. Si vuelvo a ejecutar esto. Pues no va a cambiar la gráfica. Porque sigue siendo igual. Como que. El nodo 1. Recordemos que. Este paso. Es súper importante. Este. Yo acá. Le estoy diciendo. Que el nodo 1. No va a ir directamente. A un. A otro nodo. Sino que aquí. Ya lo estoy. Poniendo en una función. En donde. Esta función. Es la que va a decidir. A qué nodo. Va a hacer el siguiente. Porque ya va a tomar. La ejecución. Entonces. Eso. Básicamente. Es. Un conditional. H. En este momento. Ya podríamos. Entonces. Implementar. O ponerle. Algo de un. Lar language model. Para que de pronto. Con base. A los mensajes. O algo así. Pues nosotros. Ya podamos. Tener una decisión. Con base. Al historial de mensajes. Pero esto es un conditional. H. Y es ya una de las partes. Importantes. Para entender. Cómo es un flujo. De nuevo. Aquí. Por ejemplo. En este. Script. Todavía. No hay nada de. Lar language model. Es simplemente. La concepción. Que tiene. La graph. Para construir. Este tipo. De sistemas. Aquí. De nuevo. Es donde yo ya puedo. En base. Al estado. En base. A un. Lar language model. En base. A una. Function. En base. A. X. Cosa. Y acá. También es interesante. Porque. Cada nodo. Puede tener. Una. Una llamada. A un. Lar language model. Diferente. De nuevo. Recordemos. Nuestro. Querido. Artículo. De. Antropic. En donde. Nos dan. Como este tipo. De patrones. En donde. Cada. Parte. Como verdecita. Es un. Una llamada. A un. Lar language model. Entonces. Por ejemplo. Aquí. Yo puedo tener. Casi que. Este. Esto que hicimos. Ahorita. Es muy similar. A un. Lar language. A un. Lar language. Call router. Ese sería. Como el. Decision mode. Y. Pues. Cada uno. De esos nodos. Puede hacer. Otra llamada. Lar language. A otro. Lar language model. Y aquí. Puede decir. Que por ejemplo. El que tome la decisión. Sea un. Zero one preview. O un. GPT cuatro. Pero de pronto. Ya en este. Lar language model. Call uno. Quiero. No sé. Hacer algo más específico. Por ejemplo. Utilizar. El modelo. De Mistral. Por ejemplo. Mistral. Hace poco. Subió un nuevo. Modelo. Para. O sea. Como enfocado. A código. Para generar código. Y de pronto. Este nodo. Sea el específico. En. No sé. Crear código. En crear. Unites. En algo. Un agente. Que sea especial. En código. Entonces. Este puede ir. Y hacer el call. Hacia el modelo. De Mistral. Pero. Este tiene un open. Allá. Y el call dos. Tiene. No sé. Uno. A lama. Etcétera. Entonces. También. Es donde podemos tener. Un híbrido. De modelos. Listo. Ahora tienes. El conocimiento. De cómo crear. Un conditional edge. Dentro del land graph. Esto es. Su. Perdón. Perdón. Perdón. Perdón. De nuevo. A repetir. Esta parte. Listo. Ahora tienes. El conocimiento. Para poder crear. Un conditional edge. Recuerda. Que esto es uno. De los patrones. Más importantes. Para saber. Precisamente. Si. De acuerdo. A una decisión. De acuerdo. A un output. De un. La lengua. Como del tomo. Cierto nodo. O cierta bifurcación. Y así. Puedes ya crear. Varios niveles. Por ejemplo. El nodo dos. Puede tener la decisión. Entre otros dos. Y así. Entre otros dos. Y crear ya. Un sistema. Un poquito. Más complejo. Pero ahora. Llega un momento. En el cual. Ya necesitamos. Pues no solo. Construir. Como estas. Piezas fundacionales. O básicas. Para entender. Un sistema de agentes. En Landgraf. Sino realmente. Ahora vamos a conectarlo. A un. La language model. Utilizando. Lanching. Aquí es donde. Se conectan las partes. Landgraf. Como sistema. De orquestamiento. Con este sistema. De grafos. Y nodos. Y lanching. Como una librería. Como una utilidad. Para conectarse. A la lengua. Y ahí. Como que los dos. Ya. Se van conectando. Pero lo interesante. Es que tú puedes. Literalmente. Podrías tener. Un sistema. De orquestamiento. De agentes. Basado en Landgraf. Y utilizar. Cualquier otra librería. Para llamar. O conectarte. A tu. La language model. Entonces. No significa. Que debas usar. Lanching. Pero obviamente. Es desde la misma casa. Entonces. Como que. Van bien juntos. Sin embargo. Puede ser agnóstico. Puedes utilizar. No sé. Lama. Para llamar. A. Literalmente. O sea. Lama index. Que es otro framework. Para ya conectarse. A la. Language model. Como tal. O puedes. Literalmente. Ya utilizar. Directamente. La librería. De Python. Por ejemplo. Para OpenAI. Y ya hacer. Las llamadas. Directas. A la language model. Sin pasar. Por esta. Serie de utilitarios. Pero puedes utilizar. Landgraf. Es para orquestar. Tu sistema de agentes. Así que no siendo más. Suscríbete. A mi canal. Para poder. Seguir aprendiendo. Más acerca. De sistemas. Y multiagentes. Con Landgraf. Y en el siguiente video. Pues ya vamos a conectar esto. Con la language model. Usando Lanching. Así que. Te veo en el próximo video.