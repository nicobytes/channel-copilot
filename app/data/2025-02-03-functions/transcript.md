 Una de las características más importantes que tienen los agentes es el acceso a herramientas. Esto es precisamente lo que nos va a permitir acceder o extender nuestros sistemas de agentes a características o otros sistemas. ¿Qué quiere decir esto? Que normalmente, hagamos de cuenta que tú tienes en uno de los agentes que yo he trabajado, por ejemplo, un sistema de appointments, un sistema de reservas. Normalmente tú no puedes brindarle esa información a la gente. Y no puedes brindárselo ni siquiera en forma de contexto, utilizando alguna técnica como RAC. No tiene sentido porque realmente tú necesitas no vectorizar la información ni nada por el estilo, sino necesitas ingreso a tu aplicación, a una API de tu calendario, de tu sistema o a Google Calendar, si lo conectas a Google Calendar. Y en tiempo real mirar la API, mirar la disposición con un request, con una API, con una consulta, una base de datos y luego devolverle esa información. Esa información a la gente para que la interprete y luego la devuelva al usuario. Entonces, esto es lo que nos permite es extender en casi un tiempo real que los agentes puedan maniobrar. En algunos puntos, no solo maniobrar o extenderlo a sistemas como APIs, como bases de datos, sino a veces es una forma de darle cuerpo a esa gente. Hagan de cuenta de que, por ejemplo, si nosotros como cerebro tenemos la Language Model, podríamos luego conectar ciertas funciones. A hardware específico como a robótica, como para mover, para girar una cámara, etcétera. Esa ya sería una API muy específica o prender un volvillo. Entonces digamos que tenemos domótica y necesitamos conectarnos a cierta API por Bluetooth que tiene, por ejemplo, una luz LED. Entonces yo sé que por domótica puedo accederlo y controlar. Entonces es la manera de extenderle, de ponerle un poco de cuerpo o extender más nuestro sistema para que nuestros. La Language Model. Se puedan conectar en nuestro sistema de agentes o al final el usuario o el cliente final se conecte a este tipo de sistemas. Call Functions no es la única forma de hacerlo. Antropic presentó también una forma muy interesante con un protocolo también que permite extender las capacidades de un sistema dándole mucho más control. Pero creo que aún así las Call Functions son mucho más simples y el poder es muy, muy interesante. Así que hoy en este video vamos a aprender cómo en Landgraf, en nuestro sistema. De agentes vamos a empezar a orquestar y a tener Call Functions. Así que vamos a empezar al código. Para hacer esta integración y empezar a nuestro agente conectarlo a ciertos Call Functions, pues vamos a ver y vamos a ir siguiendo como estos tutoriales oficiales de Landgraf, en donde precisamente nos van explicando cómo ir haciendo este sistema de agentes y ahí le vamos metiendo más cositas y demás. Pero básicamente lo que tenemos es que podríamos tener un stat. Recordemos cómo funciona. Todavía no. En nuestra arquitectura de grafos o cómo funciona Landgraf en su arquitectura de grafos. Primero hay un mensaje inicial. Luego lo podemos pasar por un Landlanguage Model, pero es el Landlanguage Model. Podemos conectarle tools. Hay que tener muy en cuenta si nuestro Landlanguage Model o el modelo que escojamos si tiene acceso como a tools, no tiene Call Functions, porque no todos los modelos tienen la habilidad de hacer Call Functions. Claro que la mayoría de modelos ahorita tienen como que es un feature por defecto. Pero en GPT-2, GPT-3 no había estas como esta feature y ya casi que todos la tienen. Así que es muy raro realmente que algún modelo no tenga Call Functions, pero puede haber que un modelo no lo tenga. Entonces, por favor, tener mucho en cuenta eso, porque si al final no soporta este feature, pues no podríamos extender o utilizar esas herramientas. Modelos que no la tienen, por ejemplo, modelos livianos o open source como Gema, que es un modelo open source liviano. De Google, por ejemplo, no tiene Call Functions. Bien, pero es un Landlanguage Model que no puede correr nativamente en un celular. Por ejemplo, eso lo hicimos, por ejemplo, en uno de mis videos. Te los voy a dejar por acá, en donde corrimos Gema en una aplicación en Android de forma offline. O sea, literalmente se corría en el celular, pero es un modelo liviano. Los modelos ya grandes, pues obviamente, pues sí, normalmente tienen como esta característica. Y acá hay algo interesante y es que nosotros cuando le decimos a un LandlanguageModel. Que accede a una tool, hay que saber un poco diferenciar cómo el modelo va a actuar. Porque es importante saber cómo el modelo va a actuar cuando nosotros le damos una tool. Porque normalmente cuando nosotros, por ejemplo, una función sencilla. Si yo le pregunto a un modelo cuánto es 5x3, el modelo es capaz de responderme, no hay ningún problema. De pronto, algunos modelos previos no eran tan buenos como con operaciones. Pero podrían sumar. Y podrían sumar, multiplicar. A veces no tan bien, ¿no? Como que a veces se enredaban. Pero el LandlanguageModel, como un GPT-4. Claro que los modelos nuevos de razonamiento, como el GMI Thinking. O el de DeepSeq R1. O los Zero One Preview de OpenAI. Como tienen un razonamiento, ellos sí como que son capaces de ejecutar. De pensar un poco y de procesar antes de votar una respuesta. Pero si tú estás con un GPT-4 o GPT-3. De pronto, no va a ser bien esas operaciones. Él va a intentar. Pero de pronto no las va a hacer siempre bien. Entonces, cuando tú quieras, por ejemplo, hacer una multiplicación, una suma. Pues a veces, simplemente decirle. Mira, esta es la función para sumar. Y tienes que ejecutar esta función en Python que hace la suma. Ahora, eso pues simplemente lo extendemos. Y él en vez de buscar la respuesta en el LandlanguageModel. Como en generarla. Simplemente va a conectarlo a la función. Y ya va a operar lo que tú le describas en la función. ¿Sí? Si tu función de sumar está mal. Eso ya es cuenta tuya. Pues tienes que escribir bien tus funciones. ¿No? Porque al final tú le das esa respuesta. O básicamente el LandlanguageModel va a tener la forma de operar o de ejecutar esa función. Y literalmente luego retorna esa respuesta. Y construye una respuesta al usuario. ¿No? Entonces como que va. Le envía esa con parámetros y todo lo que necesites a una función. La opera la respuesta. El return. Es el que luego de pronto. Lo va a mandar hacia el usuario. No lo va a enviar en crudo. Como la respuesta es 2 más 2. 4. ¿No? Lo va. Normalmente lo trata de poner bonito. Como pues la respuesta a tu anterior pregunta es 4. ¿No? Pero la complementa. Pero el resultado depende de la lógica de tu función. Ahora, para sumas, restas. Pues obvio no es tan interesante. Pero obviamente cuando yo tengo que hacer por ejemplo un agendamiento. O quiero mirar el clima. Que es un ejemplo sencillo. Pues al final la language model no tiene en tiempo real. Pues no sabe qué clima es. No sé en New York o en Bogotá. En La Paz. Si no sabe exactamente cuál es el clima. De pronto si yo no le meto la tool. Pues va a empezar a inventar. Pero como necesitamos evitar eso de las alucinaciones. Y de que invente. Pues podemos conectarlo a la API del clima. Va a consultar. Lo trae y genera una respuesta. Entonces ese como flujo hay que tenerlo muy en cuenta. Y. Y pues lo vamos a hacer en código. Vamos a empezar por unas funciones sencillas. Vamos a empezar por esas funciones que son de operaciones. Supongamos que no vamos a confiar en la language model. Para hacer operaciones matemáticas. Sin embargo creo que un GPT-4 ya lo sabe hacer muy bien. O un modelo de razonamiento ya lo hace muy bien. Sin embargo pues para empezar a calentar motores. En lo que es una call function. Pues aquí vamos a definir algunas herramientas. Algunas funciones. Que luego se las vamos a decir. A la language model para que las opere. Aquí es donde luego podemos sacarle potencial. En esas funciones es donde podemos conectarnos a una API. Podemos conectarnos a la API del clima. Al calendario etc. Y con eso pues. La language model se va a alimentar. Entonces vamos a escribir estas funciones. Vamos a ir a nuestro código. Al que hemos estado trabajando. A lo largo como de esta saga. Como de tutoriales. Y vamos a crear un notebook. Y luego ya vamos a probarlo en el sistema de debugging. De. Langriff. Entonces vamos a crear el notebook 03. Y aquí voy a llamar a este tools. Vamos a empezar a manejar tools. Bien. Listo. Voy a hacer lo necesario. Lo típico de siempre. Primero cargar variables de ambiente. Es como lo primero que se hace. Lo corro. Acá tengo que seleccionar el kernel. Ahí está. Ahí está. Luego ejecuto. Cargo las variables de ambiente. Ahorita solo estoy conectándome a OpenAI. Pero luego podemos empezar a tener variedad de modelos. Y recordar que modelos son los que realmente soportan call functions. Ok. Luego, ¿qué vamos a hacer? Aquí es donde yo me conecto a un... Pues con Lanchain me estoy conectando a el GPT-4. Entonces aquí literalmente con Lanchain y con la librería especial de OpenAI. Pues le digo chat OpenAI. Me conecto al modelo. Le digo la temperatura. Y básicamente lo invoco. Acá le digo un hello. Hello, how are you? Y vamos a ver qué responde. Aquí en ese hello, how are you? Y esperamos a que se ejecute. Ahí está. Me dice hola. Yo solo un programa de computadora. No tengo sentimientos. Bla, bla, bla. En fin. Eso es una respuesta normal de GPT-4. Pero vamos a conectarle tools a este... La language model. Y aquí es donde necesitamos ciertas funciones. Entonces vamos a hacer la función de multiplicar. Aquí también es donde los componentes. Los comentarios importan. Porque normalmente él va a tener contexto de esta función. Y hay algo muy interesante. Y es que aquí tenemos Python con hints o con typing. Como TypeScript. Pero soportado nativamente por el lenguaje como debería ser. Pero esto también le ayuda mucho. Le ayuda mucho porque la language model va a entender. Esta función de multiplicar y recibe dos parámetros. Y esos dos parámetros no son cualquier tipo de parámetros. Son enteros. Y que devuelve? Devuelve uno entero. Además de eso tengo documentación. Y además de eso tengo ya el return. Bien. Entonces los comentarios importan. Cuando estás haciendo esto. Importan los comentarios. Y si además de eso le pones typing. Eso también importa. Bien. Entonces vamos a hacer solo una. Multiplicar. Y luego ya vamos a ir metiendo las demás. Solo quiero abordar una en este momento. Bien. Listo. Tenemos nuestra función. Tenemos una función. Luego va a haber una forma de. De por si hay un decorator. Para poner como esto es una tool. Luego vamos a verlo. Pero empecemos por lo sencillo. Listo. Entonces luego yo tengo un. Puedo como conectar un array de tools. Que básicamente es un array de funciones. Porque al final estos son funciones. Entonces puedo conectar varias. Pues varias funciones. O lo que llamaríamos tools. Y luego lo que hacemos. Fíjense que lo que hacemos acá. Acá lo que hacen es. Utilizar la misma instancia. Que ya teníamos acá. Que es este. Lar language model. Fíjate que acá. Tenemos el lar language model. Y lo invoco. Sin embargo aquí. Este lar language model. No tiene. No tiene literalmente. La potestad. O no tiene tools. Es más. Si yo le pregunto. Hola. Cuánto es. Uno por. Por. Por doce. O dos por doce. Entonces. Fíjense que acá. El que va a responder. Es GPT4. Como con su inteligencia. Dice hola. Dos por doce. Es igual a veinticuatro. Ahí lo hizo bien. Realmente de nuevo. Estos modelos. GPT4. Creo que ya lo hacen bien. Un GPT3. Como que a veces no. O si uno le ponía. Como algo complicado. Como que. Empezaba a sacar cosas que no. Pero recuerden. Que la gracia también de las tools. Es conectarlos. A sistemas de real time. Obviamente. De nuevo. La lengua. No sabe el clima. Actual que hay en Nueva York. En. Cochabamba. Entonces ahí es donde nos sirve. Bien. Pero. Por ahora. Una multiplicar. Está bien. Ahora. Vamos a ver la diferencia. Voy a conectarme. A otro lar language model. Bueno. Al mismo. Realmente al mismo. La lengua. Model. Pero ahora. Añadiéndole. Tools. Entonces. Básicamente. Acá. Lo que hacemos. Es. Podemos sobre. Escribir. El. La lengua. Model. Pero. Esto. Si es de. Lanchen. Lanchen. Nos permite. Hacer. Esta función. Que es. Vine. Tools. Que lo que hace. Es como. Pues. Básicamente. Enlazar. Esas funciones. Al. Language. Model. Ahorita. Nuestro. Lar language. Model. Tiene. GPT. 4. Y tiene. Una temperatura. De 0. Es decir. No es muy creativo. No sé. Si le. Aumente. La creatividad. Un 0. 9. De pronto. Empiece. A alucinar. Veamos. No creo. Como. El. Saltos. De línea. Pero. No. No falla. Dice. 12. Veces. 12. Y 2. 2. Veces. 2. Veces. 12. Es 24. No. No. No. Está mal. La respuesta. Pero. Puede. Entre más. Temperatura. Tenga. Pues. Más creativo. Se pone. Y puede alucinar. En fin. Entonces. Aquí es donde. Vamos a. Sobrescribir. Nuestro. Lar language. Model. Actual. O la instancia. De nuestro. Language. Model. Que teníamos acá. Y. Básicamente. Ahora le pasamos. Una que tiene. Tools. Bien. Acá le decimos. Que no quiero. Que haga. Que no llame. Varias. Como funciones. En paralelo. Que eso puede ser interesante. Porque si yo le saco. Ya una ecuación. Como. De estas ecuaciones. Que tienen. Por. Pero menos. Pero luego. El nivel. A la 2. No. Como que podría llamar. Varias funciones. Como en paralelo. Pero ahorita. Quiero ir llamando. De a una. O sea. Si él se da cuenta. Que la mejor. Es la de multiplicar. Porque es el caso. Que le estamos dando. Pues. Vaya. Y. Mire. Cuál de sus tools. Son las mejores. De por sí. Esa es otra cosa interesante. Ahorita. Solo tenemos. Una tool. Como. La de multiplicación. Pero luego. Pues yo le puedo sumar. La de dividir. La de restar. Y ahí. La language model. Tiene que saber. Cuál es la tool. Como indicada. Precisamente. Para resolver. Lo que el usuario. Me está pidiendo. Si yo le pido. Una suma. Pues debería utilizar. La función. De la. La suma. No la de multiplicar. No. Él mismo. Va a razonar. Y literalmente. Saber. Cuál función. Ejecutar. Bien. Entonces. Acá tenemos. La language model. Y ahora. Lo podemos ejecutar. O sea. Si yo lo ejecuto. Si yo lo ejecuto. Déjame. Creo que lo puedo ejecutar. Tal cual. Como lo ejecutamos. Acá. Solo para ver. Cómo. Es la invocación. La respuesta. Va a ser. Un poquito. Diferente. Veamos. Cómo va a ser. Ahora. Cómo va a ser. Con. Pues. Con. Ya añadiendo. Una tool. Fíjate. En algo. Muy. Muy. Interesante. Y creo que es la parte. Más interesante. Que hay que tener en cuenta. Y es. Acá nosotros. Tenemos un. Content. Bien. Content. Con la respuesta. Cuando tenemos un content. Es básicamente. La respuesta. Que produjo. La language model. Bien. Sin embargo. Cuando yo tengo. Una tool. Este content. Llega en vacío. O sea. La language model. No produce. Una. Respuesta. Lo que me dice. Lo que me da. Es aquí. Un tool. Calc. Y me dice. Ok. Mira. Según. Lo que tú me dijiste. Que es resolver. Una multiplicación. Lo que debe hacer. O lo que debes hacer. Es ejecutar. Tu función. O. Básicamente. Me dice. Cuál tool. La que tengo que ejecutar. Y pues. Reconoce los parámetros. Acá. Es muy interesante. Me devuelve un array. De los arguments. Es decir. Literalmente. En lenguaje natural. Me dice. Ok. El 2. Sería A. El 12. Sería B. La función. Que yo tengo que operar. Es multiply. Y es de tipo function. Entonces. Básicamente. Literalmente. Lo que me da. Es como. En un diccionario. Me dice. Mira. Según mi conocimiento. Lo que tienes que hacer. Es operar esta función. Y yo ya. Voy. Y la ejecuto. Pero. Lo interesante es esto. Primero. Me supo. Qué tool. Tiene que llamar. Y segundo. Yo. Mapio. Los parámetros. De forma. Correcta. Es decir. A. Es 2. Y B. Es 12. Eso es un caso. Muy interesante. Porque a veces. Nosotros. Ahorita lo vemos. Como de forma. Tan sencilla. Pero a veces. Nosotros. Por ejemplo. Para hacer un sistema. De agenda. Necesitamos. No sé. Una fecha. Para asignar. La agenda. De una persona. El nombre. De la persona. Y de pronto. La ciudad. Porque. No sé. Necesitamos saber. En dónde asignar. La ciudad. Eso pueden ser parámetros. Y yo le puedo decir. A la language model. Oye. Pídele al usuario. En una conversación amable. Pídele estos datos. Como dime tu ciudad. A qué horas quieres la cita. Cómo es tu nombre. Y una vez. Ya tenga los parámetros. Ya sabe. Qué función. Ejecutar. Y eso es interesante. Y vamos a ver. Si lo logramos hoy. Es decir. Que mientras. La pregunta. No sea. De multiplicar. Él responde. Porque no. No. Tiene necesidad. De llamar a la función. Vamos a hacer el ejemplo. O sea. Por acá. Por ejemplo. Digamos que yo tengo. Una pregunta. Pues. No le voy a hacer. Una pregunta. De multiplicación. Le voy a hacer. Una pregunta. Que no tenga que ver. Con una suma. O algo así. Hola. Cómo te llamas. Cómo te llamas. Listo. Entonces. Fíjate. Que acá. Si va a ser. La respuesta. Como un string. Es decir. Acá. Si tengo un content. Él. Analizó. Y dice. Ok. Mira. Yo sé que tengo unas tools. Porque acá están. La de multiplicar. Pero sé que. Para esta pregunta. No hay necesidad. O sea. No. No hubo necesidad. De llamar. Ninguna tool. O alguna función. Porque dentro. De la memoria. Dentro. De lo que envió el usuario. También puedo. Razonar. En el array de mensajes. En el historial. Pero al menos. En esta primera pregunta. No hay. Suficiente información. Para decir. Hay que llamar. A la función de multiplicación. Pero. En la pregunta anterior. Sí. Entonces. Ahí lo que cambia. Es la respuesta. No me genera una respuesta. Me dices. Cómo. Yo. Tengo. Que analizar. Esa. Respuesta. Saber. Si. Si. Tengo que llamar. A esa función. Y pues ya. Literalmente. Le mando. Estos argumentos. Que ya fueron mapeados. Por la language model. Porque es interesante. Porque. Fíjense. Que. Pongamos. Otra. Otra. Otra. Otra función. Digamos. La de. La de sumar. Tan. Tararán. Pongamos sumar. Entonces. Ahora. Le damos. Add. Porque. Aquí. Aquí. El potencial. De lo que hace. Y hagamos otro. Para no perder. Acá. Eso. Entonces. Aquí. Lo potencial. Hola. Dime. No le va. No le va a utilizar. El más. Sino. Cuánto es. Dos. Más. Tres. No. Yo. Trabajo. De qué. Otra forma. Puedo decir. Que sumes. Sin decirle. Que sume. O sea. Como. Cuánto es. Cinco veces. Tres. Pero. Es una multiplicación. Pero. Pero. Digamos. Esa. Cuánto es. Cinco veces. Tres. Y. Y. Qué hace. No. Cuánto es. Cuánto es. Cinco. Veces. Cuarenta y ocho. No. Entonces. Fíjate. Que. No le estoy dando. El símbolo. El símbolo. Per se. De multiplicar. Es más. Démosle un número. Cuántas veces. Es cinco. Veces. Cuarenta y tres. No. Entonces. Vamos a ver. Qué pasa. Vamos a ver. Si coge la de suma. Bueno. Aquí. Como añadí una nueva función. Creo que tengo que volver a ejecutar. Esta línea de código. Porque. Pues. De eso se trata el notebook. Y. Ejecutamos ahora. Esta. No. Entonces. Aquí. De nuevo. Content. No hay. No me generó respuesta. Pero. Lo que sí tengo. Es. Vamos a ver. Cuáles. Eligió. Dijo. Que es la función de multiplicar. Y. Mapeó los parámetros. Es decir. Ese cinco. En texto. Lo convirtió. En un cinco. En número. Que es. Cómo debe. Cómo debe. Recibir. Mi función. Pues. El parámetro. Es decir. Lo. Hace como ese. Cas. Porque. Literalmente. En la. Language model. O. El procesamiento natural. Del lenguaje. Literalmente. Puede. Saber que cinco. Lo transforma. Pues. En cinco. En número. Y. Luego. Sabe que. Veces. Es. Pues. Multiplicar. Y. En fin. No. Como que me mapea. Los argumentos. Y la función. Y yo. Obviamente. Ya con esta información. Puedo ejecutar. La. La función. Per se. Lo único que tengo que hacer. Es pues. Guardar la respuesta. Y. Hay que hacer unos trucos. Bueno. No trucos. Simplemente. Que. Básicamente. Hacer un if. El contenido. Está en vacío. O. Básicamente. El contenido. Tiene. Tool calls. Si tiene esto. Es porque. Necesito. Antes de enviarle. Una respuesta. Al usuario. Pues. Necesito. Procesar. Esta información. Necesito. Enviarle. Estos argumentos. A mi función. Ejecutarla. Y luego. Si. Entonces. Mandarle. Una respuesta. Al usuario. Ya sabemos. Cómo funciona. La language model. Cuando. Tiene que operar. Una tool. Y cuando. Literalmente. Dentro de esas tools. Que le ponemos. A la language model. Pues. Simplemente. No encuentra. La tool. Adecuada. Y pues. Nos contesta. Pero al final. Pues. Necesitamos. Meterlo. En nuestro sistema. De grafos. Y al final. Porque eso es lo que necesitamos. Que. Pues. Hay un flujo conversacional. Y. De acuerdo. A ciertos parámetros. Llame. O no. A cierta. Pues. A cierta función. Entonces. Aquí es donde. Acá. Por ejemplo. Tienen algo. Sencillo. ¿No? Tenemos. Sacamos el message stage. Que es el que maneja el historial de mensajes. Tenemos un system prompt. Para guiar a nuestro sistema. Y tenemos un nodo. El nodo. Que al final. Es el que se conecta. A la language model. Pero acá. Al final. La language model. Es la instancia. Que aquí. Ya le pusimos. A la que. Vendíamos tools. Y la que tiene. Pues. GPT4. ¿No? Por acá. Tenemos a GPT4. Entonces. Al final. Lo que hace. Es. Pues. Invocarlo. Sin embargo. Landgraf. Tiene una cosa. Muy interesante. Y es que. Tiene una cosa. Preconstruida. Que se llama. Un tool node. Esto es interesante. Porque como que. En un nodo. Mete como todas las tools. Y luego. El sistema de agentes. Es como consciente. De todas las tools. O todos los nodos. Son conscientes. De las tools. Que pueden ejecutar. Entonces. Cualquier nodo. De nuestro sistema de grafos. Puede ir a alimentarse. De esas tools. Entonces. Vamos a hacerlo. ¿Listo? Entonces. Aquí ya voy a meter. El código directo. Directamente. En Python. Para luego. Debuguearlo. En nuestro sistema de agentes. Entonces. Ya me voy a salir. Como del notebook. Necesitaba que aprendiéramos. Como un poco funciona. Como opera. Cuando. Por ejemplo. Nos va a contestar. Un mensaje en vacío. Y cuando. Realmente. Nos dice. Que función va a ejecutar. Pero ahora sí. Vamos a ver el código. De nuestro agente. Bien. Entonces aquí. Literalmente. Me va a crear. Una nueva carpetita. Con nuestro nuevo agente. O no. Creo que con un archivo. Como lo hemos manejado. Está bien. Voy a hacerle. Tool. Aunque empiezan a crecer. Los archivos. Luego vamos a ver. Que ya en arquitectura. Pues de software. Ya es mejor tener. Pues una estructura. Como en una carpeta. Las tools. En otra carpeta. Los nodos. Como. Es ya más. Un principio de arquitectura. Como cuando. Pues hace una organización. De una API. Tiene los controladores. Los servicios. Como divididos. Los routers. Etcétera. Ahorita. Simplemente. Vamos a ponerlo todo. En un solo archivo. Y. Va a funcionar bien. Pero luego. Pues para sistemas más grandes. Obviamente. Es mejor empezar. A hacer split. De esos componentes. Va. Entonces. Voy a. Voy a. Donde está nuestro sistema. Acá. Este me va a guiar. En el que hicimos. De. La language model. Que ya tiene. El message stage. De por si. Este es el que necesito. El message stage. Entonces. Acá. Lo voy a tener. Lo que necesito. También. Es. Pues mi. La language model. Con las tools. Entonces. Acá. Realmente. Este. La language model. Lo voy a poner. En uno de los nodos. Entonces. Primero. Me voy a crear. El nodo. El nodo. Acá está. Voy a crearme. Este nodo. Y listo. Entonces. Acá. Hay un system prompt. Obviamente. Tengo que hacer. Las. Las. Importaciones correspondientes. Entonces. Acá. Me pide un estado. Voy a ponerle. Estado. El estado. De mi sistema. De agentes. Que al final. Hereda. Del. Del. Message. Stage. Ahorita. Lo podría dejar. No. Déjamelo. Así. Tal cual. Y. Con este. My bar. Y luego. Simplemente. Pues ponemos. El system. Message. Ahora. Realmente. En el system. Message. Esto. Todo esto. Puede ir. Directamente. En la función. Del nodo. Aquí. Vamos a ponerle. Así. Así. Así. Bien. Lo vamos a llamar. Como asistente. Bien. Y. Acá. Este asistente. Voy a poner esto. Como directamente. En la función. Entonces. Aquí mismo. Vamos a tener. El system. Prom. Y. Aquí. Le voy a decir. Que después. Es un. Y. Se lo voy a hacer. En español. A ver. Eres un. Experto. En matemáticas. Y. Debes. Ayudar. Ayudar. A resolver. El problema. Listo. Un. Otra vez. Un. Prom. Muy sencillo. Luego. Si quieren. Vemos. Prom. Engineering. Pero. Ahorita. De por sí. Land. Land. Smith. Que es uno. De otro. De los servicios. Un. Sistema. Muy interesante. De hacer. Prom. Engineering. Pero. Pues. Por ahora. Dijimos. Ahí. Listo. Vamos a. También. A crear. La. Language. Model. Aquí mismo. En esta función. Para que. Como que. La función. Tenga contexto. De lo que. Debemos hacer acá. Entonces. Acá. Se crea. Este. Channel. Open. Ahí. Ahí. Nos llamamos. La importación. Entonces. Por acá. También. Tenemos. Esa importación. GPT. Cuatro. Con. Esta. Temperatura. Luego. Necesitamos. Bindearle. Las. Tools. Entonces. Acá. Pues. Necesitamos. Las. Tools. ¿No? Necesitamos. Realmente. Aquí. No. Necesitamos. Mentira. Aquí. No. Necesitamos. Bindear. Las. Tools. Ahorita. Les digo. Dónde. Es que. Se. Bindean. Las. Tools. Se me. Partió. Por acá. El. Ejemplo. Acá. Tenemos. Este. La. Language. Model. Con. Tools. Pero. Vamos. A ver. Cómo. Cómo. Realmente. Aquí. También. Se. Pasan. Las. Tools. Como. Que. Se. Pasan. Las. Tools. En. Dos. Puntos. Uno. Directamente. En. El. La. Language. Model. Para. Invocarlo. Con. Su. System. Prom. Y. El. Estado. De. Mensajes. Pero. Luego. También. Se. Lo. Tenemos. Que. Poner. Al. Al. Tool. Note. ¿No? Entonces. Definiendo. Tools. Acá. Está. La. De. Multiplicar. Pero. También. Vamos. A. Poner. La. De. Sumar. ¿Vale? Y. Pues. Generamos. Nuestro. Array. De. Tools. Tararán. Ya. Entonces. Tenemos. Las. Tools. Con. Sumar. Y. Multiplicar. Bien. Entonces. Acá. Cuando. Creamos. El. El. El. La. Language. Model. Que. Aquí. Podríamos. Tener. Un. Lío. Más. De. Performance. Y. Es. Obviamente. Cada. Es. Que. Se. Llama. Esta. Función. Está. Creando. La. Instancia. Yo. Creo. Que. Podríamos. Crear. Esa. Instancia. Antes. Aquí. Y. Luego. Simplemente. Vindiar. Las. Tools. Ahí. Yo. Creo. Que. Está. Bien. O. Lo. Podemos. Vindiar. Afuera. Y. Ya. Lo. Vindíamos. Y. Simplemente. Luego. Hacemos. La. Invocación. Acá. Tenemos. La. Language. Tenemos. El. System. Prone. Más. Los. Mensajes. Que. Vienen. Del. Historial. Y. Pues. Literalmente. Pues. Retornamos. Ese. Estado. Entonces. Hasta. Ahí. Vamos. Pues. Bien. Tenemos. A. Nuestro. Nodo. Que. Llama. A. La. Language. Model. Acá. Sí. Esto. Define. Los. Nodos. Ahora. Necesitamos. Ya. Construir. El. Grafo. Entonces. Acá. Tenemos. Este. Builder. Que. Aquí. Si. Me lo voy a copiar. Mucho. De. De. Este. De. Acá. En. Donde. Ya. Generamos. Nuestro. Digamos. Que. Ya. Generamos. Acá. El. Grafo. Entonces. Le decimos. Que. El. Estado. Es. Este. Que. Tenemos. Acá. Que. Es. My. Bar. Con. Un. Mandamos. La. Función. Del. Asistente. Que. Tiene. Un. System. Prompt. Que. Ya. Llama. Un. Language. Model. Que. Tiene. Un. Binding. De. Tools. Ok. Perfecto. Y. Pues. Lo. Tenemos. Ahí. ¿No? Ahora. Lo. Que. Nos. Faltaría. Es. Agregar. Otro. Nodo. Que. Es. El. Que. Tiene. Las. Tools. Este. Tools. Note. Es. Viene. De. Es. Red. De. Tools. Digamos. Que. Dos. Puntos. En. Los. Que. Enviamos. Las. Tools. Uno. Al. Digamos. Que. A. La. Language. Model. Y. Otro. A. Este. Tools. Note. Que. Por qué. Básicamente. Porque. De nuevo. Si. El. Tool. Note. Como. Que. No. Solo. Las. Va. Colocar. Al. A. Este. La. Language. Model. O. Este. Sistente. Sino. Que. Luego. En. Sistemas. De. Grafos. Más. Complejos. Pues. No. Solo. Como. Que. Lo. Conecta. A. Este. Nodo. Sino. Que. Lo. Puede. Conectar. Como. Como. Que. El. Sistema. Es. Consciente. A. Nivel. De. General. De. Las. Tools. Que. Puede. Utilizar. Bien. Entonces. Acá. Literalmente. Tenemos. El. Ese. Ese. Ad. Node. Y. Acá. Es. Donde. Viene. Algo. Muy. Interesante. Y. Es. El. Este. Que. Es. El. Tools. Condition. Tools. Condition. Al. Final. Hace. Algo. Muy. Muy. Interesante. Por. Detrás. Es. Algo. Como. El. El. Condicional. Edge. Que. Si. No. Has. Visto. El. Video. Del. Condicional. Edge. Te lo dejo por acá. Para que. Sepas. A. Que. Me. Estoy. Refiriendo. Pero. Básicamente. Habíamos. Visto. Que. Con. Un. Conditional. Edge. Vamos. A ver. Si. Lo. Tengo. Por acá. En. Los. Ejemplos. Creo. Que. Lo. Tengo. En. Este. Condicional. Un. Condicional. Edge. Es. Una. Forma. De. Decidir. Cuando. De. Acuerdo. Alguna. Lógica. Sea. Por. La. Language. Model. O. Sea. De. Forma. Programática. Pues. Ir. A. Un. Nodo. O. A. Otro. Sin. Embargo. Acá. Ya. Hay. Una. Tools. Condición. Que. Lo. Que. Hace. Lo. Siguiente. Lo. Que. Va. A. Hacer. Es. Cuando. El. Sepa. Que. Hay. No. Hay. Un. Content. O. Sea. Está. Vacío. Porque. Ya. Sabemos. Que. Cuando. El. La. Language. Model. Sabe. Que. Tiene. Tiene. Un. Stream. Vacío. Y. Además. De. Eso. Tiene. Como. Una. ID. Tiene. Ya. Mapeada. Las. Funciones. Y. Sabe. Que. Función. Es. La. Que. Tiene. Que. Ejecutar. Entonces. Cuando. Él. Sabe. Que. Pasa. Eso. Va. Y. Se. Devuelve. A. La. Language. Model. Y. Le. Manda. Y. Ejecuta. Realmente. Esa. Función. Y. Luego. Básicamente. Lo. Mantiene. En. Un. Ciclo. De. Conversación. Entonces. Es. Bastante. Interesante. Porque. Él. Ya. Como. Que. Ejecuta. La. Función. Y. Luego. La. Refina. Para. Darle. Una. Respuesta. Al. Usuario. Entonces. Lo. Único. Que. Tenemos. Es. Que. Agregar. Ese. Condicional. Edge. Como. Parte. De. De. Nuestro. Start. Entonces. Acá. Por ejemplo. El. Start. El. El. El. El. Primer. Edge. Básicamente. Es. Inicia. Se va. Al. Asistente. Luego. Del. Asistente. Que. Acá. Nos. Dicen. Un. Proquito. ¿No? Y. Básicamente. Él. Opera. Bueno. También. Hace. Algo. Interesante. Y. Es. Que. Toma. El. Historial. De. Mensajes. Y. Con. Base. Al. Último. Pues. Ve. Si. Realmente. Puede. O. Tiene. Que. Ir. A. Ejecutar. Una. Función. Y. Va. Y. La. Ejecuta. Entonces. Acá. Nos. Dicen. ¿No? Si. El. Último. Mensaje. O. El. Resultado. Del. Asistente. No. Es. Una. Tool. Call. Entonces. Básicamente. Va. Y. Finaliza. ¿No? Entonces. Dice. Ok. Simplemente. Envío. La. Respuesta. Como. En. Este. Caso. Que. Cuando. No. Tiene. Una. Cuando. No. Tiene. Que. Ejecutar. Una. Una. Función. Va. Y. Envía. La. Respuesta. Entonces. Acá. Dice. ¿No? Si. El. Último. Mensaje. Del. Asistente. No. Es. Una. Tool. Una. Tool. Code. Entonces. Va. Y. Finaliza. O sea. Envía. El. Mensaje. Pero. Si. Realmente. Hay que. Llamarlo. Literalmente. Va. Y. Lo. Enrutea. Y. En. Este. Como. Nodo. De. Tools. Va. Y. Hace. La. Ejecución. De. Esa. Función. Entonces. Vamos. A. Pues. A. A. Ver. Cómo. Funciona. Lo. Trabajar. Aquí. Como. En. Forma. Lineal. Para. Que. Lo. Podemos. Ver. Claro. Y. Ya. No. Acá. Te. Verán. Ahí. Está. Tools. Condition. Y. Ya. Y. Eso. Es. Acá. Tenemos. Ah. Nos toca agregar. Este. Nodo. Y. Creo. Que. Creo. Que. Acá. Finalmente. El. Nodo. De. Finalizar. No. Lo. Agregamos. Porque. Simplemente. El. Nodo. De. Finalizar. Depende. Si. Hay. Que. Llamar. O. No. Una. Tool. Básicamente. El. Que. Finaliza. Es. El. Tool. Condition. Si. Literalmente. Tiene. Que. Ir. A. Finalizarlo. Pues. Lo. Finaliza. Pero. Si. No. Pues. Va. A. Seguir. Como. En. Este. Ciclo. Con. El. Usuario. Entonces. Lo. Que. Hacemos. Es. Un. Edge. Es. Decir. Que. De. Tools. Puede. Redirigir. A. Hacerle. Asistente. Y. Listo. Obviamente. Básicamente. Acá. Lo. Que. Tenemos. Es. Esto. Para. Que. Uno. Lo. Entienda. Como. De. Forma. Gráfica. Nuestra. Asistente. Queda. Así. Inicia. Va. Nuestra. Asistente. No. Le. Escribimos. Hola. Como. Estás. Este. Hola. Como. Estás. Va. Y. Se. Ejecuta. Con. La. Language. Model. La. Language. Model. Responde. Y. Ella. Va. Y. Genera. La. Respuesta. Sin. Embargo. Le. Hace. Como. Un. Chequeo. Hacia. Las. Tools. Oiga. Necesito. Ir. A. Llamar. A. Una. Tool. A. No. No. Porque. Pues. El. Contenido. No. Tiene. Ninguna. Tool. De. Entonces. Él. Va. Y. Lo. Ejecuta. Le. Envía. La. Respuesta. Al. Asistente. El. Asistente. Ya. Refina. La. Respuesta. Y. Finaliza. Vamos. A ver. Si. Nos. Funciona. Y. Y. Pues. Ya. Que. Ya. Está. El. Grafo. Compilado. Entonces. Vamos. A. Ejecutarlo. Entonces. Vamos. A. Ya. Ir. A. Nuestro. Forma. De. Debugging. Vamos. A. Ir. A. Landgraf. Note. Y. Vamos. A. Y. Llamar. A. Nuestro. Agente. Que. Lo. Vamos. A. Llamar. Tool. Y. Pues. Literalmente. Nuestro. Nuestro. Archivo. Tool. Pipe. Y. El. Graph. Listo. Entonces. Ya. Tenemos. Varios. Digamos. Sistemas. De. Agentes. Acá. Que. Hemos. Estado. Haciendo. Nicobot. La. Language. Y. Hoy. El. De. Tool. Bien. Entonces. Pues. Veamos. Veamos. Si. Nos. Funciona. Si. Hay. Algún. Error. Y. Si. No. Pues. Lo. Vamos. A. Ir. Solucionando. Entonces. Vamos. A. Ahora. A. Poner. Esto. En. Marcha. Entonces. Voy. A. Correr. Este. Landgraf. Def. Que. Es. Lo. Que. Nos. Permite. Pues. Es. Ejecutar. Nuestro. Agente. En. Modo. De. Debugging. Entonces. Lo. Ejecuto. Landgraf. Def. Ahí. Al parecer. No. Hubo. Ningún. Error. Lo. Compilo. Bien. Vamos. A ver. Si. Nos. Deja. Acá. Tengo. Pues. El. Tool. No. Y. Acá. Parece. Que. No. Hay. Una. Línea. Entre. No. Sé. Si. Es. Un. Book. De. Una. Línea. Es. Un. Error. De. Taipo. No. No. Es. Error. De. Taipo. Yo. Creo. Que. Es. Un. Error. En. Alguna. Línea. Cita. Aquí. De. La. Interfaz. Que. Raro. Parece. Que. Fara. Un. Book. En. La. Interfaz. Pero. No. Me. Pinta. La. Línea. Entre. Star. Y. Assistant. Miremos. Si. Se. Es. Un. Error. Y. Escribamos. Hola. Como. Estás. Eh. Mi. Bueno. Ah. Si. Parece. Que. Es. Un. Error. De. La. Interfaz. Porque. Si. Realmente. Eh. Lo. Ejecuta. Eh. Listo. Mira. Fíjate. Que. Entonces. Dice. Mira. De. Start. Pasó. Al. Asistente. Y. El. Asistente. No. Tuvo. Ninguna. Tool. Que. Llamar. Entonces. Hola. Estoy. Estoy. Aquí. Para. Ayudarte. Con. Problemas. De. Matemáticas. En. Que. Puedo. Asistir. Te. Hoy. Este. Pron. Lo. Sacó. De. Nuestro. System. Pron. No. O sea. La. Respuesta. De. Por qué. Respondió. Así. Es. Porque. Le. Dijimos. Que. Esta. Gente. Era. Un. Experto. Matemáticas. Entonces. Ya. Dice. Yo. Soy. Un. Experto. En. Matemáticas. No. Entonces. Ok. Cuánto. Es. Uno. Por. Por. Dos. A ver. Y. Voy a ponerle. Por. No. Y. Voy a ponerle. Aquí. Uno. Y. Ejecutemos. Entonces. Vamos. A ver. Entonces. Va. Y. Aquí. Es. Esta. Es. Una. Cosa. Muy. Interesante. Que. Tiene. Pues. Que. Que. Nos. Deja. Ver. El. Sistema. De. Debugging. De. Landgraf. Y. Es. Que. Nos. Deja. Ver. Nos. Mapea. Como. De. Una. Forma. Gráfica. Básicamente. La. Respuesta. Que. Tenemos. Acá. Esta. Respuesta. Acá. Nos. Lo. Pone. Como. Una. Tablita. Para. Para. Verlo. Y. Eso. Me. Parece. Pues. El. Sistema. De. Debugging. Debuggear. Un. Sistema. De. Agentes. Es. Complejo. Porque. Son. Sistemas. Complejos. Y. Creo. Que. Landgraf. Tiene. Uno. De. Los. Mejores. Sistemas. De. Debugging. Y. Por eso. Me. Gusta. También. Como. Sistema. De. Agentes. Que. Me. Coloque. Aquí. Ah. Mira. El. Asistente. Lo. Que. Hizo. Fue. No. Responder. Un. Mensaje. Porque. No. Hay. Un. Mensaje. Que. Responder. Lo. Que. Respondió. Es. Que. Tiene. Que. Ir. A. Ejecutar. Una. Función. Y. La. Función. Me. La. Pinta. Me. Dice. Mira. Multiplicar. Y. El. Parámetro. Es. Uno. Y. Tal. Pues. Esto. Me. Ayuda. Mucho. A. Hacer. Debugging. De. Un. Sistema. De. Agentes. Luego. Yo. Sé. Que. Él. Fue. Y. Después. De. Que. La. Sistema. Que. La. Language. Model. Me. Dijo. Que. Que. Esta. Fue. La. Tool. Que. Escogió. Va. Al. Nodo. De. Tools. Por. Eso. Es. Tools. Y. Ya. Ejecuta. La. Función. Como. Que. Ya. Va. Y. La. Ejecuta. Si. Como. Que. El. Asistente. Lo. Que. Sabe. Que. Es. Un. Entero. Luego. Entonces. Dentro. De. Las. Tools. Básicamente. Que. Es. Como. Donde. Están. Todas. Las. Funciones. Como. Listas. Para. Ejecutar. Realmente. O sea. Ahí. Ya. Literalmente. Lo. Que. Hace. Es. Mandarle. La. Ejecución. O sea. Literalmente. Yo. Podría. Poner. Un. Print. Acá. O sea. Como. Un. Print. Y. Ese. Print. Me. Va. A. Salir. En. Mi. Sistema. De. Pues. En. Mi. Servidor. Porque. Literalmente. Está. Ejecutando. ¿No? Entonces. Coge. El. El. Toma. El. Parámetro. Del. Usuario. Va. Lo. Ejecuta. Lo. Multiplica. Está. Ejecutando. La. Función. Que. Es. Básicamente. Lo. Que. Hace. El. Nodo. De. Tools. O. Y. Acá. Está. La. Respuesta. O. Sea. Al. Final. Este. Es. El. Return. ¿No? Pues. Uno. Por. 1212. Es. 1212. Entonces. Él. Envía. Esa. Respuesta. Y. Como. Se. La. Vuelve. A. Enviar. Al. Asistente. El. Que. El. Asistente. Lo. Que. Hace. Es. Recibir. El. Mensaje. Pero. Acá. Ahí. Hay. Algo. Interesante. Si. Yo. Veo. Mi. Historial. De. Mensajes. Que. También. Lo. Puedo. Ver. Déjame. Ver. Si. Lo. Puedo. Debuggear. Por. Acá. View. State. Acá. Fíjense. Acá. Yo. También. Tengo. Mi. Sistema. Fíjense. Que. Acá. Yo. Puedo. Tener. Y. Lo. Puedo. Ver. En. Jason. Si. Si. Lo. Queremos. Ver. Pero. Tengo. El. Historial. Fíjate. Que. Por. Acá. Tengo. Hola. Cómo. Estás. Esto. Es. Mensaje. Del. Del. Del. Humano. Déjame. Lo. Corro. Un. Poquito. Más. Por. Acá. Ahí. Ahí. Acá. Entonces. Yo. Puedo. Ver. Acá. Esto. Es. Un. Mensaje. Del. De. Del. Humano. Tararán. Pero. Aquí. El. Hay. Cómo. Oye. Esta. Fue. La. Respuesta. De. Una. Tool. No. Que. La. Respuesta. Fue. Pues. La. Respuesta. De. La. Ejecución. De. La. Tool. Y. Él. Sabe. Cómo. Interpretar. La. Respuesta. De. Una. Tool. De. La. Ejecución. Y. Se. Lo. Vuelve. A. Mandar. Como. Contexto. A. El. Asistente. Y. Ya. Genera. Una. Respuesta. Bonita. Para. El. Usuario. No. Pues. Uno. Por. Doce. Por. Doce. Es. Igual. A. Doce. No. Entonces. Como. Que. Le. Devuelve. Eso. Al. Asistente. Deja. Que. La. Language. Model. Ya. Refine. La. Respuesta. O. Sea. Básicamente. La. Language. Model. Ya. Sabe. Que. La. Respuesta. Doce. Y. Le. Envía. Una. Respuesta. Bonita. Al. Asistente. Eso. Es. Muy. Interesante. Y. Es. La. Forma. En. Que. Podemos. Conectar. Estas. Funciones. Bien. Ahora. Hagamos. Una. Función. Un. Poquito. Más. Complicada. Una. Una. Función. Que. Queramos. Que. Como. Responda. Alguna. API. Que. Nos. Conectemos. A una. API. Literalmente. Y. Con. Conectarme. A esta. API. Es. La. Que. Se. Me. Ocurre. Ahorita. Obviamente. Ahí. Creo. Que. Mejor. Es. Pero. Ahorita. Solo. Se. Me. Viene. A la. Cabeza. Una. Una. Que. Siempre. Estiliza. O. No. Conectemos. A la. A la. A la. Fake. API. De. Platzi. En. La. Cual. Pues. Yo. Trabajo. En. Esta. Fake. API. Y. La. Mantengo. Y. Acá. Tenemos. Una. API. De. Productos. Entonces. Digámosle. Que. Dime. Cuál. Es. El. Producto. Más. Caro. Con. Base. A. La. API. O. Las. Categorías. Son. Más. Chiquitas. Porque. La. API. Son. Como. Unos. Cien. Productos. Categorías. Solo. Hay. Cinco. Entonces. Podemos. Ir. A. Este. Endpoint. Y. Decir. Dime. Las. Categorías. Que. Hay. En. El. E-commerce. Y. Pues. Debería. Listarme. Estas. Categorías. Ok. Ahorita. Hay. Treinta. Y. Ocho. Categorías. Vamos. A. Entonces. Vamos. A. Conectarnos. A. Esta. API. Listo. Entonces. Acá. Le. Voy. A. Decir. Get. Categorías. Bien. Fíjense. Que. Acá. No. Es. Una. No. Es. Una. No. Es. Una. Función. Que. Va. A. Recibir. Algún. Parámetro. Pero. Algo. Que. Si. Es. Muy. Bueno. Es. Que. Retorne. Siempre. Un. String. Si. Es. No. Es. Siempre. Bueno. Pero. Es. Lo. Recomendable. En. En. Al menos. En. En. El. Caso. Que. Voy. A. Hacer. Por qué. Porque. Yo. Le. Voy. A. Al final. La. Respuesta. Se. La. Voy. Volver. A. Enviar. A. La. Language. Model. Para. Que. La. Interprete. Entonces. Aquí. Lo. Que. Voy. A. Hacer. Es. Mandarle. Una. Lista. Literalmente. Categoría. Uno. Y. Le. Voy. A. Poner. Un. Poquito. Más. De. En. Vete. Categoría. Uno. Categoría. Dos. Le. Voy. A. Poner. Las. Categorías. Que. Están. Acá. Fíjense. Que. Ahorita. No. Me. Estoy. Conectando. Realmente. A. La. API. Estoy. Casi. Como. Emulando. ¿No? Que. Estas. Van. A. Hacer. Las. Respuestas. Pero. Luego. Pues. Simplemente. Llamamos. Al. Endpoint. Parseamos. Y. Lo. Respondemos. ¿No? Acá. ¿Qué. Tenemos? Tenemos. Un. String. Separado. Por. Comas. Muy. Interesante. Get. Categorías. Y. Vamos. A. Ponértelo. Acá. Creo. Que. Debería. Cambiarle. Un. Poco. El. Prompt. Porque. Al. Final. Ya. No. Sería. Un. Experto. Matemáticas. Pero. Probemos. Probemos. Eres. Un. Experto. Matemáticas. Y. Además. Es. Muy. Raro. Este. Parte. Y. Simplemente. Tienes. Acceso. A. Categorías. De. Productos. Listo. Ya. Listo. Entonces. Es. Una. Función. Que. Es. Get. Categorías. Retorno. A. Una. String. Claro. Es. Una. Lista. Y. Ya. ¿No? Entonces. Vamos. A. Ver. Qué. Pasa. Entonces. Vamos. A. Ver. Qué. Pasa. Por. Acá. Voy. A. Crear. Un. Nuevo. Hilo. Listo. Y. Voy. A. Decirle. Voy. A. Enviarle. Un. Hola. ¿No? Por. Ahora. Debería. Responderme. Sin. Ninguna. Tool. Hola. En. Que. Puedo. Ayudarte. Hoy. Perfecto. Ya. No. No. No. Hubo. Ninguna. Tool. Que. Llamar. Entonces. Simplemente. Me. Respondió. Listo. Entonces. Voy. A. Decirle. Cuánto. Es. Uno. Eh. Acá. Le. Reconoció. Parció. Los. Parámetros. Y. Me. Dijo. Ah. Mira. Pues. Acá. La. Tool. Respondió. Tres. Y. Luego. Esa. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. La. Dime. Las. Categorías. De. Los. Productos. Que. Tienes. Ah. Y. Vamos. A ver. Si. Reconoce. Que. Tiene que. Ir. A ejecutar. La. Función. Cat. Categories. Ahí. Está. Cat. Categories. Como. No. Tiene. Ninguna. Función. De. Entrada. Simplemente. No. Parció. Ninguna. Función. de entrada, aunque eso va siendo interesante porque yo le puedo decir dame todas las categorías que tengan más de 10 productos, entonces literalmente el 10 productos se vuelve una entrada y tu API debería poder filtrar, ahí si ya es problema de tu API, tu API debería tener un parámetro que diga el tamaño de los productos y en fin cosas que, o sea al final la language model lo que hace es parciar el parámetro pero fíjate que la función la ejecutó ahorita no tenemos ningún llamado a la REST API, simplemente devolvimos un string y ya pero esa es la magia la magia es que tenemos una función y aquí yo puedo hacer todo el código que se me dé la gana básicamente y aquí puedo conectarme a una API conectarme a una base de datos a un sensor esto es ya pues ya es libertad de lo que yo puedo hacer aquí en código, obviamente aquí estoy retornando un string sencillo algo separado por comas ejecutó esa función se la devolvió y el asistente respondió mira, las categorías de los productos y es más, hizo algo muy interesante que fue traducirlo porque sabe que como que todo mi historial está en español yo le podría decir que no pero igual aún así me parece un muy buen comportamiento el retorno está en inglés pero como sabe la language model que estamos conversando en español entonces y porque ya tenemos un historial de mensajes que es gracias a literalmente tener el historial de mensajes es gracias a esto y eso es gracias a Langrath ya tenemos un message stage que es el que coordina el historial y por eso él tiene acceso al historial y pues pues es la respuesta entonces dice las categorías de los productos que tengo son ropa electrónica y muebles entonces lo tradujo y esa tool la obtuvo listo entonces veamos si podemos hacer el request entonces hagamos el request o sea ya no sería simplemente retornar el string sino literalmente pues hacer la llamada a esa REST API nos toca procesar la información al final esto es un JSON acá tenemos un JSON y sólo necesitamos devolver el nombre esto ya es esto esto es si eres frontend o backend ya sabes llamar a una API esto es un JSON iterarlo mapearlo y sólo quedarte con el nombre para devolver un array de el array separado por comas entonces pues pues pues pues pues y déjame ver si Cursor me puede ayudar con eso engineer code for to get to retrieve the information no puedo retrieve, de ira of this endpoint entonces acá le digo tan eeeem y mmmmmmm pues necesito que luego lo una y me envía un array separado por comas and generate generate un string with names y y y y y y y y y y y y y y y Víctor de me시죠 me Mine homosexual sangman y manda de una guía util y acá dice ropas insta electrónica no sé qué roser es confiar en tecnología y books puntos de venta facturación digital vamos a ver qué pasa vamos a ver si funciona bien dónde está mi sistema de grafos acá listo vamos a crear otro hilo y empezamos hola cómo estás aquí hay que tratarlos bien hola estoy aquí para ayudarte con cualquier pregunta o problema que tengas especialmente si es sobre matemáticas o categorías de productos todavía nos falta mejorar mucho prompting o sea el prompting en general en que estamos haciendo acá es muy vago nos toca mejorar mucho nuestras técnicas de prompt luego vamos a hablar técnicas de prompt con herramientas de lunch en que también tienen para eso la mía y varias cositas por ahí pero nos deja ver cómo funciona quiero las categorías de los productos y ordena las vamos no sé vamos a ver si puede también hacer algo más que no le pedí ordenar aunque lo dije por cómo ordenarlas pero supo que las funciones de categorías y fijándose en los primeros dos en la siguiente sección vamos a ver cómo funciona así es que ya lo he hecho Fíjense, aquí, aquí, aquí, aquí, aquí, esta es una respuesta que viene directamente desde la API. Esta es la respuesta de la API. O sea, si yo hago un put, lo que sea, o sea, ejecuto y hay más categorías, ahí están. Literalmente ahí están. Me conecto a una red API, amplifico la información de mi agente, porque se está conectando, digamos, a mi e-commerce para obtener las categorías. Las mapeó, o sea, las dividió en un string separado por comas, se las devolvió al asistente. ¿Y qué hace el asistente o la language model con eso? Pues aquí tiene, ahora no sé cómo las ordenó, porque no, no, no sé, no sé, a ver, ¿qué orden hay acá? Quiero saber cómo las ordenó. ¿Qué? Books, ¿por qué puso books de primeras? Ah, creo que las ordenó por ABC, Darío. Sí, mira, B, C, Electronics, no porque la B está acá, Blush, no, no, no sé por cómo ordenó. No, no siguió tampoco el orden de la, del endpoint, ¿no? Del request, porque primero está Clothes, Electronics, Shoes, no sé qué utilizó para ordenar. A ver, aquí tienes la categoría ordenada alfabet, supuestamente es alfabéticamente, pero pues, pues Blush, te debería ir junto de Books, pero en fin, no sé. Si necesitas más información o ayuda con algo más, házmelo saber, ¿ok? Pero lo que acabamos de obtener es una respuesta en bluish. Real time de nuestra API. Hoy hablaremos de algo muy importante y es que ahora puedes conectar tu sistema de agentes a funciones, a tools, que se ejecutan directamente y tú controlas ese código. Pueden hacer una operación, pueden conectarse a una base de datos o incluso, como lo hicimos, llamar a una API para que en tiempo real tu sistema se conecte y se alimente de esa información. Y eso lo aprendes precisamente en este canal en donde estamos haciendo sistemas de agentes con Landgraf. De donde vamos aprendiendo a extender y hacer sistemas de agentes potentes utilizando este framework de orquestamiento. Así que no siendo más, recuerda suscribirte a este canal para seguir con más contenido respecto al tema. Nos vemos en el siguiente video.