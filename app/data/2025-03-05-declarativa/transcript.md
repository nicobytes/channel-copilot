 En este video vamos a ver dos formas de o estilos de programación que de pronto tú conoces o se llaman allá en la industria, que normalmente es programación hiperativa y declarativa. Los dos approaches tienen sus estilos, sus ventajas, sus desventajas, pero en este video vas a aprender a utilizar las ventajas de uno o el otro, al menos a identificar si estás haciendo programación declarativa o hiperativa, un spoiler alert, casi que en Angular se prefiere casi en general hacer programación declarativa, pero precisamente en este video vas a aprender el por qué, porque de pronto cuáles son las ventajas, desventajas, y para eso hoy traigo a un gran amigo en el cual nos va a explicar acerca de este tema. Así que no siendo más, traigamos al invitado a escena. Hola, hombre, ¿qué tal? ¿Cómo estás? Dime de qué nos vas a hablar hoy, de qué se trata la programación declarativa, hiperativa, qué es este cuento y por qué deberíamos ser importantes. ¿Qué es lo más importante para nosotros? Wow, son muchas preguntas. Bueno, hola a todos. Nada, hoy les voy a hablar un poco de programación declarativa e hiperativa, un poco de, tal vez, les voy a contar una historia, de hecho, de cómo yo me sumergí. Bueno, voy a hacer como un paralelismo, ¿sí? Que en esta historia de cómo más o menos yo me sumergí en estos conceptos, ¿no? Y nada, los vamos a, vamos a ver que probablemente, Nico mencionaba, ¿no? Que se prefiere tal vez hacer programación declarativa en Angular. Sin embargo, vamos a ver que probablemente estamos haciendo en muchos casos programación imperativa, sin darnos cuenta, porque es más o menos lo que nos han venido enseñando. Nada, aquí el título, ¿no? Programación declarativa e imperativa en Angular, son los temas que vamos a tocar hoy, ¿sí? Como dije hace un rato, mi nombre es Mauricio C. Torres, soy ingeniero software en Halasoft. Trabajo específicamente como técnica lead de un equipo de desarrollo front-end. Trabajamos por una empresa de Estados Unidos. Hacemos específicamente un antivirus. Nada, soy un apasionado de las comunidades. Soy coorganizador en Angular Bolivia y también en el GDG Cochabamba. Y me pueden encontrar en todas las redes como Combi Mauri. Bueno, para la charla del día de hoy vamos a hablar un poco de imperativo versus declarativo. Voy a hablar un poquito de lo que es el camino imperativo, pero voy a enfocarme sobre todo en lo que es el camino declarativo, ¿ok? Empecemos. ¿Qué es un paradigma? ¿Qué es un paradigma? Podríamos decir que un paradigma es una forma de conceptualizar y estructurar el código. Este es un concepto como que bien exprimido porque evidentemente podemos encontrar conceptos mucho más complejos sobre lo que es un paradigma. Pero siento que es una forma fácil tal vez de entenderlo. Y específicamente cuando hablamos de paradigma imperativo vamos a encontrar a muchos autores que se refieren a él como una receta. ¿Sí? Cuando escribimos código imperativo estamos escribiendo código que describe instrucciones que se dan paso a paso. Ya vamos a ver más adelante, justamente Nico me compartía un artículo hace poco donde se refutó un poco esta idea, pero vamos a ver que precisamente no hay como que algo consensuado respecto a sus conceptos. Pero nos vamos a quedar por el momento con este. ¿Sí? Y nada, el paradigma declarativo. ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? Agarrar y describir las cosas paso a paso como diríamos en el imperativo directamente pide qué es lo que quiere. ¿Sí? ¿Sí? Aquí se hace una analogía, ¿no? En el imperativo podemos pensar que es como una receta de cocina donde nosotros seguimos las instrucciones para al final obtener un resultado, ¿no? Y en el declarativo estaríamos solicitando el resultado de forma directa, ¿no? Y directamente nuestro plato de comida. por ejemplo. Se hace mucho esta comparativa, se dice que imperativo es un código que describe cómo se hacen las cosas, mientras que declarativo es código que te dice qué es lo que queremos directamente. Así que para poder entenderlo un poco mejor vamos a ver algunos ejemplos precisamente que se dan en industria relacionados a estos dos conceptos, y para eso vamos a ver un par de desafíos. Vamos a ver el primero, nos dice escribe una función llamada double que reciba un array de números y retorne un nuevo array con los números duplicados del array original. Entonces nuestra entrada es un array que tiene ciertos números y la salida va a ser otro array que tenga los números duplicados del array original, es eso básicamente. Esta probablemente sería la forma imperativa en la que lo podríamos escribir, tenemos aquí nuestra función, se llama double, recibe este array, lo itera y va agregando en un nuevo array los números multiplicados por 2, no tiene muchas ciencias, se entiende, están todos los pasos ahí bien definidos. Sin embargo, algo que sucede es que este es código que nos han enseñado a escribir para que lo entienda una máquina. Algo que a mí me parece muy interesante es que la gente que está escribiendo algo que a mí me parece muy interesante es que la gente que está escribiendo algo que a mí me parece muy se me hizo bien interesante cuando empecé a aprender programación es que te hablan mucho de la lógica de programación y de cómo tienes que cambiar un poquito tu mindset para poder empezar a programar. A muchas personas seguramente les ha sucedido que les ha costado mucho empezar a programar, sin embargo, cuando pudieron hacer ese clic, por así decirlo, ya se les volvió muchísimo más sencillo. Y esto es debido a que, por ejemplo, cuando yo estaba en la universidad, cuando yo estaba en la universidad, cuando yo estaba en la universidad, cuando yo estaba en la universidad, cuando yo estaba que cuando estamos empezando a programar, se nos enseña a cambiar un poco la forma en la que pensamos, ¿no? ¿Para qué? Para poder dar instrucciones de forma muy específica a una máquina, ¿no? Yo recuerdo que cuando estaba en la introducción a la programación, ¿no? Y nos decían, vamos a hacer un algoritmo para ponernos una chompa, ¿no? Y se ponía la docente delante de todos y uno tenía que dictarle su algoritmo. Y si no eras demasiado inteligente, ¿no? Y si no eras demasiado inteligente, si no eras demasiado específico respecto a las instrucciones que le estabas dando, de repente no se colocaba bien la chompa, ¿no? Agarraba y, qué sé yo, terminaba el abrigo en el piso, ¿no? Y te daban a entender que básicamente lo estabas haciendo mal, ¿no? Eventualmente hacías clic y empezabas a programar dando instrucciones muy específicas, ¿no? Y como les digo, esto es como lo haría una máquina, ¿no? Por eso aquí tenemos como que ejemplificado, que esto sería algo que entendería tal vez un gatito robot, ¿ya? Es como que la analogía que quiero hacer. Sin embargo, ¿ya? Yo les decía que cuando programamos de forma declarativa, nosotros damos la instrucción directamente de qué es lo que queremos, ¿ya? Un ejemplo de esto probablemente sería hacer el ejercicio de esta manera. Aquí el resultado es el mismo. Sin embargo, estamos diciendo directamente, ¿qué es lo que queremos? Queremos, ¿no? Que se mapee este array y se devuelvan los números duplicados, ¿no? En un nuevo array. Algo interesante, ¿sí? La programación declarativa es que se asemeja un poco más a cómo haríamos nosotros las cosas, ¿no? Si tú te vas, por ejemplo, a un restaurante y quieres comida, no te metes a la cocina y la preparas tú, ¿no? Directamente agarras y haces una solicitud y le dices qué es lo que quieres, ¿no? Y por detrás, ¿sí? Se hacen ciertas cosas, tu comida se prepara y eventualmente la recibes. ¿Ya? Podríamos decir entonces que esto es algo que entendería ya no un gatito robot, sino un gatito de verdad, ¿no? Bueno, tal vez no un gatito de verdad, un gatito de verdad probablemente no te entienda, pero sí una persona, ¿no? Es como se comunicaría una persona realmente, ¿ya? Tomando esto en cuenta, ¿sí? Vamos a otro ejercicio. Nos dice, escribe una función llamada add que reciba un array de números y retorne el resultado de sumar todos estos números. La forma imperativa. La forma imperativa probablemente sería esta, ¿sí? Recibimos este array, ¿no? Tenemos nuestro resultado que empieza en cero, iteramos el array, ¿sí? Vamos sumando los números que están dentro del array, los agregamos a nuestro resultado, al final devolvemos ese resultado. Y como yo les decía, estas serían las instrucciones que entendería un gatito robot, ¿sí? Mientras que si lo escribimos esto de forma declarativa, podríamos agarrar y sacar provecho precisamente. Llegamos a la conclusión de que... Imperativo probablemente es como le hablarías a una máquina, mientras que declarativo se asemeja más a como le hablarías aquí a... No sé, a Jesús. Para poder ejemplificar esto, les voy a contar una historia. Les hablaba ya de esto al inicio, ¿sí? Pero antes quiero hacerles un par de advertencias. La primera advertencia es que las definiciones que están por verse dependen del contexto. Nos vamos a poner dentro del contexto de que estamos programando, ¿no? Y la segunda es que las definiciones que están por verse dependen del contexto. Entonces, vamos a poner aquí, ¿sí? Que estamos usando TypeScript, que estamos usando Arix.js, ¿no? Y este tipo de herramientas. Aparte de que yo les decía, ¿no? Que los autores realmente no tienen un consenso respecto a estrictamente qué es código imperativo y qué es código declarativo. Así que al inicio de cada ejercicio vamos a poner algunas reglas, ¿sí? Nosotros le vamos a poner, dar como que un contexto, ¿ya? Y la advertencia... Advertencia número dos es que en esta charla no se busca señalar que un paradigma es mejor que el otro. Si bien, bueno, Nico lo comentaba y igual lo repetía, ¿no? Es que vamos a preferir usar un paradigma declarativo. Sin embargo, eso no quiere decir que uno sea mejor que el otro. Les voy a contar esta historia, que es una historia que hice... La hice con Gemini, ¿sí? Que se llama el camino declarativo de Lumio, la llama programadora. ¿Ya? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? ¿Qué es? código imperativo, estamos dando instrucciones paso a paso se hace una gestión manual del estado y hay una mayor verbosidad en el código este último un poco es subjetivo pero en estos ejemplos va a ser así sigamos con la historia Lumio vio su board tomó el primer ticket, que era construir una lista de eventos y lo inició definiendo paso a paso como debía funcionar entonces, ayudemos a Lumio vamos a empezar creándonos un componente del events component vamos a crear una propiedad que va a ser el tipo array detect event y bueno, lo vamos a inicializar para que no nos riña el compiler de Angular lo siguiente que vamos a hacer es que vamos a asumir que ya tenemos un servicio de eventos que se va a encargar de recuperar los eventos filtrarlos, hacer búsquedas paginar temas, todo el tema de eventos alrededor de los eventos y lo vamos a inyectar entonces tenemos nuestras dos propiedades perfecto lo siguiente es que cuando nosotros ingresemos a este componente probablemente se debería inicializar podríamos es decir, el array eventos se debería inicializar, debería llenarse los datos podríamos tal vez pensar en agregarlo en un hook en un lifecycle hook, en este caso tal vez en el engine init ok y probablemente haríamos algo así y estoy bastante convencido de que muchos cuando empezamos a programar en Angular de hecho, hacíamos esto que incluso puede ser que lo sigamos haciendo que en un hook agarramos nos suscribimos al getEvents del eventService asumimos que nos está volviendo todos los eventos el valor que nos devuelva se lo asignamos a la propiedad de la clase entonces entonces esto funciona por buenas prácticas algo que también tendríamos que hacer es asegurarnos de que esta suscripción en algún momento muera para evitar el tema de memory leaks para eso lo que podríamos hacer es crearnos un subject que sea un subscribe y hacer uso del operador takeUntil para que cuando este subject emita algún valor se muera la suscripción y lo siguiente es que en el onDestroy nos aseguramos de que no hay que disparar como tal este subject para completar la suscripción ya aprovechando que estamos viendo esto vamos a ver que podemos mejorar un poco esto de aquí utilizando las últimas versiones de Angular podríamos en vez de utilizar el operador takeUntil utilizar otro operador que se llama takeUntilDestroy sin embargo vamos a ver que si hacemos esto nuestra emisión de la suscripción va a empezar a llorar ¿por qué? porque eso va a tirar un error ¿ok? para poder utilizar el takeUntilDestroy tenemos que estar dentro de una referencia bueno, vamos a asumir que tenemos un convivent card donde se van a mostrar nuestros eventos información de cada evento y así se vería nuestro componente esto en teoría debería funcionar ¿sí? y nada Lumio va a estar contento su código funciona sin embargo lo que sucede es que en la vida real empezamos a recibir más requerimientos y de repente este código que hasta aquí se ve bien de repente puede volverse más verboso y se pueden dar ciertas complicaciones ¿ok? entonces nos dicen empezó a recibir más requerimientos ¿no? y bueno, vamos a ver algunos de los requerimientos extra que recibió Lumio ¿ya? uno es agregar filtros a la lista de eventos vamos a asumir que tenemos nuestra lista de eventos queremos poder filtrar qué sé yo por fecha, por ciudad ¿no? alguna cosa así lo que probablemente podríamos hacer es crearnos una función para filtrar los eventos en este caso aquí ya estoy directamente creando esa función filterEvents que va a recibir un filtro vamos a asumir que es un string ¿ya? y vamos a asumir igual que no es cierto que es un string, ¿ok? igual que nuestra función getEvents del eventService igual puede recibir filtros ¿no? y ya sabe manejarse y nada esto es muy parecido a lo anterior para y se parece mucho ¿no? sin embargo vamos a anotar aquí algo interesante ¿ya? y es que tanto en el onInit como en el filterEvents estamos asignándole un valor a la propiedad events ¿sí? y esto ya puede llegar a ser un valor ¿no? un problema podríamos decir ¿no? ¿qué pasa si agregamos paginación? ¿no? ¿qué pasa por ejemplo si agregamos sorting? ¿ya? lo que va a suceder ¿no? es que para cada una de estas probablemente terminamos agregando otra función que sea sortEvents otra que sea no sé nextPage para los events y para cada una de estas probablemente vamos a terminar resignando el valor de eventos ¿ok? entonces nada volvamos a la historia la app crecía en complejidad Andina que es otra llamita que es la mentora del umio notó su frustración y decidió guiarlo en el camino declarativo hablamos un poco del camino declarativo vamos a definir características decíamos que la programación declarativa se enfoca en el qué y no tanto en el cómo se consigue una gestión del estado abstraída es entre comillas conciso y más legible jaja y vamos a agregar esta característica que creo que es muy importante y justamente cuando veamos un poco de la discusión que hay entre autores respecto a qué es programación imperativa y declarativa sobre todo cuando aplicamos en Angular vamos a ver que probablemente en esta última si están de acuerdo y es que las propiedades no se resignan ¿ok? veamos Andina dio una charla ¿no? en la que decía debes enfocarte en el qué ¿en qué quieres? que haga tu aplicación ¿ok? y dejar que Angular sea a cargo del resto ¿ya? Lumi decidió probar este estilo declarativo empezó a usar el PyPasync los observados de RxJs y nada vamos a ver cómo está el código vamos a volver a hacer este componente pero tratando de seguir un paradigma un poco más declarativo ¿ok? vamos a empezar esta vez inyectando el servicio de eventos lo siguiente que vamos a hacer es que vamos a definir la propiedad de events pero la misma ya no va a ser un un array de eventos directamente sino que por la esta anotación nos damos cuenta que esto es un observable ¿no? y es la ventaja precisamente de utilizar RxJs y directamente le estamos diciendo que events es lo que sea que me devuelva la función que de events del servicio de eventos ¿ok? si se dan cuenta ¿no? habíamos hablado de que hay una cuarta característica que es que las propiedades no se resignan ¿ya? para tratar de reforzar esta idea nos vamos a asegurar de que nuestras propiedades sean read-only ¿ya? con esto lo que vamos a hacer es que cuando alguien venga y vea el código va a tener cierta certeza de que esta propiedad de event service por ejemplo es lo que sea que ha dado la inyección del event service lo propio con events que events es lo que sea que ha dado el servicio de eventos al llamar a la función getEvents y que esto no se modifica más adelante en el código no hay una reasignación del valor de esta propiedad ¿ya? volvemos a hacer la iteración de nuestros eventos ya que hay algo interesante ¿no? al iterar como tal un observable tenemos que pasarle el pipe async esto nos ayuda a evitar hacer una suscripción manual directamente desde el componente ¿ya? y como tal eso es ¿no? nuestro componente ahora es mucho más pequeño ¿sí? y se sigue entendiendo ahí entra la característica que probablemente el código es medio verboso ¿no? cuando es declarativo ¿qué pasa si agregamos filtros? lo que podemos hacer si esto es solamente una idea de las muchas formas en las que podríamos hacer esto es crearnos por ejemplo una propiedad filter que sea igual a un subject específicamente un behavior subject donde al inicio quizá el filtro sea un array vacío ¿no? esto ya nuestro servicio de eventos lo va a entender y vamos a crear un centro de eventos un sentido de dependencia ¿ok? entre eventos y el filtro para crear ese servicio ese sentido de dependencia nos vamos a apoyar en en un operador en este caso en el operador switch map para poder este básicamente cada vez que nuestro subject del filtro dispara un nuevo valor se actualice lo que es la lista de eventos ¿ok? utilizando justamente este operador y nada en sí como tal la lista de eventos seguiría igual probablemente deberíamos tener igual un componente para lo que es el filtro que se encargaría de disparar un nuevo valor de una u otra forma en este caso lo hace de esta manera esto podríamos argumentar que es algo imperativo pero vamos a ver al final igual de que siempre detrás del código declarativo hay algo de código imperativo además de que probablemente nuestras soluciones nunca van a poder ser 100% declarativos ¿ok? ¿qué pasa si queremos agregar paginación? ¿qué pasa si queremos agregar sorting? nada agregamos igual un par de subjects probablemente para eso ¿sí? y igual creamos un sentido de dependencia ¿no? con lo que es events lo podríamos hacer utilizando por ejemplo el operador combine latest ¿no? donde agarramos y hay una dependencia entre estos tres en el rato que cualquiera de estos dispara un nuevo valor se recalcula lo que es la lista de eventos ¿no? el observable y básicamente nuestro template es solamente agregar los componentes necesarios para poder hacer cambios ¿no? tanto en el sorting como en la paginación ¿sí? y esta es básicamente eso si se fijan el código se reduce bastante no estamos en ningún momento resignando lo que es el valor de eventos ni el valor de ninguna de nuestras otras propiedades ¿sí? podemos saber que es event solo viendo esta propiedad ¿no? y como está declarada y no tenemos que irnos a ningún lugar del código para poder este ¿no? sacar conclusiones respecto a esto algo importante y esto es algo que ya les mencioné es que muchas si no es que todas las APIs declarativas tienen algún tipo de implementación subyacente imperativa ¿no? porque por detrás probablemente ¿no? estos operadores ¿sí? si los examinamos a fondo seguramente tienen implementación que es imperativa en el fondo ¿no? lo importante al hacer código declarativo es saber apoyarnos en lo que es el lenguaje el framework, la teoría que estemos utilizando para poder decirles el qué es lo que queremos y que ya ellos estas herramientas se encarguen de poder devolvernos eso que le estamos pidiendo entonces ya como para concluir un poco la historia de Lumio vemos que al enfocarse en qué quería Lumio vio que Angular se hacía a cargo del cómo ¿no? sin necesidad de manejar cada paso manualmente al inicio Lumio sentía que el paradigma declarativo era raro además que le tomó tiempo el aprender nuevas herramientas como los operadores de RxJS pero cuanto más lo usaba más sentía que esta era la forma más natural y simple de escribir aplicaciones nada como conclusión la app de eventos de Lumio fue un éxito Lumio siguió su camino en la comunidad ¿ya? y de hecho me gustaría que aprovechar este espacio para invitarlos que si no son parte de alguna comunidad de programación lo hagan porque es es algo que te ayuda a conectar ¿no? con un montón de personas que te dan ideas que te ayudan a crecer ¿no? en tu camino profesional o incluso puedes conseguir amigos de alguna forma yo pude conectar así de hecho con Nico fue como lo conocí y nada Lumio les da las gracias sin embargo jeje yo aún no termino como tal la idea de de preparar esta charla en su momento vino dada debido a lo que aquel año pasado junto con el GDG Coach Abamba hicimos un evento llamado bueno estuvimos en la organización del evento Dead Fest aquí en mi ciudad y quisimos hacer como tal una aplicación para manejar lo que son los eventos esta es como tal la aplicación estamos empezando justamente a usarla igual en más eventos que venimos realizando y por eso es que la historia de Lumio es sobre hacer una aplicación de eventos y demás y un pequeño demo ¿no? aquí tenemos nuestra lista de eventos aquí ¿no? cuando tú quieres agarrar y registrarte para un evento de Angular Bolivia puedes venir aquí y hacerlo jeje ajá ahí vamos a ... ... y como tal la aplicación se encarga de hacer tus registros, se encarga de bueno todo este tipo de cositas ¿no? y ... esta aplicación en el momento en que en que se desarrolló tratamos de que fuera lo más declarativa posible ¿si? sin embargo algo que quiero aprovechar en mostrarles es que a pesar de que me enfoque en seguir un enfoque declarativo van a notar que yo no uso en ningún momento el Pypasing en los templates a pesar de que en el ejemplo que veíamos en los diapos sí o sí para evitar las suscripciones manuales estaba usando el Pypasing esta aplicación ni siquiera tuve necesidad de hacer eso ¿no? aquí estoy haciendo una búsqueda en ningún momento estoy utilizando el Pypasing y ahorita vamos a ver un poco el porqué ¿no? vamos a ver un último desafío que es el agregar signals a lo que es nuestra aplicación de eventos ... ... ... una forma de ... ... ... ... ... ... les voy a mostrar algún componente y van a ver que estoy utilizando signals ¿no? en vez de agarrar y usar el Pypasing estoy utilizando signals ... lo que hago ¿no? es que este EventService que me devuelve mis eventos ... signos y directamente utilizarlos en el template este probablemente es el lugar hacia donde nos vamos dirigiendo de hecho justamente veía una publicación de nicos y no estoy mal hoy en estos días en la que va a haber una nueva implementación incluso mediante la cual ya no vamos a necesitar utilizar el htp client no para poder hacer este tipo de cosas sino que va a haber una alternativa directamente utilizando signos y nada sí esto va a ser que el uso de alexia y es se vuelve opcional en el futuro pero para quienes aún decían seguir utilizándolo no se integra mejor que nunca en nuestro flujo de trabajo aquí está el mismo ejemplo así si queremos agarrar y agregar signos lo único que tenemos que hacer es utilizar el o la ley paitú signal de la libre interoperabilidad de alexia ya te pasa un suelo inicial y estamos básicamente hechos aquí dejamos de utilizar el paypal zinc y directamente agarramos invocamos no lo que es nuestro signal para que nos dé el valor perfecto algunas consideraciones que me gustaría que podamos ver antes de terminar y quiero hacer mucho énfasis en esto ya lo hice pero quiero repetir lo es que los autores aún no se ponen de acuerdo sobre estos conceptos un ejemplo es para mí como que las personas de las que más aprendí respecto a este este paradigma es joshua martino quien habla tiene una serie de vídeos donde habla justamente lo que es el patrón declaro de gol paradigma declarativo y trae ejemplos te habla justamente de este concepto de no reasignar sin embargo él igual se rige en el concepto de toda la vida por así decirlo, que se maneja donde se dice que el imperativo habla del cómo mientras que el declarativo habla del qué sin embargo aquí está el tweet justamente que se me hizo muy interesante este es un thread que pueden encontrar en Twitter de Mike Pearson que es autor de una librería muy relevante de hecho para hacer state management en lo que es Angular donde él justamente te dice que el código imperativo no son instrucciones paso a paso y tampoco es el qué versus el cómo pero yo leyendo todo el hilo hay una cosa con la que me quedé y es que él justamente finaliza todo este thread diciéndote qué es en sí imperativo para él que básicamente el código imperativo se da cuando cambias algo que ya está declarado en otro lugar básicamente es eso y si recuerdan cuando iniciamos poniendo en contexto lo que es la programación declarativa pusimos un cuarto punto que era que no vamos a reasignar los valores de nuestras propiedades y este concepto de no reasignar los valores de nuestras propiedades es algo que igual comparte Joshua Moroney de hecho tiene muchos videos donde agarra y te dice por ejemplo aquí el primero te dice never change things nunca cambies las cosas las cosas tienen que declarar y la gente debería poder ver eso y saber directo en la declaración a qué estás haciendo referencia y aquí tiene otro video que dice justamente the secret to declarative change without reassigning donde justamente igual refuerza este concepto de declaración y dice que no se puede cambiar las cosas sin reasignar las cosas es este concepto de no agarrar y reasignar los valores de nuestras propiedades a pesar de que ambos no están de acuerdo en este de qué es imperativo y declarativo y en esta batalla del step by step o el qué versus el cómo si hay algo en lo que están de acuerdo que es en este concepto en el que decimos específicamente en angular tal vez que no queremos hacer reasignación del valor de nuestras propiedades y nada ya estoy terminando algunas referencias respecto a la declaración respecto a todo lo que les he mostrado es bueno ya hablé de Joshua Moroney pero otro pilar para mí respecto a programación en angular es Deborah Curata es una divulgadora que igual es muy buena y eso es todo amigos muchas gracias ya me pueden encontrar en todos lados como con mi amor y éxito sería de esta forma aprendiste cómo implementar programación declarativa y declarativa y tienes ejemplos muy explícitos en angular de cómo llevarse a la declaración y cómo llevar a cabo este tipo de paradigma recuerda que uno no es mejor que el otro así que simplemente tienes que saber cómo utilizar cada uno aunque normalmente es preferible en angular utilizar programación declarativa así que no siendo más recuerda suscribirte a este canal puedes encontrar muchos más vídeos y contenido acerca de inteligencia artificial y angular así que suscríbete nos vemos en la próxima