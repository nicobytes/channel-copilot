 Angular sigue lanzando algunas reactivas primitivas que ayudan a apropiarnos de todo el modelo nuevo de reactividad basado en Signals y ahora tienen el Resource, el RxResource, que básicamente es una forma de manejar asincronismo dentro de un modelo de reactividad basado en Signals. Si bien los Signals se pueden declarar como de forma directa, por ejemplo, yo declaro un Signal de un valor o declaro un Computed Signal o un LinkedIn Signal o como todos estos artefactos, o por ejemplo, utilizo un ToSignal para convertir un Observable en Signal, todo eso se puede hacer, pero normalmente todo eso es como declarativo y directo, como que un Computed tiene un valor por defecto, un ToSignal, por ejemplo, podríamos decir que tiene un valor por definición, pero ¿qué pasa con lo que es asíncrono? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? ¿Qué pasa con lo que yo tengo que esperar? Bien, sí, claro. Bueno, entonces yo tengo que dar M benchmark por si hay alguna pregunta. ¿Qué pasa con uno de mis datos? Bueno, él es F entender. En este caso, ¿qué opción le pondría? Log ín micrófono. Sí. ¿<|nl|> decir que el valor of tao, que no nos queda data per se, es verdadero? Pues el valor de algo. Sí. O sea, este萬 es tan valioso como el valor de algo, que la verdadera autonomía que tendremos aận providedan, o sea, la fórmula aroundner más o menos real, ¿verdad? Sí. se maneja una máquina de estado, por ejemplo, normalmente uno coloca, esto puede ser un string y el string entonces puede ser pasar por varios estados, uno es el estado inicial, otro es realmente si salió en success, lo otro si salió en error, lo otro si está realmente loading, entonces a veces el estado de loading se queda muy corto, entonces lo que se hace es una máquina de estado con como los estados por los que pasaría un request, normalmente de nuevo son como 4 estados por defecto o 5, depende de cómo lo quieras configurar, pero en fin, creaste dos variables basadas en signals para manejar el estado y si yo te dijera que este componente tiene otro, tiene otra lista, normalmente pues tú me dirías, bueno, divide en un componente, pero puede haber que en la misma componente tú tengas otro, otro estado de loading de otra cosa que estás también cargando, entonces ya tienes dos loadings de dos elementos en particular, por ejemplo, si yo te dijera que acá tenemos que también traer las que categorías, ahora tendrías que hacer loading categories y así te llenas como de estados, microestados chiquitos y esto si bien funciona, pues vamos a ver precisamente cómo el resource nos ayuda a afrontar todo este reto sin como mayor dificultad y utilizando programación muy declarativa y basada en signals, entonces lo primero es que si yo quisiera por ejemplo, tener un poquito más de código o ser un poco más declarativo y por ejemplo ya no utilizar el engine init o el syscon, describe para obtener toda la data, una forma podría ser pues products pasarlo a tus signals, ¿verdad? Entonces por ejemplo, yo podría hacer algo como esto, products, tengo normalmente lo que es un observable, lo colocamos como signo pesos al final y podría directamente traerme el get products de service, que eso por si es un observable y estos son los products, ¿verdad? Entonces en vez de declarar acá un to signal en, digo un signal directo de esta manera, lo que podría hacer es un to signal, convertirlo directamente a signal, y entonces pues le digo, hey mira, necesito que conviertas este observable en signal, entonces hago products y le digo que tenga un init value, o sea en el caso que no venga nada, entonces lo ponemos en, pues en un array en vacío, si bien esto funciona y funciona bien, es decir, aquí, y ya no tendríamos que hacer esta parte, voy a comentar este pedazo de acá, acá, este pedazo de acá lo voy a comentar, ahorita les digo por qué, y listo, entonces acá por ejemplo, vamos a ver si todo va bien, ahí está, tenemos la lista, pero fíjate que hay algo que hace el to signal, y es que una vez que ya obtengo el valor, acá ya no tuve que utilizar pues como, es más, aquí ya no habría que utilizar el ng on init, porque en automático el to signal cuando ve que él puede, pues que ya la interfaz está lista, como que se lanza sin problema, entonces me ahorro como el ng on init, y como pensar en el ciclo de vida de Angular, porque ya por definición ya lo hacen automático, sin embargo si pierdo características, fíjate que products por ser to signal, ya no le puedo hacer un set, ya es imposible hacerle un set a ese signal, y cómo le agreguía un reload, si ya, si ya, la petición ya estuvo, básicamente en to signal lo que hace es, lo que estaba ahí en ese observable, lo devuelve y ya, no hay mucha manera, pues se puede, haciendo como un poquito de hacking, pero se podría, pero no hay como una forma como directa de hacerle un reload, tendríamos que hacer como un observable para enviarle una señal, y entonces que vuelva a hacer el fetching, etcétera, como que las cosas como sencillas, como hacer un set, o como simplemente hacer un reload, se vuelven complejas, por utilizar signals, y la gracia es que no, la gracia es que sea fácil usar signals, entonces precisamente ahora, es donde introducen el resource, el resource hace lo siguiente, entonces, de por sí, muchas de estas cosas, que estaba haciendo acá, se van a poner casi en una sola línea de código, y casi que te podría decir que, puedo hacer todo esto que estaba haciendo, en una sola, bueno en tres líneas de código, ¿cómo lo haríamos?, entonces, ¿cómo lo haríamos?, entonces, recuerden, todo el proceso, hacíamos un fetching, queremos que todo sea signals, intentamos que con tu signal, lo podríamos cambiar, pero al final tiene unas limitantes, no puedo hacer set, bueno, tiene como varias cosas ahí, vamos a ver cómo lo logramos, entonces, voy a comentar todo esto, sí, lo voy a borrar todo, y ahora voy a crear lo llamado el product resource, lo voy a crear RC, ¿bien?, entonces, ¿de qué trata esto?, este resource, se hizo precisamente para toda la parte que se llama el resource, ¿bien?, entonces, ¿de qué trata esto?, este resource, es asíncrona, y voy a utilizar directamente el RX resource, y vamos a saber por qué, entonces, acá, el RX resource, lo que tiene es un loader, y en el loader, yo le puedo tener un call function, y ese call function, yo lo puedo conectar a un servicio, que me devuelva un observable, entonces, por ejemplo, yo sé que get products, me devuelve un observable, y pues, lo devuelvo, perfecto, entonces, listo, eso es todo, literalmente, eso es todo, fueron tres líneas de código, y ahora, voy a crear un service, y voy a crear un service, luego, literalmente, product resource, ¿cómo estas tres líneas de código me suplantan toda la lógica que yo tenía?, hacen un reset, obtener los productos, tener el estado de loading, etc., todo ya viene solucionado en el resource, por ejemplo, entonces, si yo literalmente quiero hacer un reset, y digamos que voy a escribir la función reset, entonces, yo puedo hacer, ir al RS, hacer un set, y literalmente, sí puedo hacer un reset, y voy a crear un service, y ahora, voy a hacer un set, y luego, pondré a ciro, es un setup, voy a crear un setup, y luego, pondré a ciro, y luego, pondré a ciro, y luego, pondré a ciro, podría pasarle un Arby en vacío y no hay ningún problema. Entonces, primer reto, puedo literalmente limpiar como los valores de ese fashion, de esa data que yo había obtenido de forma síncrona. Entonces, check por ahí. Ok, ¿cómo hago el reload? Vamos a ver, yo tenía una función que se llamaba getProducts. Vamos a ver qué sería getProducts. GetProducts sería algo tan sencillo como products. Y literalmente hay una función llamada reload. Y ya, él sabe que tiene que, como es un resource y ya tiene un loader que es este, sabemos que el reload va a hacer esa recarga. Ok, ¿qué pasa con los estados como loading y como products? Pues ahora dentro de products, acá, products. Hay algo que es el value. Value, value. Él va a obtener, una vez obtenga el fashion, va a guardar como en uno de sus estados el valor que obtuvo. Y el loading es parte de ese estado. Entonces, yo puedo hacer productResource, punto. Y literalmente hay un sign-out que me dice si la petición está en estado de carga. It's loading. Entonces, literalmente acá ya tengo todo, todo lo que yo tenía ahorita como de forma un poco manual. Lo había intentado hacer con tu sign-out, pero tu sign-out no me da el set. Entonces, tendría que seguir usando el envío en internet, el punto subscribe. Pues no, ahora aquí el R que es resource. Me permite hacerlo de forma como directa. Y estas funciones, digamos que podrían ser para ser más precisos. Pero yo fácilmente, que sería de pronto una mala práctica, pero yo podría hacer products.set directamente aquí desde dentro de la función, que no es la mejor práctica y debería acá llamarlo. Ahí. Y también podría llamar a product reload. Y literalmente estoy llamando a esas funciones. De nuevo. Yo creo que igual. Sigue funcionando mejor tener como esa función para de pronto reusar. Pero sabemos que podría yo enviarle el resource. Y no es solo eso. Si yo miro cuál es el estado de un resource, puedo saber cuándo dio error. Que si lo fijamos bien, así como yo había tenido el estado de loading, también debería saber el estado de error. Entonces, él ya me lo da. Entonces, ¿qué otros estados tiene? Miremos qué otros estados tiene o qué cosas más tiene. Digamos, si yo hago this. Product. Acá tengo. Bueno, si tiene un valor, si tuvo un error. El status. Y el status de por sí es un resource status. Es decir, déjame aquí vemos cuál es el typing específico. El resource status. Resource status es este. Literalmente es esa máquina de estados que te estaba comentando. Ideal, que es básicamente el estado inicial. Si es error es uno. Si es loading es dos. Si es reloading es tres. Si es resolve es cuatro. Si es local es tres. Etcétera. Entonces, él me da una máquina de estado. Ya por definición que era muy común que nosotros lo hiciéramos manualmente para manejar el estado del fashion. Pero aquí con RxResource, literal, ya tenemos esto. Ya tenemos que realmente yo podría reutilizar mis servicios. Que si te fijas bien, mi servicio maneja o retorna un observable. Al final, aquí le estoy haciendo fashion a una API. Pero pues le puse aquí el GetProducts. Ahora, este Rx es porque es la interoperabilidad con RxJS. Es decir, si nosotros queremos conectarlo a un servicio que maneja observables. Pero de nuevo, nosotros ya también estamos como en la fase en la que RxJS podría ser opcional dentro de los proyectos. Entonces, podría tener una función que sea una promesa. Hagamos una promesa. Es decir, hagamos una promise. No utilizaríamos el HTTP client. Ni utilizaríamos un observable, sino una promesa. Una promise que al final es lo que muchos al final de pronto no entendían de lo que es un observable. ¿Por qué Angular no utiliza una promise? Si es lo que se maneja, no sé, en React, en Vue, en cualquier lado. Es como hacer un fashion se hace con la función fetch del navegador o con Axios. ¿Por qué utilizar HTTP client? Si bien en Angular no se utiliza una promesa. O los que ya estábamos un poco acostumbrados a Angular. Sabemos algunas de las beneficios de utilizar RxJS. Pues al final no es para todos y de pronto no es para todos los equipos. Entonces aquí es donde yo podría tener ya GetProducts, pero como promise. Entonces voy a poner GetProducts promise. ¿Vale? ¿Cómo sería entonces esto? Pues esto sería asíncrono porque suena a sana wait. Y pues hagamos un fetching. Un fetch. Aquí sí me hubiera servido mucho el autocompletador de... Ah, no, mira. Aquí me está autocompletando. Utilizando IDX de Google. No me lo he autocompletado tan chévere porque esto debería ser... Pues utilizando sana wait. Entonces voy a transformarlo. Esto sería el response. Y acá es una wait. Perfecto. Y acá está mal escrito. Response. Ya. Y entonces ahora hago un data que sería un await. De response. Punto. Y eso. Y finalmente pues ahí tengo la data. Return data. Ok. ¿Qué pasa si yo no quiero... Si realmente yo quiero salir de los observables? Que aquí es donde RxResource es gran ayuda porque si realmente quieres reutilizar toda tu lógica, pues utilizas Rx. Pero si de casualidad ya quieres salir de RxJS y hacer simples promesas, eh... Entonces ya no utilizarías Rx, sino lo que utilizarías es resource. Que eso viene directamente del core. Resource. Acá. Resource. Perfecto. Entonces ahora podríamos cambiar esto por esto. Resource. Y obviamente esto tocaría que devuelva una promesa. Entonces get promise. Y acá pues lo escriben. Resource. Y listo. Debería funcionar exactamente igual. Debería funcionar exactamente igual. Puedo hacer un reset. Puedo hacer un reload. O sea, sigue funcionando sin mayor dificultad. Solo que ahora pues tengo una promise en vez de un observable. Ahí es donde está pues la... Como la clave entre si utilizo un resource o un RxResource. Depende si tú quieres reutilizar tus funciones que ya tenías en servicios que utilizan el HTTP client. Esta es la manera. Bien. Ahora, la pregunta también es, ok. Esto es un fetching. Esto es un listado. ¿Cómo yo hago para conectarlo, por ejemplo, a que el detalle de un producto reciba un parámetro? ¿Cómo le meto parámetros a esto? Pues ahora vamos a hacer lo siguiente. Voy a dejar este aquí. Este, digamos que este ejemplo acá. Voy a hacer un HR. Acá. Y entonces aquí abajito voy a hacer el detalle. El detalle. ¿Y por qué no me cierra un HR de esta manera? Es autoclose. No, el HR. Ok, listo. Ahí está. Vamos a ver si ya me aparece. ¿Por qué tengo un error acá? Creo que se quedó pegado con el H7 que había puesto. Ahí está. Exacto. Ahí tenemos. Y por acá abajo está nuestra línea. Es más, la voy a hacer al principio para que el nuevo ejemplo nos quede aquí arriba. Listo. Entonces aquí voy a hacer el detalle de un producto. En este detalle del producto. Pues necesito, no sé, que me digiten el número del producto. Y con base en ello pues hago un fetching. Entonces sería el get. El get de un producto. ¿Cómo lo haría? Voy a seguir utilizando RX. Ya sabemos que podemos utilizar una promise. Pero voy a utilizar pues el HTTP client que está acá. Entonces acá tengo un producto. Hace un fetching y recibo los datos del producto. Y yo quiero que pues ver cómo yo podría recibir ese parámetro. Entonces acá. Voy a tener un nuevo resource. Product detail. Detail resource. Entonces aquí utilizo RX resource porque lo voy a conectar a un servicio que tiene observables. Entonces ahí está. Acá sería get product. Y la vuelta es aquí. Ok. Esto recibe un parámetro. ¿Cómo conecto ese parámetro? Entonces aquí podría tener un ID. Que sería el ID del producto. Product ID. Vamos a ponerlo como Product ID. Realmente también lo podría recibir como un parámetro. O sea como el routing. Sacar el ID del routing. Eso ya se puede con el binding input. En donde literalmente yo recibo el ID como un sign-in y input sin problema. Por ahora lo voy a declarar directo. O sea como un sign-in acá. Que sea tipo number. Que inicie en nulo. Sí. Que inicie en nulo. Por ende entonces. Voy a ponerlo por acá. Puede ser el Product ID. Puede ser acá. Puede ser un number o un nulo. Aunque no está muy bien que inicie en nulo. Pero vamos a ver cómo nos va. ¿Listo? Podría también ponerle un ID por defecto. Voy a ponerle un ID por defecto. Por ejemplo el ID 1. Y ahí es donde normalmente yo lo ataría al routing. Esto debería llegar directamente. Como un input sign-in. ¿Listo? Esto lo voy a atar a este con un ngModel. Entonces vamos a utilizar el ngModel. Y lo ato al sign-in para que tenga el input binding. Y acá me está molestando porque obviamente el ngModel. Necesitaríamos importarlo. Entonces hacemos un import. Import. Vamos a ver. Import. Déjenme ver una cosita. Acá. Import. ¿Listo? ¿Listo? Y nos traemos a los forms. Form module. Form module. Perfecto. Entonces ahí ya no molesta. Entonces esto ya significa que si yo cambio ese ID. Pues debería actualizarse. Y esto es un sign-in. Entonces debería funcionar de forma reactiva. Entonces ¿cómo yo ato este sign-in? Y ahí está digamos el truco. La forma de atarlo. Si yo estoy utilizando un resource. O un RxResource. No importa. Los parámetros sí deben ser sign-ins. ¿Por qué? Porque en el caso. El RxResource. Yo lo conecto a un servicio que devuelve un observable. Pero los parámetros sí van a ser sign-ins. Entonces por eso tengo mi Product ID en sign-in. ¿Cómo yo lo? Pues como hacemos la implementación. Aquí es donde hay algo llamado request. Este request. Normalmente yo puedo retornarlo como en un objeto. Entonces vamos a devolverle un objeto. Y le voy a decir. Este es el Product ID. Product ID. Product ID. Y le digo. Pues yo tengo un sign-in. Con ese valor. Listo. Entonces acá. Esto al mapearlo de esta manera. Aquí yo ya recibo. El request. Y del request. Entonces yo puedo obtener. Es más creo que acá por typing. Ya me dice Product ID. Entonces yo puedo decir. Ok. Mira. Mándale el Product ID. Entonces ahí ya los tengo conectados. ProductDetailResource no lo he mapeado entonces podría ponerlo por acá digamos que en un párrafo coloco el pues el nombre del título product.value me suscribo y acá podría pues obtener title, acá me dice que value podría en un momento ser un define porque claro no tiene un valor entonces podría hacerle algo como un knowledgeColessing y acá ya está el primer producto, ahora que es lo bueno que si yo cambio esto por el 2 en automático cuando cambie el param cuando este signal cambie en automático como este ya mapeó esa suscripción de alguna manera como que ya sabe que es dependiente de ese signal entonces ya sabe que tiene que volver a hacer un request porque están actualizando ese producto entonces solo hace falta no hace falta que leerlo o hacer un subscribe, simplemente acá es de nuevo muy declarativo yo digo está este signal le digo productDetails depende de productSignal hago el fetching con el valor que tiene, en este caso por defectos 1 pero si yo lo cambio entonces estoy en automático ahí está el 4, sé que pues está la ID 5, sé que está la ID 6 y yo podría entonces colocarle un loading también acá podría colocar esto está cargando y es loading ahí está entonces ahora si yo le muevo al número 8 está cargando y false está el 9, está cargando sí, loading y va y lo trae entonces literalmente de esta manera yo ya primero, fíjense que acá me hubiera tocado crear para el detail me hubiera tocado crear un loading para el detail y un error para el detail y pues la data el value para obtener o en qué variable guarda todos los detalles del producto para renderizarlos todo esto ya queda aquí todo eso ya queda aquí literalmente como parte de es parte del estado un resource va a tener su valor va a tener el estado de si es loading y su status, si salió mal, si no salió mal puedo hacerle un set o puedo hacerle un reload, etc. y esta sería la forma en la que yo lo ato a un parámetro un parámetro que esté cambiando y que necesito hacer ese request entonces fíjate como se puede hacer un request como se puede hacer un request como se puede hacer un request como este nuevo RxResource o resource depende si tú quieres manejar una promise o seguir utilizando el HTTP client o observables pues te sirve un montón para optimizar esas peticiones que son asíncronas ahora con esto sabes de las dos nuevas primitivas reactivas de Angular tienes resource para promesas y RxResource también para hacer todo lo que es asincronismo pero basado en los servicios que ya tengas con RxGS así que si quieres saber más recuerda suscribirte a mi canal y nos vemos en la próxima