 Angular en la versión 19.2 ha lanzado una nueva reactiva primitiva precisamente para hacer fetching, cosas como hacer un request a una API y sería el reemplazo definitivo a lo que conoceríamos como el HTTP client. Así que vamos a explorar el HTTP resource y ver cómo funciona. En el blog post oficial mencionan algunas de las mejoras. Recordemos que esto es una mini release, o sea, no es como tal una nueva versión como una 20, como una de estas grandes. Es una mini release, es la 19.2 y en esta han lanzado precisamente el HTTP resource que lo vamos a explorar en este video. Sin embargo, para entender mucho mejor cómo funciona el HTTP resource, al final esto se apalanca en una primitiva que ya habían lanzado antes, que es el resource. Que tiene su otra variante que es el RxResource para adaptarlo hacia observables. Así que te voy a dejar por aquí el video en donde hablé muy específico. Y muy a fondo acerca del resource, cómo funciona, cómo podemos habilitarlo para entender en definitiva cómo funciona el HTTP resource y qué problemas resuelve. Así que vamos al código del proyecto que tengo como listo para poder hacer el ejemplo. Este es un proyecto sencillo que ya está bajo la versión 19.2 y tengo un algo súper sencillo que es una lista de productos que al final hace fetching. Y pues a este le puedo hacer reset, le puedo hacer reload y vuelve a hacer fetching. Si voy a un click pues va y me hace el detalle de ese producto. Entonces si yo voy por acá pues va el detalle del producto, etc. Todo esto ya funciona. Acá por ejemplo tengo un servicio que todavía utiliza el clásico HTTP client. Acá tenemos observables que devuelven suscripciones y van y hacen los requests. Y tengo dos páginas que es la página de la lista de productos. Y fíjate que acá tengo un RxResource. De nuevo. Te sugiero que veas el video en mi canal acerca de RxResource para que entiendas bien esta nueva directiva, las posibilidades y entiendas precisamente el HTTP resource que es lo que vamos a ver hoy en este video. Entonces tenemos el product page y acá tenemos el detail que también es un resource que básicamente lee el ID. Al final esto es una ruta. Les voy a dejar el link de este Starbucks en la descripción del video por si lo quieren ver a más detalle. Básicamente esto es la ruta principal. Luego aquí el ID. El ID lo estoy mapeando directamente como un input required. Recuerden que ya los IDs pueden ser enlazados directamente a la ruta. Esto gracias a esta configuración que es la de el with component input binding. Entonces no hay que leer el active route y todo esto sino que ya llegan directo como inputs a la ruta y utilizando sign al input pues se pueden leer así. Esto también tengo un video de esto. En mi canal el component input binding lo puedes como cerciorar y también funciona muy bien con los sign al inputs. Pero básicamente aquí recibo ese sign al o recibo ese parámetro en forma de sign al y lo asigno gracias al RxResource. Ok. Esto es como la explicación clave y de nuevo deberíamos entender muy bien cómo funciona. No muy bien pero al menos saber de qué trata el RxResource y el resource para entender cuáles van a ser los beneficios del HTTP resource. Entonces de nuevo por ahí te dejo el link en la descripción. En alguna carta aquí de YouTube para que vayas y veas este video y entendamos muy bien el HTTP resource. Dicho eso pues vamos a empezar a usarlo. Si nosotros vemos el blog post oficial vemos que ahora podemos hacer como la llamada a HTTP resource y con una call function. Básicamente sobre todo cuando tienen dependencias ahí es cuando deberíamos utilizar una call function. Utilizar y literalmente le vamos le botamos el input y él ya se encarga de hacer el fetching. Entonces veamos cómo usarlo. En las que tienen dependencias y no primero en la lista de productos que es como la más sencilla y ver cómo también empiezan a cambiar nuestros servicios. Ok. Vámonos primero por la lista de productos. Es esta. Cómo migraríamos esto utilizando ya el HTTP resource. Lo primero es que esto viene de el common de HTTP. Ahí está. Y lo traemos como el HTTP resource. Ahí ya lo puedes encontrar. Entonces. Aquí básicamente cambiaremos esto y voy a comentar esta parte para que veamos como la diferencia. Sin embargo como es un resource. Pues vamos a utilizar. O sea todo esto no cambia. Tenemos el estado de desloading. El punto value. Podemos hacerlo en set. Podemos hacerlo en reload. Esto no cambia porque sigue siendo un resource. Pero lo que va a cambiar la forma en que se declara y de pronto que vamos a tener menos código. Entonces vamos a tener aquí product resource el que teníamos. Solo que ahora lo vamos a declarar como HTTP resource. Lo primero que tenemos que hacer. Y aquí ya podríamos ver que podríamos enviarle una URL. La URL a la cual se le va a hacer request. Y aquí podríamos ir al servicio. Que está por acá. Y literalmente pegarle el endpoint. De lo voy a copiar con el string. De nuestro. El endpoint al cual queremos pegarle y ya. Y literalmente con eso ya ese es el intercambio. Entonces ya no tendríamos que hacer loader. Aquí ya no estaríamos utilizando observar. Ni siquiera estaríamos utilizando o tendríamos que hacer como una promise. Si no el ya lo resuelve. El HTTP resource seguramente por detrás ya utilice fetch nativo de JavaScript. Que es hacia donde Angular se está moviendo. Ya salir de RxJS. Entonces seguramente se utilice pues el fetching. Pero pues tiene varias cosas como reactividad. Aquí por ejemplo podría decirle que método. Que método es el que yo quiero. Si es un get o si es un post etc. Y aquí voy a poner aquí. Hasta podría yo empezar a poner los headers. De por si se vuelve esto ya es una función. Y es una función casi que los parámetros. Son muy muy parecidos a los que tendríamos en una función fetch. Que en fetch también le envías la URL. Los headers etc. También tiene un segundo valor. Que es un default value. El default value es precisamente por ejemplo. En este caso que lo que yo espero es tener un array de productos. Normalmente como es fetching. Como es un algo que es asíncrono. Iniciaría en undefined. Porque no hay nada hasta que realmente tenga el valor. Pero yo podría cambiarle ese valor por defecto. Por ejemplo en este caso que es un array. Normalmente podríamos poner un array en vacío. También algo que podemos hacer es ponerle typing. Porque acá perdemos un poco el typing. Entonces lo que podríamos hacer es decirle. Ok mira esto devuelve un array de productos. Inicia con esto. Es get y esta es la URL. Bien. Entonces vamos a ver. Acá tengo creo que un error. Vamos a ver. Si ya después de recargar. Funciona. Ahí está. Entonces tenemos exactamente como el mismo resultado. Acá está. De por si pareciera como más código. Contra esta configuración. Sin embargo recordemos que ya no estaríamos utilizando el product service. O sea ya no estamos necesitando de un servicio. Y no estaríamos utilizando el http client. Aquí directamente ya estamos haciendo. La llamada al resource y el fetching. No tendríamos que si estamos utilizando promise. Hacer el await. El punto json. Como pues toda la parte para operar. Y hacer fetching. Eso se lo dejamos a http resource. Ahora esto es en teoría sería una mala práctica. ¿Por qué? Porque normalmente nosotros tenemos servicios. Que se encargan de hacer como estas operaciones. O conexiones a datos. Y ahí es donde otros componentes lo puedan reusar. ¿Qué quiere decir? Que si yo quiero en otro componente. Quiero utilizar y volver a hacer el get de productos. Tengo que volver a escribir esto. Y la gracia es no hacer esto. Entonces podríamos cambiar esto. Y moverlo al servicio. ¿Cómo sería? Entonces aquí sería igual. Voy a poner get products. Get products resource. Y lo que hacemos es un return. Y literalmente devolvemos el resource. Esto lo sacamos de el common de http. Y listo. Entonces tenemos acá ya la definición. Un default value. De por si tiene otras opciones. Más que las vamos a ver en otros videos. Pues un poquito más avanzados. Tiene una función para parciar. Que sería como algo. Como lo que haríamos con los pipes. Etc. Sin embargo recuerda. Este ya de forma definitiva. No utiliza observables. Entonces ya no podríamos utilizar los operators. Si realmente todavía quieres utilizar. Rxjs. Y reutilizar de pronto todos los servicios. Que ya tenías con observables. Con operators. Con switch match. Con varias cosas. Pues la mejor sería. Que sigas utilizando el RxResource. Bien. Que ese sí. Pues tener todas las ventajas de los resource. Pero te dejaría. Pues seguir utilizando tus observables. Si ya quieres salir. Y de los observables. Sería hacer ya fetching. Como más directo nativo. Digámoslo de alguna manera. O basado en signals. Pues esta sería la opción. Entonces acá. Este sería get products resource. Entonces ya no tendríamos que. Pues hacer como toda esa declaración acá. Si no nos vamos al servicio. Y hacemos get products resource. Y. Lo guardamos. Y ya nos quedaría así. Entonces tenemos la inyección del servicio. Y simplemente queremos un product resource. Por acá creo que. Hay un error. En la página. En la línea 34. Algo. Ah no. Ahí está recargando. Entonces está el Blix cargando. Ok. Entonces ya literalmente. Tenemos la definición de get products. Así. Directo. Y entonces ahí es donde te digo. Que nos ahorraríamos como. Estas líneas. O sea. Cambiamos esto por esto. Y básicamente. Esto. Por esto. Bien. En donde. Pues acá ya tenemos las ventajas de un resource. Tenemos. Podemos hacerlo en un set. Por ejemplo. Pues acá yo le. Puedo limpiar todo el array. Ahí está. Puedo hacerlo en reload. Y tengo estados de ese fetching. Si está cargando. Si salió un error. No hay problema. Normalmente. De nuevo. El resource nos ayuda un montón. A. Manejar el estado de un fetch. Que eso es complicado. Y normalmente lo haríamos muy manual. Eso de hacerlo manual. Está en el video del resource. Entonces ahí están las ventajas del resource. Pero ahora con el http resource. Pues como que. Es más declarativo. Y no tenemos que preocuparnos por el fetching. Ok. Esto es uno sencillo. Esto es uno sencillo. Fue hacerle get a un. A una URL. ¿Qué pasa con el que tiene una dependencia? Pues. No con el que tiene una dependencia. Con el que tiene un parámetro. En este caso el product detail. Entonces vamos a ver. Ya el detalle de un producto. Entonces yo voy acá. Fíjate que acá tengo. Puedo ir atrás. Y acá. Pues tengo también un estado de loading. Tengo la descripción. El título. Etcétera. ¿Cómo se hizo acá? Pues acá se recibe el ID. Estoy mapeando. O. Sí. Mapeando los parámetros. Y se lo envío a mi observable. Que aquí. Pues. Lo que teníamos. Es un ID. Que devuelve un observable. Y. Pues. Obtiene la información. Y. Gracias al resource. Pues igual. Tengo un estado de loading. Tengo. Si tiene un valor. Y luego puedo empezar a imprimir el título. Y el valor. ¿Cómo lo pasaríamos? Si me voy otra vez. Como por la misma definición. Es decir. Como. Muy manual. Digamos que acá me voy a poner a. HTTP resource. Lo voy a volver a poner acá. Lo voy a hacer primero aquí. Y luego lo paso al servicio. Para que veamos cuál sería el cambio. Entonces acá. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a hacer. Vamos a. Vamos a hacer. Vamos aplatir. Vamos a hacer. Vamos a hacerlo. un producto y producto esa interfaz la tengo en el servicio que básicamente es esta de acá esta interfaz de acá ok porque me está diciendo que no, ah ya listo ahora listo, tenemos eso nosotros podríamos hacerlo de la misma manera, es decir, enviarle como el parámetro, la url en este caso la url debería ser algo de esta manera entonces enviamos la url la envío de esta manera sin embargo el id tiene que funcionar de forma reactiva, aquí es donde yo podría hacer un dis.id, suscribirlo y debería funcionar, ¿no? debería funcionar, acá por ejemplo ya hay un error y es que yo digo que esto sí o sí devuelve product cuando realmente podría también devolver undefined, entonces yo podría decir esto también es undefined acá yo le podría hacer que esto es undefined y pues ya no me da como este tipo de error, sin embargo acá hay algo raro y es que como el título no existe, bueno hay varias cosas que aquí fallan, ¿por qué fallan? porque como este ya tiene una dependencia ya no se lo podemos enviar así los parámetros ya no los podemos enviar así de por si aquí empieza a fallar y si vemos el inspeccionador, aquí en la consola empezamos a tener algunos errores interesantes, como por ejemplo que el input required no tiene un valor y esto tiene que ver más que todo con la definición de mi HTTP resource, ¿qué pasa? que acá si bien aquí lo definíamos como así directo y no tiene ninguna dependencia aquí nos toca cambiar y como esto si tiene una dependencia y tiene que saber cuál es el ID lo que tengo que hacer es cambiar esto por una row function, es decir una función que devuelve exactamente los mismos parámetros pero necesita ejecutarla para obtener el valor del ID es decir, no es como simplemente enviarlo de esta manera sino que lo enviaríamos con una arrow function y esa arrow function calcula la URL con base al ID y ahí si hace el fashion entonces vamos a ver si funciona ahí está, funciona, entonces acá yo voy acá, ahí está entonces ya lo tengo entonces esto funciona de esta manera ok, acá por ejemplo yo también le puedo hacer un set, normalmente el set sería undefined, se lo quiero como quitar o le podría poner un producto directamente ahí en el valor, pero pues tiene que cumplir con la interfaz de product y le puedo hacer un reload, le puedo hacer, bueno acá es el botón de back, pero pues le puedo hacer todo lo que todo lo que requiere, digamos y de nuevo tengo un resource tengo todos los beneficios de un resource el estado de loading, si tiene valor el valor per se, etc ahora, ¿cómo pasaríamos esto de nuevo a nuestro servicio? entonces vamos a hacer esto, get product resource ok, entonces tengo una función lo voy a retornar acá le hago return y entonces lo tendríamos de esa manera, sin embargo aquí tenemos un signal, aquí es donde empieza a cambiar algunas cosas y es que el id sería declarado como un signal, yo espero que esto sea un signal de tipo string entonces aquí importo el type in the signal y ahora pues obtengo el valor, como eso es un id, entonces lo obtengo entonces fíjate que yo tengo que enviarle un signal, entonces yo tengo que enviarle un signal de esta manera, pues eso podría ser una opción donde envío directamente el signal y como es una función, esta función que se declara de forma reactiva pues él va a obtener el valor y como aquí ya en esta función está declarando la dependencia, cada vez que cambia signal, pues se va a ejecutar el resource, entonces este sería como la forma, ahora vamos a ver cómo lo usamos, entonces ahora en project tail, pues ya no lo haría de esta manera, sino simplemente haríamos el llamado al servicio que sería productservice.getproductresource y le enviaríamos directamente el signal que en este caso es un input signal que viene del id que viene en la ruta, que es este que está por acá, este id que dinámicamente se está pasando y en la lista del producto, si ves básicamente estamos poniéndole en la iteración product slash id y pues va a esa ruta en específico entonces ahora tendríamos esto bien, entonces tenemos product, le digo mira este es el resource para product este es el signal que va atado pues para que estés leyendo de forma reactiva y seguimos teniendo pues las ventajas de un resource, entonces acá veamos cómo quedó al final quedó de esta manera, quedó url también podríamos meterle un default value pero realmente lo define creo que está bien entonces podríamos meterlo como un define y no hay mayor dificultad bien, lo único acá raro es que ya no tenemos un como el id de forma directa como string sino que como esto y el http funciona con signals y con reactividad, lo que tendríamos que hacer para que esto funcione de forma reactiva es primero si tiene una dependencia, recuerda enviarlo como una row function, esa fue una de mis primeros errores al entender este http resource, no le envié como estos parámetros, cuando es estático lo puedo enviar así nomás, pero cuando si tengo que calcular pues o meter un signal como dependencia tengo que enviarlo como una row function ok, entonces ahí si lo calculo, como esto es un signal ya puedo obtener el valor y pues ahí sigue funcionando, ahí está, vamos a ver sigue funcionando back, mouse ahí está, sigue funcionando y este es el resource algo que hay que tener en cuenta es que tanto el resource como el http resource por ahora solo funcionan como para hacer get, es decir, para obtener parámetros, puedes enviar un post claro que si, puedes enviar un post, pero al final lo que se espera de ese post, por ejemplo es un search o algo de ese tipo en donde devuelve cosas, todavía no está preparada como la API para hacer mutations, es decir todo lo que sea de la creación, enviar un post pero para crear, hacer un delete, hacer un update como de formularios que es lo más típico, todavía no está preparado sin embargo pues ya se están empezando a explorar las APIs, normalmente esto se llama mutation, y listo, eso fue el http resource, espero que te haya servido para explorar esta nueva primitiva reactiva, para ver que sería el reemplazo definitivo al http client sin TGS, te voy a dejar este starblitz o este ejemplo, dentro de la descripción del video ya que es público, así que lo puedes ver forkear y pues ya hacer tus propias pruebas, recuerda suscribirte a este canal y pues te veo en el próximo