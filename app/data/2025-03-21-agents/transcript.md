 OpenAI ha lanzado su propio SDK para manejar agentes, para orquestar sistemas multiagentes. Obviamente utilizando todos sus features, todos sus modelos y también las tools. Tools nuevas que son bastante interesantes que se soportan en la nueva API, Responsive API. De por sí ya tengo dos videos en mi canal hablando de las diferencias de Chat Competitions con Responsive API y cómo utilizar estas tools simplemente con el SDK. Sin embargo, en este video vamos a ver cómo utilizar agentes o cómo es la propuesta de OpenAI para crear agentes utilizando esas mismas herramientas, esas mismas tools, pero ya orquestándolo en un sistema multiagentes. Ahora, esto es una evolución a lo que ellos experimentalmente tenían como Swarm. Swarm que era como este forma de OpenAI que estaba en forma como muy, muy beta. Pues precisamente ahora lo han ya lanzado de forma oficial, de forma productiva y es lo que vamos a experimentar. Vamos a explorar ahí. Así que vamos al código. Esta es la documentación oficial de OpenAI y en SDK. Entonces me dice por qué usarlo, cuándo no, bla, bla. Básicamente pues tenemos todo el patrón de agentes en donde puedo empezar a pues tener un sistema, cada agente respondiendo como algo en específico. Acá tenemos la documentación, cómo crear un agente, cómo correr, hacer streaming, que es pues enviar un streaming la respuesta, hacer un handoff, esto es muy importante, que es cómo yo puedo pasar de un agente a otro, cómo yo puedo decirle qué agente es el que debe actuar según el historial del mensaje, el historial de la conversación, X o lo que el usuario está escribiendo. También puedo hacer tracing. Esto me parece muy, muy interesante. Uno puede ya en automático, si tú creas esto con OpenAI, también tener una plataforma de monitoreo. En fin, entonces vamos a verlo, vamos a estudiarlo. Entonces lo primero que vamos a hacer es instalarlo. Yo ya lo tengo instalado en mi entorno, así que simplemente tú instálalo en tu entorno. Yo utilizo Conda para mis entornos. Entonces tú miras cómo lo quieres instalar en tu entorno, lo que sea, pero simplemente instala la dependencia OpenAI Agents y creas tu key y la pones. Puedo crear un archivo. Esta vez ya no voy a trabajar como en los notebooks que venía trabajando, sino literalmente voy a trabajar en un archivo per se de Python. Bien, entonces vamos a llamarlo demo.py. Listo. En este demo.py vamos a, de por sí aquí tengo un poco el ejemplo de lo que quiero lograr y solo de ese ejemplo me voy a copiar, cargar las variables de entorno. Que básicamente es llamar a la key en donde pues tengo mis variables de entorno con OpenAI o lo pueden cargar aquí. Y recuerda que uno se puede exportar y ya. Acá está. Están algunas instrucciones de cómo generar la key, etcétera, etcétera. Ok, entonces aquí literalmente vamos a copiarnos este primer agente. Y acá lo que hacemos es ya importar Agents de la librería Agents. Vamos a importar Agent. Y acá, por ejemplo, me dicen mira, yo este agente es un, le doy un nombre a este tutor. Bueno, a ese agente y dice que este va a ser un tutor en matemáticas. Y acá le doy Instructions. Aquí se parece mucho. Los inputs se van a parecer mucho a Responses API. A la nueva API. Instructions, los inputs, etcétera. Entonces le envío, este sería lo que conocemos como el System Prompt. En donde tú pues debes proveer ayuda a solucionar problemas de matemáticas. Explica tu razonamiento de cada paso e incluye ejemplos. Ok, este es un agente. Vamos a correr a este agente. Directamente vamos a correrlo. Entonces, ¿cómo se corren los agentes? Entonces acá luego vamos a importar el Runer. Y luego vamos a utilizar un Main de forma síncrona. Que es este de acá. Y vamos a correrlo. ¿Cómo se crea? Entonces acá ya creamos el agente, que es este que está acá. De por sí lo creamos fuera del Main. Pero acá es donde tenemos el resultado. Entonces acá yo estoy haciendo un Await. Le estoy diciendo el agente. Y esto es lo que el usuario... Le escribiría. Entonces, es más. Aquí vamos a hacer algo muy interesante. Vamos a, desde la consola, recuperar esa información. Entonces, vamos a escribirle. Digamos que este es el mensaje del Message. Message, Message. Hola, ¿en qué puedo ayudarte? Voy a decirle que escriba en español. Tú pruebes ayudas en matemáticas. And your... And your... Your responses are in Spanish. Perfecto. ¿Listo? Entonces aquí, este mensaje que me va a llegar desde la terminal, lo vamos a poner acá. Message. Y el resultado, pues lo vamos a imprimir. Entonces, pues, imprimir resultado. Ahora, vamos a ver la documentación. ¿Cómo imprime? Lo que imprime es un Final Output. Entonces, vamos a imprimirlo como Final Output. Luego, entonces, pues ya como esto lo puedo crear como un script. Y acá, como esto va a ser asíncrono. Me importo async.io. Y voy a poner todos estos imports. Solo porque me da tic nervioso. Vamos a ponerlos arriba. Listo. Listo. Entonces tenemos un agente. Literalmente tenemos un agente. Todavía no es nada robusto, pero es un agente. ¿Vale? Y esto sería muy familiar a literalmente utilizar Responses API, SDK de Python y ya. Pero, pues, vamos entendiendo un poco. Entonces, vamos a ver cómo correrlo. Pues, vamos a ir a la terminal. Vamos a ver. Vamos a limpiar por acá. Y vamos a ejecutar Python. Y en este caso voy a ejecutar demo.py. Entonces, ahora en que puedo ayudarte. Entonces, quiero que me ayudes a entender Pythagoras. Que no es un problema per se, pero vamos a ver que me responde. Ay, dice que no he seteado. No he seteado la OpenAI. La key de OpenAI. ¿Por qué? A ver. Vamos a ver. Esto ya debió haber cargado la key. Entonces, vamos a volver. Vamos a correr el archivo. Entonces, dice que en que puedo ayudarte hoy. Ayúdame. Ayúdame a entender. Entender Pythagoras. Pythagoras. Pythagoras. Pythagoras. Pythagoras. Pythagoras. Pythagoras. Vamos a ver. Entonces, vamos a esperar aquí que me responda. Aquí no, me está diciendo como un archivo de key, como una advertencia. O sea, si me respondió. Me da como un mensaje de advertencia de que esta key no está configurada para hacer tracing. Que ahorita vamos a ver como el sistema de monitoreo. Pero ahorita no me importa, pues, que la key esté habilitada para tracing para el sistema de monitoreo. Luego la vamos a configurar. Pero lo importante es que aquí ya me respondió. aquí ya me respondió, me dice por supuesto, mira el teorema de Pitágoras bla bla bla, es más, puedo aquí ponerle como algo para identificar la respuesta respuesta esta es la respuesta de la IA y ya, entonces lo puedo limpiar otra vez puedo ejecutarlo, obviamente esto ya lo puedo poner en una API con FASAPI y todo lo que eso significa pero por ahorita lo estamos corriendo en consola entonces, hola entonces, bueno me aparece aquí como esta advertencia de que esta aquí no está configurada para hacer tracing, pero me dice, hola, ¿en qué puedo ayudarte? ¿cuántos problemas de matemáticas? o sea, me está respondiendo, ¿vale? ok, entonces sigamos acá, listo ahora aquí tenemos un agente sencillo sin embargo, un agente, la gracia de un agente es poderle dar tools acá es donde uno le puede dar una tool y se vuelve un poco más sencillo, por ejemplo en Responses API o manejando la API es un poquito más complejo darle una call function, etcétera la gracia de ese agente es que sea más fácil hacer un agente entonces básicamente lo que yo tengo es lo siguiente, entonces vamos a decirle que yo quiero extender digamos que yo tengo una función y ahora este agente ya no va a ser un agente de matemáticas, va a ser este agente que está acá literalmente va a ser este agente que está acá entonces lo voy a cambiar, ya no va a ser un agente de matemáticas, va a ser un haiku agent que básicamente es como responder en una forma en este tipo de respuesta que es como decirle responde en forma pirata responde en modo como con este tipo de formato sin embargo acá yo le estoy dando una tool, pero esta no es una tool de OpenAI, es una tool que yo escribí es decir, que yo puedo manejar el código, ¿cómo yo doy una tool? pues acá yo tengo esta función, function tool que es muy parecida a la que tiene Landgraf, de por si Landgraf también tiene un decorator para sus tools y acá yo le doy una tool en esta tool lo importante es que yo ya soy ya soy dueño del código, entonces ¿qué quiere decir? que acá yo puedo correr una API puedo conectarme a una base de datos etcétera, literalmente esta función yo tengo el de esta función, porque estoy aquí en Python yo puedo conectarla, acá digamos que la respuesta de esta función es simplemente me va a detectar, y esto lo va a hacer en automático va a detectar una entity en automático, va a detectar la ciudad de la que el usuario está hablando y simplemente le voy a responder que está pues soleada, obviamente yo debería conectarme a una API del, como ya tengo la ciudad, podría ir y conectarme a la API del clima para saber cuál es el clima de esa ciudad, etc. pero eso ya es como un todo, conectarme a una base de datos conectarme a lo que sea, pero acá yo simplemente ya estoy como suponiendo que fui, me conecté y es soleado, así que esa va a ser la respuesta de mi todo, ok acá dice que siempre responda en esta forma, que utilice un modelo de razonamiento, interesante que por defecto me diga que utilizo yo utilizaría GPT-4 pero me parece interesante que supongo que es porque tiene que razonar qué tool debe usar, pero GPT-4 es muy buena en eso, pero interesante que por defecto me sugiera o que en la documentación me diga que utilice un modelo de razonamiento, ok entonces acá ya tengo un agente que tiene una tool, vale y puedo volverlo a correr, etc. entonces vamos a volverlo a correr entonces lo limpio y lo corro ¿cómo puedo ayudarte? hola fíjate que cuando él automáticamente no y es un poco lo que una vez que se ha hecho un de esas dudas normales y aquí se demora un poquito en responder porque estoy utilizando un modelo de razonamiento, los modelos de razonamiento se demoran un poquito más acá fíjate que no fue directamente y ejecutó la tool, sino que lo que hace automáticamente detecta cuándo no llamar una tool como yo no le estoy preguntando nada todavía del clima, ni le estoy dando nada de la ciudad, pues simplemente responde sin necesidad de ejecutar la tool, eso es muy bonito porque literalmente esta tool no significa que siempre se va a ejecutar sino que la va a llamar cuando él crea que es adecuado, por eso es importante el modelo de razonamiento sin embargo creo que un GPT-4 lo hace también muy bien pero dejámoslo con el 03 mini él va a saber cuándo llamar a esta tool, cuando no sea necesario en este momento simplemente me dijo que hola friend, bla bla bla pues me dio la respuesta y ya todo bien, no fue y llamó la tool de por si voy a cambiar este modo de responder, voy a ponerlo en en weather agent o sea este va a ser como el agente del clima y lo que voy a hacer es responda en spanish si en spanish bueno responda en voy a hacerle que responda como pirata y en español listo y vamos a probarlo obviamente aquí cambió este agente entonces hasta ahora todo muy sencillo pero pues aquí ya vemos la tool vamos a ver, hola vamos a ver si me responde en pirata y en español se demora un poquito, eso tienes que evaluarlo entonces dice ahoy, que aventuras te trae hoy por estos mares ok, bien acá yo podría ponerle como un while true y como que sigamos hablando básicamente déjenme lo pongo y pues ya me quedo en una conversación hasta el infinito básicamente solo que tendría cada vez que salga el mensaje reescribirlo, si acá está que pueda ayudarte hoy y introduzca mensajes, si creo que con esto va a bastar vamos a ver si ya con esto me quedo en un loop infinito hablando con él hola creo que por efectos del video también voy a moverlo a gpx2 para que no se demore tanto dice bienvenido a bordo que te como que aventuras te trae por acá entonces yo le digo me gustaría saber que clima hay en Bogotá entonces fíjate que él automáticamente va a reconocer la entidad Bogotá y se lo va a mandar a la tool y por defecto mi tool todavía no llama a ninguna base de datos, ninguna API pero cualquier ciudad que le envíe va a decir que es su aliado entonces vamos a ver qué responde entonces aquí ya debería saber que tienen que ejecutar una tool y dice según mi brisa Bogotá el sol está comandando los mares, en fin acá ya se trajo toda la respuesta en modo pirata y reconoció la ciudad reconoció la entidad ciudad y fue y ejecutó la tool, entonces aquí listo, acá tenemos un agente sencillo que sabe cuándo llamar a la tool acá de nuevo yo creo que para que funcione un poquito más rápido si ustedes quieren velocidad en la respuesta yo utilizaría GPT-4 que también es bueno con las tools realmente no sé por qué por qué sugieren que por defecto sea el de razonamiento pero pues en fin lo pueden probar y en teoría este debería responder mucho más rápido, hola compañero cómo estás listo para hacer para las aventuras sí, dime qué clima es en La Paz por ejemplo vamos a ver otra vez me va a decir que La Paz está soleado dice La Paz el sol brillando como el oro del tesoro digamos, entonces ahí sigue respondiendo y ya me puedo quedar aquí como chateando listo, esto es un solo agente que tiene como esta estructura o esta arquitectura de react de razonamiento y y actúo con base a lo que yo le voy escribiendo pues entonces pues él sabe cuando nos llamaron a tool listo sin embargo esto es como lo más sencillo y creo que un framework de agentes va mucho más allá vamos a ponerlo un poco más a prueba, vamos a poner más de un agente y hacer un agente de triage, qué significa que él tiene que analizar cuál es el mejor agente para resolverlo entonces acá tengo un ejemplo entonces voy a tener este otro agente que es un agente que si yo le envío la información de un evento simplemente extrae la información de ese evento entonces aquí vamos a decirle que este es el agente, el agent el weather agent y ahora aquí vamos a poner un agente que es el calendar agent y es este de acá acá me va a traer a paint.dict para, porque acá va a utilizar una forma de estructurar el output de nuevo acá agent me tiene como unas variantes en este caso es el output type y yo le digo que por favor me devuelva lo que me devuelva que es básicamente por detrás utilizar la estructura de output lo que me dice es que utilizando este modelo que es un modelo de paint.dict pues me devuelva el nombre, la fecha y los participantes de un evento, entonces acá lo único que tengo que hacer es importar paint.dict que por acá lo tenía en mi ejemplo y listo, entonces qué hago, esto es un calendar.stat es la de desde un texto como la información de un evento y pues necesito que lo mapee de esta manera, vale entonces este es un otro agente, listo ahora el problema es como yo le digo como como decidir de acuerdo al historial, de acuerdo a varias cosas como decido cual agente que agente debe pues tomar y aquí es donde hacemos el handoff que es como pasar de un agente a otro entonces como se hace ese agente acá seguimos teniendo una estructura muy similar a esta, de por si aquí lo voy a llamar como a este agente se le llama triage agent y lo voy a llamar así triage agent, entonces acá dice triage user analiza el mensaje del usuario y determine si este es una pregunta sobre el clima o sobre una pregunta sobre un calendario, sobre un evento y acá me dice que el output string es, o sea que devolvería debería retornar un string, realmente esta parte no no la necesito siempre va a retornar string a menos que yo le envié pues un modelo para estructurar la respuesta pero este sería la forma, aunque según instrucciones o según la documentación de OpenAI, si nosotros nos vamos a la parte de handoff acá vemos un una de por si hay algo muy interesante aquí es que tienen pre definidos algunos prompts para hacer handoff, pero vamos a utilizar un handoff sencillo que no sé porque aquí no lo tienen en este ejemplo no sé en que parte de la documentación a ver si de pronto en este está eeeh acá acá tienen acá tienen uno de triage este es el mismo de triage que estoy por acá y bueno, realmente tienen uno muy sencillo, también basado en la información debe escoger, pero bueno yo voy a utilizar este prompt que lo vi en una parte de la documentación que ahora ya no la encontré pero acá le voy a dar las instrucciones le digo tú eres un un pues eeeh ayudas a alucharles con sus preguntas si la pregunta es sobre el clima por favor transfiera esto al weather agent si la pregunta es acerca del de un evento, voy a ponerlo en evento eeeh haga handoff al calendar agent y ahora lo más importante es como yo le envío a esos otros agentes entonces acá yo mando al weather agent esto es muy muy parecido a crew ai realmente eeeh y al calendar structure, entonces acá yo le doy normalmente de esto el va a decidir, entonces el que ahora va a tener la decisión es triage agent, vale entonces nuestro agente ya no va a ser por defecto este, sino todo va a empezar por el agente de triage y el el no va a responder, este agente de triage lo que va a hacer es saber a cual pasarlo, si pasarlo al de weather o al de calendar, depende de lo que le estén hablando, eeeh y si no el va a responder puede responder en caso que no sepa cual osea no tenga información tan especifica, de pronto no le están hablando de ni de eventos, ni de el clima, sino de otra cosa entonces el como que va a responder y aquí yo le podría dar también una instrucción como cuando no cuando no sabes que agente hacer handoff, pues simplemente el le manda también un prompt para que siga la conversación, no, en fin entonces vamos a probar este triage vale, y ver que onda vamos a ver eeeh y aquí es donde si ya me debería servir pues hacer tracking y ahí es donde si nosotros abrimos la plataforma de openai eeeh aquí uno puede gestionar sus proyectos, pero si uno va al dashboard y se va a traces uno puede empezar a trackear como hizo ese handoff eeeh y vamos a ver si con eso aunque supuestamente aquí tengo un alert de que mi apk no se puede no esta habilitada para hacer tracing pero en algunos ejemplos que hice algo así se ve el triaje entonces como que primero el eeeh el agente de triage por eso le ponemos un nombre como que analiza, acá yo puedo ver un poco que responde, el todo el historial y acá puedo ver como el le envía o como que le traspasa al otro agente que sería mi heiko agent esto es lo que deberíamos ver y que herramienta utilizo, etcétera vamos a ver si ahorita puedo solucionarme el problema con aquí, pero si no básicamente esto es el tracing que tenemos en openai para saber que agente lo tomo y como lo tomo y cuanto duro, etcétera pero vamos a ver igual ya como responde aquí entonces vamos a hacer lo siguiente ahora algo que si voy a hacer y algo que si acá requieren es como ponerle el contexto entonces lo primero que voy a hacer y voy a ver si me sirve eeeh va a ser lo siguiente primero vamos a meterle una como una eeeh id a la conversación como todo un id a la conversación voy a generar un id importando eeeh import uuid perfecto, entonces aquí tengo como la conversación para manejar como todo el hilo conversacional luego voy a este hola como puedo ayudarte está bien pero el historial si lo voy a seguir manejando como un array vale es decir entre más mensajes pues este input va a seguir creciendo quiero no solo manejar un mensaje quiero ir teniendo todo el historial de la conversación aquí no estoy utilizando como la API de responses en donde yo puedo enviarle el el response id previo para manejar la conversación automáticamente en OpenAI acá lo que voy a hacer es hacerlo manual y ir teniendo un array e ir sumando el array de mensajes e ir enviándoselo ok y segundo vamos a ver si esto si me deja hacer tracing eeeh vamos a poner dentro de este while true on trace y este trace viene de de agents entonces lo ponemos acá listo y por acá le puedo poner eeeh este sería demo example listo y eeeh esta es la idea de la conversación para como que analizar como todo el triaje que se hace con solo pues un un id no con eso uno puede seguir todo el historial porque recuerden que pues al final si ustedes ponen esto en una API pues van a llegar muchos mensajes no y y de un usuario de otro usuario entonces como se cual es de cual pues básicamente se crea un id para seguir el flujo conversacional listo una vez responda una vez el usuario pues la AI responda que recuerda que acá ya le estoy enviando mi no el agente el de clima sino mi triage agent pues lo que vamos a hacer es concatenarlo a los inputs lo concateno esta sería la respuesta de de la AI y le pongo que este es el role de assistant y le voy a ir enviando en vez de los mensajes le envio inputs que sería el historial de mensajes y listo y luego pues nada que introduzca la respuesta y también una vez el usuario pues me escriba lo que voy a hacer es concatenar esa ese user message a el array de mensajes con eso en la siguiente pues ahora voy a tener el el array de la conversación vamos a ver como funciona y como funciona ya este triage entonces vamos a ver vamos a ver que puedo ayudarte hola vamos a solo escribirle hola en teoría el no sabría que agente osea esa no es información suficiente para saber si el agente de clima o el agente de calendario lo tiene que obtener el debería simplemente seguir la conversación aquí yo debería darle otra instrucción diciéndole oye cuando no lo sepas habla, háblale de esto o recuerda que este es tu scope bueno ya técnicas de program engineering no entonces hola vamos a ver y dice en que puedo ayudarte hoy y bueno ahí me sale todavía el warning de open que raro bueno dice en que puedo ayudarte hoy todavía no lo hizo triage a ninguna a ningún agente entonces le dice ahora si voy a decirle que clima clima hace en tokyo aquí en teoría como ya le estoy hablando del clima el debería utilizar pasárselo al weather agent y fíjate que acá ya respondió y bueno y responde el agente del clima tiene otro prom en específico que es que hable como pirata y por defecto utiliza una tool que es que le dice que es soleado entonces en tokyo hace sol entonces fíjate que acá si realmente hizo lo mandó al otro agente que es el que tiene el prom de que hable como pirata que tiene una tool que es una función etcétera pero vamos a seguir la conversación entonces le digo ok ok interesante le voy a decir a ver qué pasa interesante a ver si él vuelve fíjate que él ya no se va al vuelve otra vez al triaje siempre se está teniendo toda la raíz de los mensajes entonces vuelve al de triage como triage no sabe ya no tiene contexto de no le están hablando del clima porque el último mensaje no tiene nada que ver con el clima solo le dije ok interesante pues sigue manteniendo el flujo con el clima conversacional vamos ahora preguntarle algo sobre el sobrevento mañana tengo un evento a las 3 pm con julie y nico digamos vamos a ver qué pasa en teoría él debería utilizar este structure y fíjate que acá ya no me envió una respuesta una respuesta como en texto sino una respuesta estructurada porque porque yo le dije que la respuesta tenía que ser estructurada obviamente para estos tipos de agentes que lo que hacen es analizar la respuesta normalmente uno lo pasa por otro agente o por una function calling para pues esos inputs pasárselos a una función o una API o lo que sea y volver a responder en modo texto pero como no le he hecho eso pues simplemente está respondiendo en la forma estructurada entonces dice ah mira nombre evento julie nico fecha mañana a las 3 pm participantes julie y nico él automáticamente extrajo eso del evento vamos a ver qué pasa si lo confundo es decir le hablo del clima y de un evento mmm ayer aunque a veces es muy inteligente cuando le digo ayer dice como para qué lo envío a un agente si ayer ya no es un evento posible y eso puede estar dentro de las reglas a menos que eso sea posible dentro de tus reglas de gente dice ayer tenía un evento en Tokio entonces aquí lo estoy tratando de confundir porque estoy mencionando una ciudad en Tokio a las 3 pm con Ana digamos y aquí por ejemplo ya algo pasó eeeeee ajajajajaj yo creo que tiene que ver más en tiene que ver en que la acá este es error mío y es que la respuesta como lo envié por un básicamente el el acá tiene una forma estructurada de responder esto no es un string y lo estoy concatenando como si fuera un string acá lo estoy poniendo como un final output como si fuera un string entonces como que la estructura de datos se me rompió porque simplemente no esperaba un string y posiblemente esto en el estructura del output sea es una clase con con el model para obtenerlo entonces eeeeee voy a volver a correrlo y lo voy a volver a confundir desde el inicio y luego obviamente aquí ya hay que hay que pues trabajar mucho más para que la gente quede más pulido pero pues enviémosle de inicio este este prompt a ver que pasa vamos a ver fíjate que aquí ahí si como que el le envió una ciudad pero como el mensaje tiene más información de evento que de clima entonces se fue por el por el agente que tiene que ver con analizar los o extraer la información de un evento entonces acá dijo nombre evento Tokio ayer las tres de la tarde participante Ana entonces el mismo el mismo está decidiendo que eso es como lo interesante del triage el mismo decide de acuerdo al texto de acuerdo al historial cuál va a ser el agente que va a tomar pues la conversación vale acá literalmente ya sólo como por ir finalizando yo ya puedo crear otro por ejemplo el super agent y aquí es donde yo puedo poner las tools que ya tiene OpenAI por ejemplo este file search tool que es una búsqueda ya en una base vectorial de archivos entonces aquí esta base de datos vectorial lo que hace es que yo tengo un PDF cargado esta tool esta tool hace parte de las nuevas características de Responses API que si no las has visto te dejo por aquí el video o en la descripción en donde ya hablamos de las nuevas tools que tiene OpenAI en donde se pueden hacer búsquedas en internet o hacer búsquedas privadas esta sería una búsqueda privada con base a un PDF que yo le subí este PDF lo vectorizó pero entonces aquí es donde yo puedo por ejemplo hacer un super agent entonces acá le digo que así como yo le di una tool que en este caso yo tenía la función de esa tool pues yo también ya puedo poner esta tool que sería vaya y busque en un espacio vectorial en este caso en mi espacio vectorial del first search tool y acá pues ya le puedo decir que hay otro al cual le tiene que hacer triage y entonces también yo podría decirle que si la respuesta se acerca de micrófonos porque realmente el el PDF que tengo ahí micrófonos epa micrófonos no lo manda el super agent listo entonces vamos a ver si yo le pregunto algo de micrófonos pues debería ir a esta base de actus vectorial vamos a volverlo a correr y así yo lo puedo llenar el problema de esto es que pasa lo mismo que pasa con prompts cuando tú a un prompt le pones muchas instrucciones de tantas cosas que le pones empieza como a alucinar a no saber que tal aquí por ejemplo cuando yo ya le pongo tres agentes a los cuales tiene que ser triage pues puede que funcione bien puede que con un modelo de razonamiento funcione bien si yo le pongo un 01 preview pues estos razonan más entonces puede que le meta 20 agentes y con un modelo de razonamiento igual lo haga bien porque los modelos de razonamiento pues actuarán mejor solo que se demoraría más porque le cuesta un poco pensar en base al historial en base a este a cual agente hacerlo pero este es un patrón sencillo que es un patrón de agentes de routing es decir de acuerdo al historial del mensaje saber que agente es el que debe interactuar y esto yo creo que lo facilita mucho este nuevo SDK de OpenAI porque pues simplemente aquí uno pone el handoff y con un prompt pues básicamente está haciendo el triage o saber que agente seleccionar, probemos el de support entonces si yo le pregunto hola como conecto mi transmisor al PC porque este manual es unos micrófonos que tienen un transmisor entonces vamos a ver para conectar necesitaré más información sobre el tipo de transmisor y lo que es raro por ejemplo aquí lo puso como una como si fuera una pregunta genérica cuando en teoría bueno aunque yo le dije que cuando preguntara acerca de micrófonos tal vez aquí el agente de triage no supo que un transmisor es un elemento que está dentro de mis micrófonos y eso hace parte de pues todo lo que pasa en orquestar multiagentes aquí hay que hacer aquí hay que hacer mucho trabajo en prompt probablemente utilizar un modelo de razonamiento y obviamente este prompt no está siendo tan eficiente y hay que mejorar mucho acá pero estamos apenas explorando el framework pero voy a hacerle un poquito más claro o sea le voy a decir que es voy a mencionarle algo de micrófonos hola como conecto el micrófono el transmisor el transmisor del micrófono micrófono al pc vamos a ver acá ya le estoy hablando de micrófonos entonces espero que ya lo mande no todavía si podría especificar el tipo de transmisor no acá se quedó yo creo que nos toca escoger un modelo de razonamiento porque literalmente el debería irse al de support bueno también podría ponerle microphone agent creo que el nombre también le da cierto poder a saber a dónde derivar porque aquí yo tengo en esta base de datos vectorial tengo un pdf con todo el manual de un micrófono y debería sacar la información de ahí pero pero no lo está haciendo no lo está haciendo no lo está haciendo y yo creo que voy a ponerle un modelo de razonamiento el 0 3 mini a ver si mejora y si no pues ya sería un poquito más de prompt obviamente acá también ya aquí hay cosas más avanzadas acá realmente por ejemplo hacer estos home guard rails en donde uno también puede analizar mejor la respuesta y acá es donde entonces quiero ir a esta parte que es orquestar varios agentes no acá ellos tienen el repo como varios patrones y cómo utilizar agents como tool como tener un agente que es determinístico como tener un lar language model como jurado que es otro patrón que básicamente casi que se volvió un estándar el blog de construir building effective agents de anthropic que son como todos los patrones que uno puede encontrar al construir workflows o agentes entonces está el workflow en donde tenemos un gate en donde pasa de una parte a otra el más clásico es que es el de routing es el que por ejemplo estaríamos haciendo ahorita y es que tenemos un un agente de triage y de acuerdo como a ciertas reglas pues él escoge a cuál otro agente llamar y luego genera un output bien este es el que podríamos estar haciendo ahorita que todavía tenemos que mucho que mejorarlo para que responda bien pero este sería el patrón pero hay muchos más patrones como hacer paralización como hacer orquestar varios workers como este sería el este que estamos viendo acá el lar language model como jurado como él se puede auto evaluar y volver al al nodo original para salir otra vez con una respuesta este sería el que se quedaría iterando por ejemplo en fin entonces aquí tenemos varios dentro del mismo documentación de open ai está como algunos ejemplos de cómo hacer routing este routing por ejemplo es el que tenemos acá es el caso que estoy haciendo el de triage solo que acá por ejemplo son tres son tres agentes este es mi punto cuando ya le conozco muchos agentes empieza como a no responder también vamos a ver si con el 0.3 mini que es en teoría es un modelo de razonamiento responde sino ahí si nos toca hacer mucho más prompting o ya utilizar los GANs que básicamente están ahí para optimizar más el agente entonces vamos a cobrarlo vamos a ver si solo con cambiar el modelo sirve y le voy a enviar exactamente la misma pregunta a ver si ya es el triage bien o si no algo estoy haciendo mal ay porque no puedo copiar me está quedando con caracteres esto si ya directamente fallo creo que fue por lo que le puse caracteres a la a la a mi input entonces vamos a ver ta ta ta ta ta ta ta ta otra vez intentemos otra vez le puse caracteres otra vez le puse caracteres ya vamos a ver esta vez como triage le estoy poniendo el modelo de razonamiento vamos a ver si con el modelo de razonamiento se va a demorar un poco más y eso es interesante también que acá mira que acá ahora si ahora si literalmente esto esto hace parte de el pdf que o del pdf de la base de datos vectorial porque esta es la información que yo subía a esa base de datos vectorial que está en openAI recordemos que esto está acá si vamos aquí a platform uno puede subir sus archivos acá en el dashboard uno sube sus archivos acá tengo un pdf que es el manual de unos micrófonos y uno crea una base de datos vectorial en donde adjunta ese archivo y puede adjuntar muchos más y este es la key de esa base de datos vectorial entonces esa es la key que tenemos acá es esta key que tenemos acá en donde automáticamente openAI está buscando en esa base de datos vectorial y le digo que como máximo es resultados de 3 entonces fíjate que acá empezó a mejorar cuando yo al modelo de triage o a la gente de triage le di ya un modelo de razonamiento acá si realmente como que pensó un poquito más se demoró eso es un trade off se demoró pero ya sacó la información y fue y lo derivó al de su port entonces fíjate que de nuevo si yo ya tengo 2, 4 agents en un routing en un modelo de routing funciona pero cuando yo ya tengo algo más complejo 20 agentes posiblemente ya el patrón de triage o aun así utilizando un modelo de razonamiento yo creo que empieza a divagar y a saber que agente debería tomar la tarea en fin entonces estos son varios patrones de los que uno se enfrenta al crear agentes que aquí pues en la documentación está esta forma que aquí ya pues yo creo que podemos hacer casi un video por patrón routing creo que es lo que hicimos hoy que es hacer un triage en este caso nos tocó utilizar un modelo de razonamiento interesante que uno pueda ok el de triage es un modelo de razonamiento porque es el que tiene que pensar un poco más y decidir pero luego ya los otros agentes se pueden ir más livianos podemos utilizar un GPT-4 o incluso esto un GPT-3 que ya no es tan necesario un 3 yo creo que ya por defecto un 4 mini en el caso que queramos más velocidad pero ya no necesitan tanto razonamiento eso se lo dejamos al agente de triage pero luego podemos ver estos otros patrones agentes como tool un agente que es determinístico un agente con patrones un poco ya para tener contexto el language model como jurado etcétera ahora cuál es mi punto de vista acerca de este ese de cada agente de OpenAI realmente de nuevo al utilizarlo se me pareció mucho a CrewAI en donde uno realmente como que fácilmente puede definir como agentes y otro de triage para decidir cuál lo hace y cuál no entonces me parece fácil en cuanto a empezar a crear sistemas de agentes sin embargo desde mi punto de vista cuando uno empieza a tener agentes mucho más complejos más de 40 agentes en un mismo como sistema unos 10 agentes cada quien especializado en alguna cosa en específica que ya utiliza diferentes tools ahí es donde creo yo podría que este SDK se quede un poquito pues en lo básico digamos aunque podemos ver que ellos también tienen ejemplos para lograr patrones avanzados como la paralización determinístico el mismo se retroalimenta y sabe cuándo terminar o no la tarea podríamos examinar cada o ya tú puedes ver cada uno de esos ejemplos y utilizar agentes de SDK de OpenAI para lograr esos patrones sin embargo desde mi punto de vista a mí me sigue gustando el LandGraph sobre todo porque dentro de de todo creo que los patrones que tiene el LandGraph para orquestar son mucho más potentes y permiten un poquito más de nodos complejos sobre todo para complejidad más grande en agentes entonces por ejemplo por ejemplo este es un agente que tiene que en teoría serían como tres agentes sólo que yo puedo controlar mucho mejor cuándo o por qué o puedo tener realmente sistemas de agentes de 30 o 40 agentes y es más fácil orquestarlo es más difícil entenderlo es un poquito más complejo porque ahí necesitas entender el modelo de nodos de grafos de LandGraph y saber cuándo derivar y cuándo no casi que esa decisión te la dejan a ti pero ese poder es súper interesante en modelos de agentes complejos ahora si no es tan complejo tu agente yo creo que y además de eso sólo quieres utilizar OpenAI porque es lo otro obviamente OpenAI sólo puedes utilizar los modelos de OpenAI de pronto en otros tipos de modelos multiagentes quieres utilizar un Gemini para cierto agente pero también quieres utilizar el modelo de razonamiento de OpenAI para otra tarea entonces creo que LandGraph me permite también tener un híbrido de modelos y no sólo casarme con uno en fin ya te lo dejo a tu elección puedes utilizar el Open SDK de agentes puedes ver acá de pronto patrones más avanzados según ellos se pueden lograr patrones como estos y podríamos ya ponerlos a prueba hoy sólo probamos uno el de Routing uno sencillo nos tocó utilizar un modelo de razonamiento para que haga buen routing pero bueno eso es básicamente lo que tenía preparada y realmente hicimos una exploración interesante sobre este nuevo SDK de agentes de OpenAI ahora si quieres más contenido acerca de agentes déjame en los comentarios qué te pareció si quieres que examinemos los otros flujos un poco más complejos para lograr agentes mucho más potentes utilizando igual este SDK o si seguimos con el camino de LandGraph así que déjame escucharte o leerte en los comentarios y suscríbete para más contenido en este canal nos vemos en la próxima