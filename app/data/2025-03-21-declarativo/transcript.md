 En este video vamos a ver dos formas de o estilos de programación que de pronto tú conoces o se llaman allá en la industria, que normalmente es programación hiperativa y declarativa. Los dos approaches tienen sus estilos, sus ventajas, sus desventajas, pero en este video vas a aprender a utilizar las ventajas de uno o el otro, al menos a identificar si estás haciendo programación declarativa o hiperativa, un spoiler alert, casi que en Angular se prefiere casi en general hacer programación declarativa, pero precisamente en este video vas a aprender el por qué, porque de pronto cuáles son las ventajas, desventajas, y para eso hoy traigo a un gran amigo en el cual nos va a explicar acerca de este tema. Así que no siendo más, traigamos al invitado a escena. Hola, hombre, ¿qué tal? ¿Cómo estás? Dime de qué nos vas a hablar hoy, de qué se trata la programación declarativa, hiperativa, qué es este cuento y por qué deberíamos ser importantes. ¿Qué es lo más importante para nosotros? Wow, son muchas preguntas. Bueno, hola a todos. Nada, hoy les voy a hablar un poco de programación declarativa e hiperativa, un poco de, tal vez, les voy a contar una historia, de hecho, de cómo yo me sumergí. Bueno, voy a hacer como un paralelismo, ¿sí? Que en esta historia de cómo más o menos yo me sumergí en estos conceptos, ¿no? Y nada, los vamos a, vamos a ver que probablemente, Nico mencionaba, ¿no? Que se prefiere tal vez hacer programación declarativa en Angular. Sin embargo, vamos a ver que probablemente estamos haciendo en muchos casos programación imperativa, sin darnos cuenta, porque es más o menos lo que nos han venido enseñando. Nada, aquí el título, ¿no? Programación declarativa e imperativa en Angular, son los temas que vamos a tocar hoy, ¿sí? Como dije hace un rato, mi nombre es Mauricio C. Torres, soy ingeniero software en Halasoft. Trabajo específicamente como técnica lead de un equipo de desarrollo front-end. Trabajamos por una empresa de Estados Unidos. Hacemos específicamente un antivirus. Nada, soy un apasionado de las comunidades. Soy coorganizador en Angular Bolivia y también en el GDG Cochabamba. Y me pueden encontrar en todas las redes como Combi Mauri. Bueno, para la charla del día de hoy vamos a hablar un poco de imperativo versus declarativo. Voy a hablar un poquito de lo que es el camino imperativo, pero voy a enfocarme sobre todo en lo que es el camino declarativo, ¿ok? Empecemos. Paradigma imperativo, paradigma, ¿qué es un paradigma? Podríamos decir que un paradigma es una forma de conceptualizar y estructurar el código. Este es un concepto como que bien exprimido porque evidentemente podemos encontrar conceptos mucho más complejos sobre lo que es un paradigma. Pero siento que es una forma fácil tal vez de entenderlo. Y específicamente cuando hablamos de paradigma imperativo vamos a encontrar a muchos autores que se refieren a él como una receta. ¿Sí? Cuando escribimos código imperativo estamos escribiendo código que describe instrucciones que se dan paso a paso. Ya vamos a ver más adelante, justamente Nico me compartía un artículo hace poco donde se refutó un poco esta idea, pero vamos a ver que precisamente no hay como que algo consensuado respecto a sus conceptos. Pero nos vamos a quedar por el momento con este. ¿Sí? Y nada, el paradigma declarativo. En vez de agarrar y describir las cosas paso a paso, como diríamos en el imperativo, directamente pide qué es lo que quiere. ¿Sí? Aquí se hace una analogía, ¿no? En el imperativo podemos pensar que es como una receta de cocina donde nosotros seguimos las instrucciones para al final obtener un resultado, ¿no? Y en el declarativo estaríamos solicitando el resultado de forma directa, ¿no? Y a directamente nuestro plato de comida. Por ejemplo. ¿Sí? Se hace mucho esta comparativa, ¿no? Se dice que imperativo es un código que describe cómo se hacen las cosas, mientras que declarativo es código que te dice qué es lo que queremos directamente. ¿Ya? Así que para poder entenderlo un poco mejor vamos a ver algunos ejemplos precisamente que se dan en industria relacionados a estos dos conceptos. Y para eso vamos a ver un par de desafíos. ¿Sí? Vamos a ver el primero. Nos dice... Escribe una función llamada double que reciba un array de números y retorne un nuevo array con los números duplicados del array original, ¿no? Entonces nuestra entrada es un array que tiene ciertos números y la salida va a ser otro array que tenga los números duplicados del array original. Es eso, básicamente. Esta, ¿sí? Probablemente sería la forma imperativa en la que lo podríamos escribir. Tenemos aquí nuestra función. Se llama double. Recibe este array. ¿Sí? Lo itera, ¿no? Y va agregando en un nuevo array los números multiplicados por dos, ¿no? No tiene mucha ciencia, se entiende. Están todos los pasos ahí bien definidos. ¿Sí? Sin embargo, algo que sucede, ¿ya? Es que este es código que nos han enseñado a escribir, ¿ya? Para que lo entienda una máquina. Algo que a mí se me hizo bien interesante, ¿no? Cuando empecé a aprender programación. ¿Sí? ¿Sí? Cuando empecé a aprender programación. Es que te hablan mucho de la lógica de programación y de cómo tienes que cambiar un poquito tu mindset para poder empezar a programar, ¿no? A muchas personas seguramente les ha sucedido que les ha costado mucho empezar a programar. Sin embargo, cuando pudieron hacer ese click, por así decirlo, ya se les volvió muchísimo más sencillo, ¿no? Y esto es debido a que cuando estamos empezando a programar, se nos... Se nos enseña a cambiar un poco la forma en la que pensamos, ¿no? ¿Para qué? Para poder dar instrucciones de forma muy específica a una máquina, ¿no? Yo recuerdo que cuando estaba en la introducción a la programación, ¿no? Y nos decían, vamos a hacer un algoritmo para ponernos una chompa, ¿no? Y se ponía la docente delante de todos. Y uno tenía que dictarle su algoritmo. Y si no eras demasiado específico respecto a las instrucciones, que le estabas dando, de repente no se colocaba bien la chompa, ¿no? Agarraba y... ¿Qué sé yo? Terminaba el abrigo en el piso, ¿no? Y te daban a entender que básicamente lo estabas haciendo mal, ¿no? Eventualmente hacías click y empezabas a programar dando instrucciones muy específicas, ¿no? Y como les digo, esto es como lo haría una máquina, ¿no? Por eso aquí tenemos como que ejemplificado que esto sería algo que entendería tal vez un poco más fácil. Un gatito robot, ¿ya? Es como la analogía que quiero hacer. Sin embargo, yo les decía que cuando programamos de forma declarativa, nosotros damos la instrucción directamente de qué es lo que queremos. Un ejemplo de esto probablemente sería hacer el ejercicio de esta manera. Aquí el resultado es el mismo. Sin embargo, estamos diciendo directamente qué es lo que queremos. ¿No? Que se mapee este array y se devuelvan los números duplicados, ¿no? En un nuevo array. Algo interesante, ¿sí? La programación declarativa es que se asemeja un poco más a cómo haríamos nosotros las cosas, ¿no? Si tú te vas, por ejemplo, a un restaurante y quieres comida, no te metes a la cocina y la preparas tú. No, directamente agarras y haces una solicitud, le dices qué es lo que quieres, ¿no? Y por detrás, ¿sí? Se hacen ciertas cosas, tu comida se prepara y eventualmente la recibes. ¿Ya? Podríamos decir entonces que... Esto es algo que entendería ya no un gatito robot, sino un gatito de verdad, ¿no? Bueno, tal vez no un gatito de verdad. Un gatito de verdad probablemente no te entienda, pero sí una persona, ¿no? Es como se comunicaría una persona realmente. ¿Ya? Tomando esto en cuenta, ¿sí? Vamos a otro ejercicio. Nos dice, escribe una función llamada add que reciba un array de números y retorne el resultado de sumar todos estos números. La forma imperativa probablemente sería esta, ¿sí? Recibimos este array, ¿no? Tenemos nuestro resultado que empieza en cero, iteramos el array, ¿sí? Vamos sumando, ¿no? Los números que están dentro del array, los agregamos a nuestro resultado, al final devolvemos ese resultado. Y como yo les decía, estas serían las instrucciones que entendería un gatito robot, ¿sí? Mientras que si lo escribimos esto de forma declarativa, podríamos agarrar y sacar provecho precisamente. Llegamos a la conclusión de que imperativo probablemente es como la declaración de un robot, ¿sí? Hablarías a una máquina mientras que declarativo se asemeja más a como le hablarías aquí a, no sé, a Jesús. Para poder ejemplificar esto, les voy a contar una historia, les hablaba ya de esto al inicio, ¿sí? Pero antes quiero hacerles un par de advertencias. La primera advertencia es que las definiciones que están por verse dependen del contexto. Nos vamos a poner dentro del contexto de que estamos programando, ¿no? en Angular, ¿ya? Que estamos usando JavaScript, que estamos usando Arix.js, ¿no? Y este tipo de herramientas. Aparte de que yo les decía, ¿no? que los autores realmente no tienen un consenso respecto a estrictamente qué es código imperativo y qué es código declarativo. Así que al inicio de cada ejercicio vamos a poner algunas reglas, ¿sí? Nosotros le vamos a poner, dar como que un contexto, ¿ya? Y la advertencia número dos es que en esta charla no se busca señalar que un paradigma es mejor que el otro. Si bien, este, bueno, Nico lo comentaba y igual lo repetía, ¿no? es que vamos a preferir usar, ¿no? este, un paradigma declarativo. Sin embargo, eso no quiere decir que uno sea mejor que el otro, ¿ya? Les voy a contar esta historia, que es una historia que hice, la hice con Gemini, ¿sí? que se llama el camino declarativo de Lumio, la llama programadora, ¿ya? Érase una vez una llama llamada Lumio que quería aprender a programar, para lograrlo, Lumio se unió a una comunidad tech, ¿ok? donde conectó con mentores y otras llamas programadoras. Sus nuevas amigas animaron a Lumio a construir una app para gestionar sus eventos de tecnología y así iniciar su camino en la programación. Entonces vamos a ver que Lumio empezó con qué, con el camino imperativo. Les decía, vamos a definir algunos conceptos, ¿no? para poder ponernos en contexto. Vamos a decir que cuando hablamos de código imperativo estamos dando instrucciones paso a paso, se hace una gestión manual del estado y hay una mayor verbosidad en el código. Este último un poco es subjetivo, pero en estos ejemplos va a ser así, ¿ok? Sigamos con la historia. Lumio vio su board, tomó el primer ticket, que era construir una lista de eventos, ¿no? y lo inició definiendo paso a paso cómo debía funcionar. Entonces, le ayudamos a Lumio. Vamos a empezar creándonos un componente, el events component, vamos a crear una propiedad, que va a ser el tipo array de techEvent, y bueno, lo vamos a inicializar para que no nos riña el compiler de Angular. Lo siguiente que vamos a hacer es que vamos a asumir que ya tenemos un servicio, un servicio de eventos que se va a encargar de recuperar los eventos, qué sé yo, filtrarlos, hacer búsquedas, paginar temas, todo el tema de eventos alrededor de los eventos, ¿ok? y lo vamos a inyectar. Entonces tenemos nuestras dos propiedades, perfecto. Lo siguiente, ¿no? es que cuando nosotros ingresemos a este componente, probablemente se debería inicializar, ¿no? podríamos, es decir, el array eventos se debería inicializar, debería llenarse los datos. Podríamos tal vez pensar en agregarlo en un hook, ¿no? en un lifecycle hook, en este caso tal vez en el engine init. Y probablemente haríamos algo así, ¿no? Y estoy bastante convencido de que muchos cuando empezamos a programar en Angular, de hecho, hacíamos esto, ¿no? Que incluso puede ser que lo sigamos haciendo, ¿no? que en un hook agarramos nos suscribimos al getEvents del eventService, este asumimos que nos está devolviendo todos los eventos, el valor que nos devuelva se lo asignamos a la propiedad de la clase, ¿no? Entonces esto funciona por buenas prácticas, algo que también tendríamos que hacer, es asegurarnos de que esta suscripción en algún momento muera, ¿no? para evitar el tema de memory leaks. Para eso lo que podríamos hacer es crearnos un subject que sea un subscribe y hacer uso del operador takeUntil, ¿no? para que cuando este subject emita algún algún valor, sí, se muera la suscripción. Y lo siguiente, es que en el onDestroy nos aseguramos de completar como tal esta, este, bueno, disparar como tal este subject para que, bueno, se pueda completar la suscripción, ¿ya? Aprovechando, ¿no? que estamos viendo esto, vamos a ver que podemos mejorar un poco esto de aquí, utilizando las últimas versiones de Angular. Podríamos, en vez de utilizar el operador takeUntil, utilizar otro operador que se llama takeUntilDestroy, ¿no? Sin embargo, vamos a ver que si hacemos esto, nuestra llamita va a empezar a llorar, ¿por qué? porque eso va a tirar un error. ¿Ok? Para poder utilizar el takeUntilDestroy tenemos que estar dentro, ¿no? de una referencia total. Bueno, vamos a asumir que tenemos un convivendCard donde se van a mostrar nuestros información de cada evento, ¿sí? Y así se vería nuestro componente. Esto, en teoría, debería funcionar, ¿sí? Y nada, Lumio va a estar contento, su código funciona, ¿sí? Sin embargo, lo que sucede es que, en la vida real, ¿no? es que empezamos a recibir más requerimientos y de repente este código, que hasta aquí se ve bien, de repente puede volverse más verboso, ¿no? Y se pueden dar ciertas complicaciones, ¿ok? Entonces nos dicen, ¿no? empezó a recibir más requerimientos, ¿no? y vamos a ver algunos de los requerimientos extra que recibió Lumio, ¿ya? Uno es agregar filtros a la lista de evento. Vamos a asumir que tenemos nuestra lista de eventos, que queramos poder filtrar por fecha, por ciudad ¿no?, alguna cosa así. Lo que probablemente podríamos hacer es crearnos una función para filtrar los eventos. En este caso aquí ya estoy directamente creando esa función filtrarEvents, que va a recibir un filtro, vamos a asumir que es un string, ¿ya? Y vamos a asumir igual que nuestra función getEvents, del eventService igual puede recibir filtros no hay ya sabe manejarse y nada esto es muy parecido a lo anterior para y se parece mucho sin embargo vamos a notar aquí algo algo interesante ya y es que tanto en el oninit como en el filtro events estamos asignándole un valor a la propiedad events sí y esto ya puede llegar a ser un problema podríamos decir no qué pasa si agregamos paginación no qué pasa por ejemplo si gramos sorting lo que va a suceder es que para cada una de estas probablemente tenemos agregando otra función que sea sorte benz otra que sea no sé en next page para los events y para cada una de estas probablemente vamos a terminar resignando el valor de eventos ok a entonces nada volvamos a la historia la app crecía en complejidad andina que es otra llamita que es la mentora del umio notó su frustración y decidió guiarlo en el camino declarativo hablamos un poco del camino declarativo vamos a definir en características decíamos que la programación declarativa se enfoca en el que y no tanto en el cómo se consigue una gestión del estado abstraída entre comillas conciso y más legible en este caso a contactarое laください los seguidores me dice que síو que creo que es muy importante, y justamente cuando veamos un poco de la discusión que hay entre autores, respecto a qué es programación imperativa y declarativa, sobre todo cuando aplicamos en Angular, vamos a ver que probablemente en esta última sí están de acuerdo, y es que las propiedades no se reasignan. Veamos, Andina dio una charla en la que decía, debes enfocarte en qué quieres que haga tu aplicación, y dejar que Angular sea a cargo del resto. Ya, Lumi decidió probar este estilo declarativo, empezó a usar el PyPasync, los observados de RxJs, y nada, vamos a ver cómo está el código. Vamos a volver a hacer este componente, pero tratando de seguir un paradigma un poco más declarativo. Vamos a empezar esta vez inyectando el servicio de eventos. Lo siguiente que vamos a hacer, es que vamos a definir la propiedad de events, pero la misma ya no va a ser un array de eventos directamente, sino que por esta anotación nos damos cuenta que esto es un observable, y es la ventaja precisamente de utilizar RxJs. Y directamente le estamos diciendo que events es lo que sea que me devuelva la función que de events del servicio de eventos. Si se dan cuenta, habíamos hablado de que hay una cuarta característica, que es que las propiedades no se reasignan. Para tratar de reforzar esta idea, nos vamos a asegurar de que nuestras propiedades sean read-only, ya que con esto lo que vamos a hacer es que cuando alguien venga y vea el código, va a tener cierta certeza de que esta propiedad de eventService, por ejemplo, es lo que sea que ha dado la inyección del eventService. Lo propio con events, que events es lo que sea que ha dado el servicio de eventos al llamar a la función getEvents, y que esto no se modifica más adelante en el código, no hay una reasignación del valor de esta propiedad. Volvemos a hacer la iteración, de nuestros eventos, ya que hay algo interesante, al iterar como tal un observable, tenemos que pasarle el pipe async. Esto nos ayuda a evitar hacer una suscripción manual, directamente desde el componente. Y como tal, eso es. Nuestro componente ahora es mucho más pequeño, y se sigue entendiendo. Ahí entra la característica que probablemente el código, es medio verboso cuando es declarativo. ¿Qué pasa si agregamos filtros? Lo que podemos hacer, esto es solamente una idea de las muchas formas en las que podríamos hacer esto, es crearnos, por ejemplo, una propiedad filter que sea igual a un subject, específicamente un behaviorSubject, donde al inicio quizá el filtro sea un array vacío. Esto ya nuestro servicio de eventos lo va a entender. Y vamos a crear un sentido de dependencia. ¿Ok? Entre eventos y el filtro. Para crear ese sentido de dependencia nos vamos a apoyar en un operador, en este caso en el operador switchMap. Para poder básicamente cada vez que nuestro subject del filtro dispara un nuevo valor, se actualice lo que es la lista de eventos. ¿Ok? ¿Ok? Utilizando justamente este operador. Y nada, en sí como tal la lista de eventos seguiría igual, probablemente deberíamos tener igual un componente para lo que es el filtro, que se encargaría de disparar un nuevo valor, ¿no? De una u otra forma, en este caso, ¿si? Lo hace de esta manera. Esto podríamos argumentar que es algo imperativo, pero vamos a ver al final igual de que siempre, ¿si? Detrás del código declarativo hay algo de código imperativo, además de que probablemente, nuestras soluciones nunca van a poder ser 100% declarativos. ¿Ok? ¿Qué pasa si queremos agregar paginación? ¿Qué pasa si queremos agregar sorting? Nada, agregamos igual un par de subjects probablemente para eso, ¿si? Igual creamos un sentido de dependencia, ¿no? Con lo que es events. Lo podríamos hacer utilizando por ejemplo el operador combineLatest, ¿no? Donde agarramos y hay una dependencia entre estos tres, con el rato que cualquiera de estos dispara un... un nuevo valor. Se recalcula lo que es la lista de eventos, ¿no? El observable. Y básicamente nuestro template es solamente agregar los componentes necesarios para poder hacer cambios, ¿no? Tanto en el sorting como en la paginación. ¿Si? Eh... Y esta es básicamente eso, ¿si? Si se fijan, el código se reduce bastante. No estamos en ningún momento resignando lo que es el valor de eventos, ni el valor de ninguna de nuestras otras propiedades. ¿Si? Podemos saber qué es event, solo viendo esta propiedad, ¿no? Y cómo está declarada. Y no tenemos que irnos a ningún lugar del código para poder, este... ¿no? Sacar conclusiones respecto a esto. Algo importante, y esto es algo que ya les mencioné, es que muchas, si no es que todas las APIs declarativas, tienen algún tipo de implementación subyacente imperativa, ¿no? Porque por detrás probablemente, ¿no? Estos operadores... ¿Si? Si los examinamos a fondo, seguramente tienen implementación que es imperativa en el fondo, ¿no? Lo importante al hacer código declarativo es saber apoyarnos en lo que es el lenguaje, el framework, la teoría que estemos utilizando, para poder decirles qué es lo que queremos, y que ya ellos, estas herramientas, se encarguen de poder devolvernos eso que le estamos pidiendo. Entonces ya como para concluir un poco la historia de Lumio, vemos que al enfocarse en qué quería, Lumio vio que Angular se hacía a cargo del cómo, ¿no? Sin necesidad de manejar cada paso manualmente. Al inicio Lumio sentía que el paradigma declarativo era raro, además que le tomó tiempo el aprender nuevas herramientas, como los operadores de RxJS, pero cuanto más lo usaba, más sentía que esta era la forma más natural y simple de escribir aplicaciones. ¿Ya? Nada, como conclusión, la app de eventos de Lumio fue un éxito, ¿si? Lumio siguió su camino en la comunidad, ¿ya? Y de hecho, ¿no? De hecho, me gustaría aprovechar este espacio para invitarlos, ¿no? A que si no son parte de alguna comunidad de programación, lo hagan, porque es algo que te ayuda a conectar, ¿no? Con un montón de personas que te dan ideas, que te ayudan a crecer en tu camino profesional, o incluso puedes conseguir amigos. De alguna forma yo pude conectar así, de hecho, con Nico, fue como lo conocí. Y nada, Lumio les da las gracias. Sin embargo... Yo aún no termino, ¿si? Como tal, la idea de preparar esta charla, en su momento, vino dada debido a que... Aquel año pasado, junto con el GDG Coach Abamba, hicimos un evento llamado... Bueno, estuvimos en la organización del evento Dead Fest, aquí en mi ciudad, y quisimos hacer como tal una aplicación, para manejar lo que sea. ¿Sí? Para manejar lo que son los eventos. Esta es como tal la aplicación, ¿si? Estamos empezando justamente a usarla igual en más eventos que venimos realizando, y por eso es que la historia de Lumio es sobre hacer una aplicación de eventos y demás, ¿ya? Y un pequeño demo, ¿no? Aquí tenemos nuestra lista de eventos, ¿si? Aquí cuando tú quieres agarrar y registrarte para un evento de Angular Bolivia, puedes venir aquí y hacerlo. ¿Ya? ¿Ya? ¿Ya? Ahí vamos a... Y como tal la aplicación se encarga de hacer tus registros, se encarga de... Bueno, todo este tipo de cositas, ¿no? Y esta aplicación, en el momento en que se desarrolló, tratamos de que fuera lo más declarativa posible. ¿Sí? Y, sin embargo, algo que quiero aprovechar en mostrarles es que, a pesar de que me enfoqué en seguir un enfoque declarativo, van a notar que yo no uso en ningún momento el PyPasync en los templates, ¿si? A pesar de que en el ejemplo que veíamos en los diapos, sí o sí para evitar las suscripciones manuales estaba usando el PyPasync, en esta aplicación ni siquiera tuve necesidad de hacer eso, ¿no? Aquí estoy haciendo una búsqueda, en ningún momento estoy utilizando el PyPasync. Y ahorita vamos a ver un poco el por qué, ¿no? Vamos a ver un último desafío, que es el agregar signals a lo que es nuestra aplicación de eventos. ¿Ya? Una forma de... No estoy equivocado aquí. Todo está bien. ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? ¿Ya? Todo, todo, todo, todo. Tengo un ratito. Les voy a mostrar algún componente. Y van a ver que estoy utilizando signals, ¿no? En vez de agarrar y usar el PyPasync estoy utilizando signals. Y estos signals. Lo que hago, ¿no? Es que este event service que me devuelve mis eventos, ¿sí? Me estoy aprovechando de la librería de interoperabilidad de RxJS. Definitivamente. Porque normalmente directo en la fabricación. ¿Ya? El cliente va a ver las lemas, ¿no? ¿Desde dónde están? Tiene herramientas de reutilización, que éstas son lo que resaltan, es Magia cloud superior, están en Xcode, DC, ShitUE, Katana, Xcode, no sé si los conoces. Pero con Xcode tengoominio ab Lite que como decía en la contra de la otra mamy 3Game 101, no sé si está Rights quote 요 que artem Seal de plagio. ¿No? y nada esto va a hacer que el uso de RxJS se vuelva opcional en el futuro pero para quienes aún decían seguir utilizándolo, se integrará mejor que nunca en nuestro flujo de trabajo aquí está el mismo ejemplo si queremos agarrar y agregar signals, lo único que tenemos que hacer es utilizar la API to signal de la librería de interoperabilidad de RxJS le pasamos su valor inicial y estamos básicamente hechos aquí dejamos de utilizar el pipasync y directamente agarramos e invocamos lo que es nuestro signal para que nos dé el valor perfecto algunas consideraciones que me gustaría que podamos ver antes de terminar y quiero hacer mucho énfasis en esto ya lo hice pero no es un problema pero es un problema que no se puede evitar pero quiero repetirles que los autores aún no se ponen de acuerdo sobre estos conceptos un ejemplo es para mí como que una de las personas de las que más aprendí respecto a este este paradigma es Joshua Moroney tiene una serie de videos donde habla justamente de lo que es el paradigma declarativo y te da ejemplos te habla justamente de este concepto de no reasignar sin embargo él igual se rige en el concepto de toda la vida por así decirlo que se maneja donde se dice que el imperativo habla del cómo mientras que el declarativo habla del qué sin embargo aquí está el tweet justamente que se me hizo muy interesante este es un thread que pueden encontrar en twitter de Mike Pearson que es autor de una librería muy relevante de hecho para hacer state management en lo que es Angular donde él justamente te dice que el código imperativo no es no son instrucciones paso a paso y tampoco es el qué versus el cómo pero yo leyendo todo el hilo hay una cosa con la que me quedé y es que él justamente finaliza todo este thread diciéndote que es en sí imperativo para él que básicamente el código imperativo es se da a la gente que está en el código imperativo y lo que pasa es que cuando cambias algo que ya está declarado en otro lugar básicamente es eso y si recuerdan cuando iniciamos poniendo en contexto lo que es la programación declarativa pusimos un cuarto un cuarto punto que era que no vamos a resignar los valores de nuestras propiedades y este concepto justamente es algo que igual comparte Joshua Moroney Moroney de hecho tiene muchos videos donde agarra y te dice por ejemplo aquí el primero te dice no este nunca cambies las cosas las cosas tienen que declarar y la gente debería poder ver eso y saber directo en la declaración a qué estás haciendo referencia y aquí tiene otro video que dice justamente the secret to declarative change without reassigning donde justamente igual refuerza este concepto de no agarrar y reasignar los valores de nuestras propiedades a pesar de que ambos no están de acuerdo con la declaración que es la declaración que es la declaración y en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso en este caso o el qué versus el cómo si hay algo en lo que están de acuerdo que es en este concepto en el que decimos en específicamente en angular tal vez que no queremos hacer reasignación del valor de nuestras propiedades y nada ya estoy terminando algunas referencias respecto a todo lo que les he mostrado es bueno ya hablé de Joshua Moroney pero otro pilar para mí es que respecto a programación en angular es Deborah Kurata es una divulgadora que igual es muy buena y eso es todo amigos muchas gracias ya me pueden encontrar en todos lados como con mi amor y éxito sería de esta forma aprendiste cómo implementar programación declarativa y declarativa y tienes ejemplos muy explícitos en angular de cómo llevar a cabo este tipo de paradigma recuerda que uno no es mejor que el otro así que simplemente tienes que saber cómo utilizar cada uno y si no tienes ningún problema aunque normalmente es preferible en angular utilizar programación declarativa así que no siendo más recuerda suscribirte a este canal puedes encontrar muchos más videos y contenido acerca de inteligencia artificial y angular así que suscríbete nos vemos en la próxima