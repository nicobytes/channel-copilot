 Normalmente uno de los problemas clave dentro de un equipo de ingeniería es ponerse de acuerdo y hay una de las cosas que normalmente entre ingenieros a veces como que peleamos y es el formato del código y cómo automatizamos las buenas prácticas dentro de nuestro proyecto. Una cosa es el formato y otra cosa las buenas prácticas. Normalmente dentro del ecosistema de Angular tenemos dos herramientas para esto y luego vamos a hablar de Beyond, si es que lo estoy pronunciando bien, que es una gran herramienta nueva en el ecosistema para ver cómo también podría potenciar nuestros proyectos. Pero sobre todo vamos a ver cómo lo aplicamos a proyectos de Angular porque Angular per se también tiene algunas buenas prácticas que son involucradas en el framework. ¿Cómo podemos automatizar? ¿Cómo podemos automatizar que esas buenas prácticas se estén cumpliendo en nuestro proyecto? Y Angular de por sí ya tiene varias capas de abstracción, o sea Angular per se ya es un framework con algunas buenas prácticas, luego está TypeScript y luego está JavaScript en general, al final la base de todo es JavaScript y luego tenemos HTML, CSS obviamente. Pero ¿cómo podemos automatizar todas esas capas? ¿Seguir buenas prácticas de JavaScript en general? ¿Seguir buenas prácticas de TypeScript en general? Y ya también ¿cuáles son esas buenas prácticas de Angular? Y sobre todo ¿cómo hacemos que el navegador, el navegador no, sino nuestro editor de código nos avise automáticamente y también cómo lo podríamos hacer en un ciclo de integración continua? ¿Qué quiere decir eso? Que literalmente cuando nosotros estamos trabajando dentro de un equipo, pues automáticamente estas reglas detecten, oye mira, este ingeniero no está siguiendo como las convenciones o las buenas prácticas, así que aquí este pull request, esta contribución no es aceptada porque no cumple como con las buenas prácticas. Las normas estándar de buenas prácticas, por ejemplo, una norma base, por ejemplo, en JavaScript es no utilizar Evolve porque es un issue de seguridad. ¿Cómo automatizamos esta detección? Y lo segundo, eso son buenas prácticas, pero también hay otra cosa y es el formato, que nosotros entre ingenieros también peleamos mucho. Es decir, si tenemos que tener doble espacio, si utilizamos comilla doble, comilla sencilla, eso es otra cosa, no son buenas prácticas per se, pero es formato de código. Y también es bueno estandarizar eso dentro de un equipo, dentro de un proyecto, para no estar haciendo commits que realmente no tienen valor. Cuando ya todo el equipo sienta esas como reglas y además las automatiza, empezamos a tener contribuciones más de construir valor que pensar en si esto es una buena práctica o una práctica y entrar de pronto en algunas discusiones innecesarias. Entonces, precisamente en este video vamos a ver cómo automatizar utilizando PreRaw, utilizando ESLint, utilizando Linter directo. Y también vamos a ver cómo automatizar utilizando PreRaw, utilizando Linter directo. Y ver si podemos automatizarlo en un GitHub Actions para poder ponerlo dentro de nuestro ciclo de integración continua. Así que empecemos en el código. Este es mi proyecto en el cual tengo un e-commerce base. Es mi proyecto normal de estándar en el cual me permite probar todo esto y enseñarte a ti cómo hacer configuraciones adecuadas con conexiones a una API real, etc. Acá tenemos algo sencillo. Por ejemplo, acá tenemos como una... landing page de productos por categorías. Acá tenemos como varias categorías. Y voy a hacer clic en uno y pues al final me traigo los detalles de eso, nada del otro mundo. Aquí puedo empezar a agregarlo al carrito de compras, todo normal. Bien. Entonces vamos a ver cómo está el código de esto. Este es el código base del proyecto. Bien. Acá tenemos una simple aplicación con los productos, los detalles, los componentes. Acá, si bien... Vamos a ver que ya utilizo... ciertas features nuevos de Angular. Por ejemplo, utilizo... Pues sigo utilizando HTTP client. Pero, por ejemplo, ya utilizo los resources. Que déjame te los muestro. Por ejemplo, acá. Ya utilizo un link en signall. Por acá ya utilizo... Acá debería estar un resource. Eso, un xresource, etc. Que te invito en mi canal para que veas este tipo de características. Pero aquí lo importante es saber... Primero, en qué versión estoy parado. Estoy parado en... Estoy parado en la versión 19. Sin embargo, también lo que voy a hacer va a funcionar muy bien en cualquiera de las versiones. Porque normalmente esto es un proceso estándar. Bien. De pronto va a cambiar un poco la configuración de ESLint. Que es el verificador de pruebas. De buenas prácticas. Bien. También te voy a recomendar que tengas ciertas extensiones. La más importante, Angular Language Service. También el ESLint. Vas a tener esa también extensión. Vamos a ver que la encuentre. Esta la tienes que tener activada. Sobre todo, la extensión de la extensión de la extensión. Sobre todo para que vaya como resaltando los errores directamente en el editor. Y esta es opcional. Yo, por ejemplo, no la tengo. Que es la de Previewer. Vamos a ver. Acá Previewer. Esa la pueden instalar, desinstalar. Pero realmente vamos a unir bien ESLint y Previewer con Angular. Entonces vamos a ver que va a quedar igual muy bien configurada. ¿Listo? Entonces, lo primero es lo siguiente. Si nosotros vamos a ver algo. Vamos a ver. Por aquí. Acá hay algo que Angular ha estado lanzando en sus últimas versiones. Que son migraciones. Estas migraciones nos permiten automatizar cosas. Dentro de estas migraciones también se incluyen buenas prácticas. O normalmente se están empezando a incluir como detección de buenas prácticas por defecto. Sin añadir nada más extra. Por ejemplo, una que sí solo está desde la 19 en adelante. Es esta. Clean use. In use imports. ¿Qué significa esto? Es que. El va a detectar automáticamente algún import que no estemos utilizando en el template. Y literalmente lo va a quitar. Porque simplemente para que estás importando un componente que no estás utilizando. Vamos a ver un caso. Como yo estoy en la versión 19. Sin necesidad de ESLint. Sin necesidad de Previewer. Sin necesidad de ninguna configuración. Así solito como viene Angular. Esto ya viene configurado y lo podemos ver acá. Lo podemos ver en la terminal. Cuando tú corres una vez. Un ng serve. Lo puedes ver acá. Por ejemplo. Déjame te lo muestro acá. Acá lo puedes ver. Fíjate que. Acá hay como un warning. Dice. Header component is not used with the template of list component. Significa que literalmente. Este componente no está siendo usado dentro del template de lista. De list component. Bien. Y acá me dice. Mira. Este componente header no está siendo usado. Lo importaste. Lo inyectaste. Todo ese tipo de cosas. Pero no lo estás usando. Entonces. Esa ya de por sí es una buena práctica. Lo podemos también mirar directamente. En nuestro editor. Acá está. Entonces vamos a ver por acá. Si yo voy acá. Este list component. Literalmente acá me está diciendo. Mira. Header component. No está siendo usado. Lo importan. Lo tenemos importado. Dentro de. Pues dentro de nuestro componente. Pero si realmente yo voy y. Fijo y me miro. Pues no estoy nunca utilizando el header. Dentro de mi lista de componentes. Entonces es algo que importé. Y al final nunca lo usé. Entonces es muy bueno limpiar esas. Como seguir esta buena práctica. Y si simplemente no lo utilizo. Pues automáticamente. Pues debería quitarlo. Simplemente con estar parado en la versión 19. Esto ya debería funcionarte sin problema. Bien. Sin embargo angular no sólo se queda ahí. Digamos que tú tienes muchos de estos casos. Digamos que realmente tienes muchas. Te pasaste la versión 19. Y en automático como que. Él te descubrió muchos de estos casos. Pues ahí es donde tenemos una migración. Entonces. Si nosotros corremos esta migración. En automático. Nos va a limpiar todas esas importaciones. Casi lo que yo hice aquí manualmente. Que sería quitarlo dentro de la array de imports. Y pues quitar el import declarativo. De pues de las líneas. Iniciales. Bien. Entonces en automático va a ser este trabajo. Que normalmente. Nos tocaría ir por archivo por archivo. Y pues automatizar esto. Estando en la terminal. Entonces vamos a correr el comando. Y en automático. Entonces él va a analizar la aplicación. Analizar todos los archivos. En este momento. El link que incurre en esa mala práctica. Es sólo un archivo. Entonces pues él hace automáticamente el ajuste. Si voy de nuevo a mi. Pues a mi proyecto. Y por ejemplo utilizo JIT. Para ver cuáles fueron los cambios. Pues aquí veo que al final. Se han quitado los cambios. Y simplemente. El import declarativo. Entonces aquí ya estaríamos. Haciendo algo de automatizar buenas prácticas. Esto lo trae ya Angular en la versión 19. En automático. Pero vamos a ver que más podemos empezar a automatizar. Angular como tal. Tiene unas guías de estilo. Se llama Angular Coding Style Guide. Esto básicamente son como algunas reglas. Convenciones. Que normalmente los equipos de ingeniería en Angular. Dentro de Google. Dentro del mismo equipo de Angular. Y entre mucha colaboración. Pues se han creado como unos estándares. Estos estándares suelen cambiar. Y Angular está como siempre innovando. Por ejemplo. Se está ahorita repensando. Si realmente todos los componentes. Tienen que llevar el sufijo. component.py Que yo realmente estoy de acuerdo con. Que tengan ese punto component.service. Porque es fácil de leer. Y saber antes de entrar al archivo. Pero esta. Por ejemplo esta convención. Ahorita se está pensando. Todavía no la han quitado. Directamente. Pero hay un RFC. Para ver si se quita o no. Que piensa la comunidad. De nuevo. Esto no está escrito en piedra. Normalmente. Pues hay varias reglas. Sin embargo. Hay otras convenciones. Que sí. Como que siempre todos usamos. Por ejemplo. El naming de las variables. Acá nos dicen cómo nombrarlas. Etcétera. Entonces normalmente. Todos los equipos. Que trabajen con Angular. Normalmente deberíamos apegarnos. Hasta estilo de código. Si hablamos de Angular. Per se. Bien. Acá podemos ver. Varios. Varios. Por ejemplo. Ejemplos. Acá. Como. Estar. Templates. Estar. En su propio archivo. Bueno. Hay varias prácticas. Ahora. Qué podríamos hacer. Dentro de nuestros equipos. Podríamos decirles. Oigan. Este. Estén pendientes. De esta página. Y de las buenas prácticas. O empezar a automatizarlo. Por defecto. Que. El editor. O una herramienta. Nos ayude. A detectar. Cuando se está. Incumpliendo. Alguna de estas reglas. Entonces. Esto es lo que vamos a hacer. Automatizar. Que se cumplan. Estas reglas. No sólo. Las de Angular. Per se. Sino también. Las de ESLint. ESLint. Es. Otro. Helper. Que nos podría ayudar. En automático. A. Haciendo. Análisis. De código estático. Saber. Si estamos incurriendo. En algún problema. De JavaScript. Bien. Y. En algún. Título. O. Algo. Que. Tiene. Bastante. Sentido. De por si. Unos años atrás. Había. Un. TSLint. Pero al final. Se unieron los proyectos. Y todo quedó. Con. ESLint. Sin. Problema. Entonces. Básicamente. Acá tenemos. Como. Reglas. En donde. Podemos. Encontrar. Y. En. Nuestros. Proyectos. ¿Cómo. Se hace eso? Pues. Hay un paquete. Muy interesante. Eh. Que oficialmente. O sea. No está dentro de. No es mantenido. Dentro del equipo. De Angular. Pero es como el más usado. En la comunidad. Ese. Es este paquete. ¿Cómo. Se agrega. El linter? Normalmente. Angular. Tiene un comando. Llamado. En. Yo. En. El. Paquete. Que deberíamos. Instalar. Y la forma. De instalarlo. En automático. Realmente. No tienes que hacer. Ninguna instalación. Más. Solo correr. En. Y. Si no tienes nada. Configurado. El. En automático. Te va a decir. Mira. Debes correr. En. Angular. Y. Es. Lint. Lo dices. Que sí. Vamos. A. Instalar. El. Paquete. Y vamos. A ver. Qué configuraciones. Me hace. Per se. Deberían. Normalmente. Instalar. Una. Dependencia. Para. Y. Es. Lint. Y. Fíjate. Que también. Me está creando. Un. Y. Es. Lint. Config. Vamos. A. Lint. Y. A. Lint. Y. S. Fíjate. Que. En. El. Lint. Es. Una. Regla. Aquí. En. El. Linter. En. El. Cual. Automáticamente. Ahora. Va. Y. Busca. Este paquete. Angular. Y. Es. Lint. Y. TypeScript. Y. Es. Lint. Ahora. Algo. También. Que. Me. Agregó. Es. El. Y. Es. Lint. Config. Este. Si. Es. Súper. Importante. Porque. Acá. Es. Donde. Nosotros. En. General. Las. Reglas. De. TypeScript. Y. Luego. Las. Reglas. De. Angular. Todo. Es. Configurado. Con. Y. Es. Lint. La. Base. De. Todo. Es. Y. Es. Lint. Que. Es. Es. Es. Es. Súper. Importante. Para. Ver. El. O. La. A. La. L. En. Mi. M. S. L. N. S. F. S. S. I. S. N. I. I. S. y es config y ahora lo que deberíamos hacer una vez terminado eso es volver a correr el pack y el comando y angel int y acá esto es precisamente lo que queríamos ver esto es la detección automática de algunas prácticas o malas prácticas que yo estoy incurriendo y vamos a ver qué es lo que me dice por ejemplo en list component me dice que yo no estoy utilizando una variable llamada resource vamos a ver qué es eso list component entonces vamos a ir al componente list component Acá vamos a ver acá si literalmente me dice mira acá hay una importación de resource que no estás usando entonces pues simplemente lo soluciona acá está angular common no se puede encontrar qué raro aquí es este error este si no tiene nada que ver está raro que puede ser caché de mi editor pero vamos a ver este import deberían ser en este si está raro en cuanto a que acá tengo como mayor producto componen y un router link de pronto este router link no va acá porque ya viene en el común de generar no no realmente no es eso que vamos a volver a pasar la regla para saber si sólo era el resource Acá por ejemplo ya no me sale el rol de los taus pero algo se está pasando en mi editor yo creo que es más eh mi editor y tengo como que reiniciarlo porque no está corriendo bien las reglas o sea no está detectando estar se está trancando con algunas otras reglas por ejemplo no está encontrando angular common que angular common es como pues es la dependencia entonces ahorita voy a reiniciar rápidamente mi editor y ver que esto pues no me salga aquí ya reiniciando mi editor si me di cuenta que literalmente tenía mal configurado el pad en donde estaba abriendo mi editor editor en este caso estoy utilizando cursor pero acá fíjate que ya no me aparecen otras reglas donde no están contando los módulos pero si volviera a poner el resource ahí si me sale otra vez el error y este error si me dice oye mira esto es un error que sale desde el ESLINK entonces simplemente si te ocurre esto reinicia el editor o mira que estés en el pad indicado yo no estaba en el pad indicado y por eso me salía en error pero listo corregimos ese error pero veamos que no es el no es el único error que tenemos en product detail vamos a ver que tenemos otro error entonces vamos a ver product detail y fíjate que no sólo me recomienda cosas en typos que fíjate que el error anterior es un error como estás haciendo un import inadecuado es más hay otros hay otros errores por ejemplo si yo hago un implement on init por ejemplo me estaría diciendo oye estás y si hiciste la implementación de un error en el pad indicado yo no estaría diciendo implementación de una interfaz de la interfaz on init pero nunca la usaste es más si yo lo vuelvo a correr vamos a ver ya debería salirme otra vez como el incumplimiento de esa regla y aquí hay tres errores vamos a ver acá typoscript np function aunque no me está saliendo la nueva no sé si la guardé a ver aquí por ejemplo este on init y aunque acá no me aparece es el int tal vez ahorita angular no está siendo tan fuerte con esto porque esto está como cambiando un poco los lightholes pero si me dice acá que bueno acá obviamente también es porque no le importe es porque no le importe y ya entonces acá ahora si me aparece el error vamos a correr otra vez al ng lint y aquí vamos a ver me aparece acá acá lo que se me dice es que no estoy importando o no estoy correctamente importando una yo quiero interrumpir la argumentación del error este tramo entonces opportunity también Bei pues yo hago clic en aquí nos va a llenar la tabla y como aquí está contando con ello esto menos valor sí si acreditamos a todos porque en este caso si es azar así queda thorough tune ingresamos poco para deafkanal para loops aimos moinsICA y lastre a y vamos a presence luego en ese punto ahí você está completamente alemão accesibilidad entonces por ejemplo acá tengo algo interesante y es que el click de este elemento está dentro de una imagen y esto en teoría es una mala práctica de accesibilidad porque porque normalmente un image no es un elemento clickeable un botón sí un anchor o el a eso sí es un elemento clickeable etcétera y normalmente él dice bueno esta imagen la estás tratando como un elemento clickeable y no tiene los elementos de accesibilidad como lo que si tienen los tags y durante el anchor tab entonces una de dos o las reglas se lo pasas a un boom yo quisiera mantener que clic sea en la imagen entonces si yo quisiera que este elemento sea accesible entonces tendría que hacer varias cosas primero ponerle un tap index en cero luego decirle que tiene que tener el rol botón y finalmente lo que él me pide es que entonces por accesibilidad cuando uno hace tap debería también poder como navegar por el sitio web utilizando el teclado entonces me dice mira no sólo cuando haga clic voy a hacer pues el cambio del cover sino también si alguien está parado o hace focus en el elemento y luego le hace enter pues también debería realizar esa acción fíjate que acá ya también estamos cubriendo partes de accesibilidad y mejorando nuestra aplicación en automático entonces acá ya tenemos reglas en type script y reglas también en html vamos a ver qué más sale si pongo otro link dice que hay un error más en carter vamos a ver vamos a ir a verlo carter por acá está y acá es uno más sencillo y es como tienes un constructor en vacío por qué por qué tienes ese constructor en vacío entonces simplemente lo quito y ya si tienes algo en vacío pues para que lo utilices de la gracia es que el interés esté sano que esté bonito literalmente sin ningún error entonces aquí literalmente una forma ya automática de evaluar técnicas de javascript de accesibilidad de type script y de angular per se simplemente es con este comando y ya lo aprendiste a instalar y sabes cómo correrlo sin embargo falta abrir ahorita lo que hicimos fue buenas prácticas ahora el formato el formato es diferente normalmente el formato es como si yo estoy algún tap acá fíjate que acá no pasa nada y si yo vuelvo a correr el inter el inter no pasa nada me dice que todo está bien porque esto no es un error per se de una mala práctica es un formato entonces por ejemplo si yo utilizo no sé una comilla sencilla en vez de una doble no hay un error que me salte per se y puede sonar chiquito como este tipo de cambios pero realmente es importante por ejemplo el formato también incluye esto digamos que yo programo esto en una sola línea que es totalmente válido es totalmente válido no va a fallar nada sigue funcionando mi código va a seguir funcionando solo que y si yo lo guardo y corro el inter no va a pasar nada simplemente me dice que todo está bien no está mal no está mal pero lo que sí pasa es que deberíamos tener un una sola convención también para formatear nuestro código que todos digamos ok si vamos a utilizar html cuáles comillas vamos a usar cómo vamos a formatear los elementos porque esto acelera mucho la velocidad en cuanto a revisión de código si haces tu code review o si alguna AI también hace code review también le va a ayudar a saber y analizar bien dónde están ocurriendo las cosas bien entonces pues vamos a ver cómo automatizar también el formato que todo siga una estructura que todo se va a compartir con la gente también y vamos a ver por ejemplo cuando yo tengo una línea muy larga pues ya me la divide vamos a ver esto por ejemplo de nuevo yo podría hacer esto sin problema sin problema lo podría hacer me funciona porque al final de cada párrafo se divide a nivel de representación gráfica y lo podría hacer acá estoy como desde alineando un poco mi formato pero de nuevo esto no es problema del linker escribir no solo html también aquí en type scope por ejemplo déjenme ver algún formato aquí ya puse un tap es algo clásico pero digamos este por ejemplo este esto es un arrow function realmente como es un arrow function yo podría ahorrarme este paréntesis porque pues si sólo es un solo un solo parámetro pues lo dejo como state bien vamos a ver qué otras cosas puedo como medio modificar que yo vea que que podemos como medio desordenar y ver que cuando le apliquemos el formato va a dejar todo en un solo como una sola forma no entonces por ejemplo yo puedo poner esto acá y muchos podemos programar así y no está mal realmente pero de nuevo todos deberíamos seguir un mismo formato y esto es lo que las herramientas pues nos ayudan y entonces yo voy a poner aquí un parámetro y voy a poner aquí un parámetro digamos acá va a colocar un enter como muchos espacios acá bajar un espacio por acá y que más puedo así como medio hacer otro código como medio complicado vamos a ver algún componente no está sencillo este está un poquito larguito digamos que yo también podría meter esto por acá digamos literalmente lo podría meter acá en fin no puedo escribir de muchas maneras espacios meterle aquí por ejemplo podría poner esto así no es decir tengo que poner paréntesis es que el código de por sí está muy ordenado el que estoy escribiendo por defecto pero creanme que el código bastante desordenado en otros proyectos este por ejemplo está un poquito ya más grande pero no está desordenado por se pero podríamos desordenar un poco pero en fin saben a la que un poco me estoy refiriendo con esto como que muchos podríamos escribir de diferente manera un if de diferente manera con espacios sin espacios con un enter por acá en fin no entonces vamos a ver que si yo corro el inter esto me dice que no tengo errores que está todo bien porque realmente no estoy incurriendo en una mala práctica realmente no estoy dañando el software pero si de pronto estoy incurriendo en espacios donde no los hay estilos de código donde no los hay etcétera ahí es donde entra el primer primer es el formateador por defecto que nosotros tenemos entonces este es un formato bien lo que va a hacer es literalmente alinear todo y literalmente aquí lo muestran muy bien en el logo no como que todos podemos escribir como de diferente manera y ahora todo lo vamos a ordenar y todos seguimos una misma estructura y la gracia es automatizar este tipo de cosas bien acá nos dicen cómo instalarlo y pero pues y yo aquí ya tengo el comando para la instalación entonces vamos a instalarlo de esta manera pre-order punto save death listo y ahora simplemente lo único que tenemos que hacer podríamos crear un nuevo comando dentro de nuestro código o sea ese lo podemos poner por acá en el package acá y este sería el comando entonces format y acá lo que yo hago es que yo voy a poner escribir write como de escribir formatear y le digo desde donde yo quiero solo formatear todo lo que esté dentro de CRC pero realmente a mí me gusta también dejarlo en todo porque hasta los JSON también los podemos formatear los archivos de configuración vamos a correr ese comando punto format y fíjate que el analizó todo todo el código y lo vuelve en un solo formato vamos a ver qué cambió vamos a ver que acá vamos a ver que acá vamos a ver que acá literalmente vamos a ver el HTML el HTML ya me lo limpió fíjense que recuerden que yo había tenido como lo había dejado en una sola línea esta imagen lo había puesto como también como en una línea y medio desordenado acá card service acá esto es algo que él me dice y es como por convención deberíamos siempre poner los paréntesis en fin fíjense que varios de los daños como que hice y como ya tenía prioridades pues simplemente lo volví a hacer volvió a organizar acá también tenía estos parámetros y volvió en una sola línea etcétera entonces en automático ya está ahora también hay un archivo de configuración sólo que éste no va tan automatizado nos toca hacerlo manual hay un archivo de configuración que es el siguiente vamos a crearlo por acá casi está al lado del ESLIT config se llama printer.prerrc.com y es el config se llama printer.prerrc.com y es el config se llama printer.prerrc.com y yo el que te recomiendo normalmente es este este es como el oficial y aquí es donde tú puedes definir de pronto ok estas son como las convenciones por defecto pero aquí es donde tú puedes como ajustar algo digamos acá el single code single code es comilla simple por acá el arrow parents el trailing comma bueno si queremos utilizar dos espacios creo que en encarta había puesto un como varios parámetros y aquí tenemos el pero pues él ya lo deja a dos a dos taps no aquí yo podría hacer ese tipo de configuraciones quiero que todo sea a cuatro taps no sé no entonces ahora el todo lo va a formatear a cuatro taps por ejemplo acá está sólo a uno vamos a volverlo a formatear y ver cómo ahora como lo cambia a cuatro taps y cómo lo formatea entonces vamos a poner format obviamente cambio muchas cosas y ahora como que lo le tiene un tap extra y todo como que lo hizo un poquito más allá porque es parte de la configuración que nosotros tenemos pero realmente a mí me gusta más el formate en dos entonces lo voy a poner en dos otra vez para que coincida con el que normalmente tenemos en visual studio code o normalmente en javascript esta es como la preferencia de nuevo si tú dentro de tu equipo tienes otro pues no hay problema simplemente lo ajustas y ya lo voy a dejar ahorita con esto y ya lo voy a dejar ahorita con esto y ya lo voy a dejar ahorita con el tap de dos y con eso pues es como viene nuestro código bien sin embargo hay una dificultad aquí cuando instalamos preer como que lo instalamos de forma aislada de ESLint y a veces los dos pueden chocar es raro pero a veces los dos pueden chocar qué significa que de pronto ESLint te sugiere algunas cosas pero preer luego te lo formatea en otras y pues no está bien que las dos peleen deberían convivir las dos si bien una es para verificar buenas prácticas y la otra es para formateo pues deberían convivir las dos y no pisarse las reglas entonces ahí es donde tenemos que también añadir una configuración para que los dos se integren bien esa configuración donde la encontramos esa configuración la encontramos acá ESLint Integrations entonces nos dicen miren si queremos que los dos funcionen bien tanto el linterno y el linterno como preer pues tenemos que instalar como esto en donde él va a ser si instalamos esto básicamente este paquete lo que hace es hacer off de algunas reglas que sean necesarias y que pueden tener conflictos con preer acá también pues este es el plugin y acá agregamos un ESLint para que los dos convivan bien y sobre todo para unificar los comandos quiere decir que cuando yo corra lint fix o el ng-lint que es el linterno también voy a formatear entonces ya no tendría dos comandos como que unifico los comandos entonces vamos a instalar estas dependencias para unificar todo entonces ¿qué vamos a tener? ¿qué vamos a instalar? vamos a instalar lo siguiente vamos a instalar preer ESLint ESLint Config Preer y ESLint Plugin Preer eso es lo que hay que instalar que son estas literalmente son estas ESLint Config Preer ahí está y ahí está es esta ESConfig Preer Preer ESLint es esta Preer ESLint y el plugin esta es si yo me quiero poner un poquito más fuerte con los estándares pero vamos a instalar estas tres de acá entonces le digo save dev lo corro, lo instalo entonces va a instalarlo y ahora lo que tengo que hacer es unificarlo con mi archivo de el ESLint entonces vamos a esperar que se instale y aquí en este archivo de ESLint me traigo esta importación me traigo ESLint Plugin Preer que es lo recomendado y pues bueno le pongo un nombre a eso y fíjate que aquí aquí así como traíamos las reglas de JavaScript las reglas de TypeScript las reglas de Angular per se pues ahora también vamos a configurar bien las dos cosas y lo único que tenemos que hacer es poner acá en esta parte vamos a poner esta configuración ESLint Plugin Preer Recomended bien eso es básicamente lo que tenemos que poner y tienen que tener cuidado de no ponerle estos tres puntos el Spirit Operator simplemente lo ponemos así Recomended también hay otro creo que hay otro que es como el más fuerte pero vamos a utilizar el recomendado y ya qué quiere decir esto que cuando nosotros entonces ahora hagamos un ngLint ya no necesitamos dos comandos como uno para formatear y otro para verificar reglas sino que ahora todos se corren uno igual podríamos dejarlo o sea podríamos igual correr format sólo para como separar comandos una cosa formatear otra cosa es verificar reglas pero realmente con esta configuración el linter ya nos harían las dos cosas tanto formatear tanto buenas prácticas entonces voy a volver a a desorganizar este por ejemplo y voy a desorganizar el HTML voy a desorganizar por aquí las otras p Invob assigned bugles esto con tab, con tabs acá, y algo muy interesante de unir las dos cosas, es que ahora sí me dice que esto es un error, entonces fíjense que ahora cuando yo desordenaba cosas, como que el editor no me ayudaba, porque pues no estaba integrada, recuerden que eso es lo que el editor me avisa de las reglas, es el plugin de ESLint que tenemos instalado, en el Marplace, este de acá, pero este plugin básicamente no tenía comunicación con las reglas de printer, de formato, pero ahora sí se las dimos, le decimos mira este es el formato, este es el formato en el que debemos escribir el código, entonces ahora también me salen esos errores y me alertan, eso está muy bien, aunque el tab, no sé por qué no me lo alerta, el tab sí me lo alerta, el HTML también debería alertármelo, aquí esperaría yo que me diga, oye no puedes hacerlo, de esta manera, pero vamos a ver si es porque no he superado la línea, también hay una línea, y es como si el tag es muy largo, deberíamos dividirlo, pero parece que en HTML si no me está, no me está, alertando en el editor, pero bueno, vamos a ver si ya con correr ng-lint, él debería verificarme y arreglar, ahora fíjate que acá ya me salen los errores de prir, no sólo los errores de linter, o sea de angular y demás, sino también ahora de formato, y me dice prir, prir, prir, pero no los arregla, ¿qué tenemos que hacer para que los arregle? normalmente lo que tenemos que arreglar, normalmente uno coloca un comando llamado lint, lint fix, y lo que hace es mandarle a este un fix, y con mandarle fix, él sabe que no tiene que arreglar, él sabe que tiene que arreglarlos, ¿qué va a arreglar? formateo, pero también lint, y ahí hay que tener cuidado, porque a veces algunas prácticas si queremos mantenerlas, o sea, de pronto escribir corregir lógica de código, puede ser un poquito más complicado que sólo corregir formato, entonces yo dejaría como los dos, de pronto uno sólo para formatear, uno sólo para como checar, y tendría un poquito cuidado con este, con automatizar en automático, como que me arregle todo, tanto buenas prácticas como formateo, este podría ser un poquito delicado, pero podríamos igual ponerlo allí, podríamos poner punto lint punto fix, y vamos a ver, fíjate que ya me pasó todo, porque él ya hizo el fix, entonces si yo solo corro una ng-lint, ya no debería pasarme ningún error, porque el fix lo arregló, bien, aunque me refiero con que el fix podría ser peligroso en algunos casos, por ejemplo, digamos que acá, fíjate que acá si me dejó el state sin paréntesis, ahí es donde ya se pusieron de acuerdo dando pre-re como is-lint, pero digamos, a ver, una mala práctica de código, o sea, no de formato, sino de código, puede ser un eval, bueno, es que eso sí es fácil, un eval, eeeh, un eval en teoría es una mala práctica, hello, vamos a ver si me dice nada, aquí no me dice nada, claro que no estoy corrigiendo código peligroso per se, pero puedo correr esto, vamos a ver si, qué raro que no me alerte un eval, sí, no me alerta que esto es un eval, tal vez no lo toma como tan inseguro, pero yo sí diría que deberíamos arreglar, o agregar que eval no deberíamos ejecutarlo, o permitir ejecutarlo, porque es casi una puerta para ejecutar código inseguro, eeeh, y yo lo pondría dentro de las reglas, aquí es donde tú ya puedes también empezar a agregar reglas, por ejemplo, yo agregaría que no me deje, que ningún desarrollador pueda hacer un eval, entonces bueno, si esa no estaba por defecto, déjenme incurrir en otra, cuál mala, ah bueno, veamos las malas prácticas de ESLint, y pues, eeeh, cometamos una, entonces acá está la documentación, vamos a ver dónde están las reglas, eeeh, por acá, custom rules, contribute, dónde están las reglas, ESLint rules, acá están las reglas, por ejemplo, vamos a ver, configuration, vamos a hacer las configuraciones, creo que me pasé, acá, acá, vamos a ver, constructor, for direction, get return, eeeh, a ver, vamos a ver qué es esto, acá dice, usar, taladra, taladra, sí, sí, esto, están, están en get, bueno, pero esto es más como para JavaScript, es básicamente que los gets tengan un return, pero pues sí, este también, este TypeScript ya me lo valida de por sí, si un get no tiene un return, pues daría un error, a ver, déjame ver, si yo tengo un getter, de lo que sea, y no le coloco un return, eeeh, get name, ah, pero mira, esta, este es un error, literal, deberían ser expuestos, usando read only, ah, mira, este es uno de TypeScript, por ejemplo, TypeScript, con ESLint, vamos a ver qué regla es esta, aquí ya rompimos una, no es la del return, es una de TypeScript, con ESLint, y es esta, class literal property, me dice, que, o sea, que esto está rarísimo, está en la forma correcta, de hacer un get, de forma estática, debe ser privada, debe ser read only, al parecer, creo que, lo que me está diciendo es que, esto debe ser read only, a ver, pero qué raro, que esté, que esté, que esté, que esté, que esté, que esté, que esté, que esté, que esté, que esté, pero qué raro, que esté getter, esto es un getter, normal, get, name, ok, raro, a menos que ya lo tenga repetido, acá, no, no lo tengo repetido, pero acá estoy incurriendo, en las literal, deberían ser expuestos, usados, read only fields, al parecer, aquí, ya, pues, por regla de, la regla que acabo de poner, estoy incurriendo, en una mala práctica, y, simplemente, con este getter, y, y es como, no debería exponer getters, de esta manera, de por si aquí estaría, la forma correcta, y, debería crear un read only, y, literalmente, acá tengo un get, que es public, creo que, el, lo que devuelve, debe ser read only, porque acá este read on, me lo deja, o sea, este es lo incorrecto, y esto es lo correcto, a ver este, este es otro, correcto, incorrecto, tiene que ser estático, esta regla está rara, ok, no, pero no quiero que sea estático, quiero hacer un get, debe ser un get calculador, vamos a ver si puedo hacer un get, que, por ejemplo, haga total, ah, claro, ya, listo, ya sé cuál era la mala práctica, acá es, si yo devuelvo un string, de forma directa, me dice que, debería ser de tipo read only, o que yo no debería hacer esto, yo no debería, hacer un return, de algo, que no sea, de forma correcta, o sea, que no sea, de forma correcta, o sea, que no sea, un return, de algo, hacer un getter, que al final, devuelve algo, que, que no es una variable, per se, si no es algo directo, si no, entonces, póngalo en una constante, para que lo pone dentro de un get, si, realmente, eso nunca va a cambiar, o está definido, y siempre va a ser cart, entonces, aquí ya hay una buena regla, fíjate que acá ya, claro, yo pensé que era, un get, en cuanto a, estaba mal la escritura, pero lo que me está diciendo, es el return, y eso sí es una buena regla, entonces claro, acá si yo ya le pongo total que da suscripción, por ejemplo, y acá pongo bueno, digamos que le pongo name, ese sí sería un error de naming, pero bueno tan allá no va, no analiza las funciones, pero aquí si ya me dice, ok, claro, es una variable, ahí sí hace un getter, sin problema pero fíjense, ahí ya habíamos caído en una mala regla y el mismo me dijo cuál y por qué, y ahí me da los ejemplos entonces cosas de ese estilo, acá fíjense que tenemos las reglas de JavaScript, pero también tenemos unas reglas de TypeScript, entonces ya estamos funcionando cuatro niveles de reglas, yo creo que cinco niveles de reglas, TypeScript por definición ya es un rule, y déjenme con eso voy cerrando al menos esta primera parte, entonces aquí literalmente estamos uniendo casi cinco capas de buenas prácticas de forma automatizada TypeScript ya por definición es un checker de buenas prácticas como que yo no puedo hacer una suma de un entero con un string eso me daría un error, y no es que el inter me lo esté haciendo eso es ya TypeScript y su type checking de buenas prácticas eso casi que ya lo tenemos por definición en Angular, pero entonces tenemos la capa automática de TypeScript tenemos las migraciones que ya están saliendo analizar código y de pronto reducir y aclarar buenas prácticas eso lo vimos por ejemplo al remover imports que no están siendo utilizados ahora con el inter, con el inter le pusimos una capa para evaluar buenas prácticas de JavaScript, buenas prácticas de TypeScript bien, y las prácticas de Angular per se las que siguen el código, el estilo de código que uno debería hacer, entonces analiza ya esos thread sets, y luego el formato que todos escribamos en una misma convención entonces ahora si tu corres ng-lint va a detectarte en un proyecto que no tenía esto esa es una de las dificultades, cuando tú no tenías nada de esto y corres el ng-lint activas van a salirte normalmente un montón de errores de formato, de buenas prácticas, de por qué estás haciendo esto deberías hacer esto por seguridad, porque así el código es más resiliente porque esto es una mala práctica debido a esto, cada regla tiene su propia explicación y te dicen el por qué, tú puedes habilitar, deshabilitar algunas habilitar otras más, ser un poquito más fuerte, pero con la configuración que tienes ahorita, ya está bastante bastante bien, para seguir un estándar y muy buenas prácticas dentro de tus proyectos en Angular, ahora tú podrías correr el ng-lint y lo puedes correr en tu máquina el paso más es automatizarlo dentro de tu ciclo de integración continuo el paso más es automatizarlo dentro de tu ciclo de integración continuo es muy interesante porque entonces en automático se corren las reglas no se va a automatizar la solución de las reglas porque no es como que en automático se haga un commit en integración continua sino que te va a hacer un checker, lo vamos a correr en modo de revisión y si alguno de los ingenieros rompe alguna de las reglas pues va a alertar y al menos va a decir que está incurriendo en una mala práctica y podemos simplemente hacer que el ingeniero lo corrija antes de integrar realmente eso en nuestro código