 En un video anterior dentro de mi canal vimos cómo configurar Rearer y Slint y las buenas prácticas de Angular con el comando ng-lint. Sin embargo, vamos a ver cómo se automatiza esto en un proceso de integración continua. En mi caso lo voy a utilizar haciendo JIT Adaptions, lo voy a utilizar JIT Adaptions, pero normalmente tú deberías ver cuál es tu proveedor o tu repositorio, por ejemplo si utilizas Bitbucket, JIT Lab y mirar cuáles serían las configuraciones. En mi caso de nuevo voy a utilizar JIT Adaptions. Entonces lo que vamos a hacer es que ya teniendo como toda esta automatización de pruebas, sobre todo en local, vamos a ver cómo lo podemos correr en un ciclo de integración continua para que cuando cualquier ingeniero o desarrollador quiera integrar algo de código, quiera contribuir algo de código, tenemos que cumplir con todos los estándares y si no se cumplen, pues el pull request va a ser rechazado. Así que veamos. Aquí en este repositorio de prueba vamos a abrir una nueva rama, entonces voy a ponernos el fill, y vamos a poner un feature en el que estoy trabajando, un branch en el que voy a trabajar. Voy a agregar algo de código, entonces por acá voy a abrir, aquí mi estructura es un monorepo, si tú estás trabajando en un repo per se, no te preocupes, simplemente hazlo en tu repositorio y ya. Simplemente tengo un folder dentro de otro, nada más. Luego espero ampliar un poco que es un monorepositorio y de pronto monitorearlo ya con una herramienta. No es una herramienta más especializada como NGNX, pero por ahora simplemente es un proyecto dentro de otro proyecto, un folder dentro de otro folder. Ok, entonces acá voy a agregar algo per se. En locations, por ejemplo, yo tengo aquí un HTML que aparentemente está vacío. Sí, acá está vacío, locations, ahí está. Y al parecer ni siquiera está en el routing. No lo tengo en el routing, locations no está en el routing. Perfecto. Entonces vamos a trabajar, digamos acá. Lo primero que voy a hacer es eliminar el CSS porque no lo estoy utilizando, por ende entonces aquí no le hago referencia. Y hagamos cualquier cosa, realmente no me quiero trancar mucho acá. Voy a poner aquí un listado de cosas. Aquí vamos a poner un listado. Es más, por acá me dicen, sí, voy a utilizarlo lo más como, fácil posible, por ejemplo, voy a llamar a la API que tenemos de locations en Raph API de Platzi. Vamos a ver rápidamente aquí tenemos locations, un endpoint que me bota locaciones, entonces simplemente me voy a poner acá. Listo, locations, unsubscribe y ya. Aquí ya de por sí me está alertando varias cosas. Digamos que yo lo deje así, digamos que es más, si yo corro esta aplicación, vamos a ver acá, voy a poner esto y tengo que hacer un list. Esto sería algo clásico, digamos, dentro de Angular. Y aquí ya hay muchas malas prácticas. Hay un any, realmente esto es un componente y normalmente las llamadas al servicio deberían estar dentro de un servicio per se y no dentro del componente. Pero pues vamos a ver qué ocurre. Entonces acá pongo un ul. Y pongo un li y listo. Por ejemplo, acá es un for del antiguito. Podríamos pasarlo al nuevo for locations. Y le voy a decir que no quiero ir a ningún lado, simplemente que me imprima el nombre. Aquí track, aquí no entiendes por qué aclaro, no estoy cerrando el el el for. Va, entonces ahora voy a unir esto, voy a poner este export default. Perfecto. Y lo voy a unir a una ruta. Entonces acá podría poner y decir que quiero agregar una ruta que es location. Y voy y me llamo a ese componente y listo. Creo que de por sí dentro de nuestra header está ya como la llamada location. Si por acá está, vamos a ver si ya redirecciona y si esto hace algo. Tenemos malas prácticas, pero vamos a ver si mínimo funciona. Aquí ya él me está diciendo que hay malas prácticas, no me está alertando. Bueno, le voy a decir que no, que aquí ya tenía algo corriendo. Y aquí ya me está diciendo algunos errores. Pero vamos a recopilarlo. Qué raro, me está diciendo algo más como de sintaxis con TSLIP, pero vamos a ver. Acá, acá me está diciendo la inyección de HTTP. Acá sí ya me está dando errores de compilación. Vamos a ver por qué es. El inject de HTTP client al parecer no está llegando. Porque. Vamos a ver qué raro que no esté llegando este. No creo que sea por un inject. Pero sí, literalmente dice que no tiene ningún valor. Esta inyección. Uff, qué raro. Locations.component. Ah, creo que no lo hemos importado. Claro, todo el mal lo automatizó y simplemente no hemos importado. Vamos a ver. Acá también me dice el objeto. Bueno, este sí me dice, oye, Locations es un any y dice que no debería utilizar un any. Pero debería dejarme al menos. Y asignarlo quiero romper, quiero literalmente romper la regla, porque de eso se trata de romper la regla para ver si cuando envíe la contribución, pues me lo va a dejar pasar, creo que al menos me compile. Dice el objeto tipo es así, pues bueno, claro que ahorita hay algo, un verificador que si tengo, hasta tenga Prietor y demás. Tengo Stick Mode de Angular, que es el Angular. Esa es otra capa, digamos. De verificación. Si nosotros vemos el Angular.json. Tengo el Stick Mode habilitado que se me hace. No, este no es el, digo el tsconfig. Tengo Stick Mode habilitado. Esto también hace que haya una mayor fuerza de verificación de tipos. Entonces probablemente me toque crear una interfaz. Vamos a crear una interfaz de Locations. Vamos a ver que me devuelve este endpoint como para revisar. Cuál sería la interfaz correcta. Entonces me devuelve un ID, un nombre, una descripción, una latitud y una longitud. Sí. Ahí está bien, un ID, un nombre, una latitud, una longitud y eso está bien. Entonces aquí en vez de poner any, ponemos un array de Locations y vamos a ver acá. Entonces lo que haríamos es también decirle que esto es un array de... Que yo espero que esto me devuelva Locations. Creo que ya solucioné todas las... La mayoría de problemas creo. Locations, acá qué es esto? Esto es formateo. Fíjate que esto, esto es más formateo, pero voy a romper el formateo. O sea, esto, esto sí debería dejármelo compilar porque no es un error de estricto, sino que es un error por el formateo del código. Y realmente quiero cometer un error. O sea, quiero cometer, voy a cometer el error que es el error del formateo. Entonces voy a poner aquí, digamos, uno del get. Entonces voy a crear un getter que retorna un string de esta manera. Este es una mala práctica porque el getter debería tener una variable y no retornar un string directo. Este no debería tomármelo angular como parte del String Mode, pero sí es una regla que estoy rompiendo del linter, del TypeScript linter. Aquí tengo dos. Una de las rotas, una de formateo. Este es un error de printer de formateo. No es un error de código. Él me dice Mira, esto debería estar un poquito abajo de esto para mejorar la lectura. Es solo formateo. Hay que ver muy bien porque a veces uno ve muchos rojos y dice todo está mal. Qué está pasando acá? Pásense aquí directamente el error y dicen esto es por linter. Ah, esto es por esta regla del TypeScript linter. O si fue una regla ya del modo estricto que tiene angular. En fin, al menos esto, si bien tiene errores, debería compilarlo. O sea, literalmente aquí deberíamos tener algo en este puerto. Entonces vamos. Creo que lo cancelé. Entonces vamos a correr el localhost 4200. Recuerda que si quieres saber cómo habilitamos todas estas reglas, te dejo el video en donde habilitamos si es lean, printer y todas las reglas automatizadas, es más, que siguen el angular covering style guide para que en automático todas estas reglas se estén cumpliendo. Ahorita estamos tratando literalmente de romper algunas de esas reglas. Por ejemplo, rompamos una aquí de angular de esta y es, por ejemplo, que no tienen que tener app, por ejemplo, esta es una regla que dice que todos los componentes deben tener un prefijo, así como los de Ionic. No sé si han visto que los de Ionic tienen Ion o los de PryNG tienen ng, creo que es ng o los de Material tienen MT. Todos tienen como un prefijo, no? Normalmente los prefijos de nuestra aplicación es app. Pero si tú quieres que te ponga un prefijo, te lo pones en la aplicación, te lo pones en la aplicación, te lo pones en la app. Y entonces, si tú quieres que te ponga un prefijo, te lo pones en la app. Y entonces, te lo pones en la app. Pero digamos que yo no coloco ninguna. Vamos a ver, debería funcionar. Si yo voy a Locations, ahí están, se me arruinan y dicen la aplicación funciona, pero estoy cumpliendo reglas, estoy cumpliendo una regla que viene automatizada del Angular ESLint, una regla de formato y una regla de TypeScript con ESLint, entonces estoy, solo que estas reglas, si bien las estoy rompiendo y se me está dando aquí en rojo, gracias a el plugin que tenemos de ESLint, que me permite ver de acuerdo a la configuración, recordar que nosotros ya tenemos en este proyecto una configuración que es este, toda una configuración, pues él me está alertando. De nuevo, aquí en la descripción del video te dejo un video en donde hicimos como toda la configuración de las reglas, pero ahora quiero romperlas para saber si cuando yo envié un pull request con este código me lo aceptarían. En automático, debería no aceptármelo, pero pues acá me deja construir. Ok, vamos a crear el commit de esto. Y vamos a hacer un commit, vamos a automatizar el commit, vamos a hacer un Publish Branch y vamos a ir al repositorio en donde está esto. Que eso lo encuentras en Nicobytes y en repositorios. Vamos a ver que acá tengo esto, acá debería haber un branch. Un pull request. Vamos a ver dónde está. Acá está. Por acá debería estar la nueva Locations, Fitch Locations. Ahí está. Ahí está. Yo podría ya empezar a enviar el pull request de esto y ver cómo funciona. Aquí cambié un poco de navegador porque no estaba logueado mi github, pero literalmente acá ya me deja hacer el pull request. Entonces vamos a hacer un pull request. Acá yo puedo automatizar la descripción. De el pull request gracias a github copilot. Entonces me va a generar la descripción. Probablemente me diga, está generando aquí. Pues con base al código, básicamente me queda una descripción. Dice pull request, introduce new location features en el website. Este cambio incluye agregar una nueva ruta, crear un componente y mostrar la data de las locaciones. Haciendo fetch en una external API. Literalmente esto me lo generó github copilot. En automático. El lee los archivos, analiza un poquito qué es lo que está pasando en esos archivos y ya. Entonces fíjate que acá dentro del pull request yo no tengo un linter. No tengo una forma, así como en el editor, que me diga oiga, esto está fallando. Acá hay una mala práctica, acá hay otra mala práctica, acá hay otra mala práctica. Es más, si yo hago un ng build, él me deja hacer la construcción. Si yo hago un ng build, no hay problema, él me deja hacer la construcción. ¿Por qué? Porque al final no hay algo que me permita o me obligue. Claro, lo puedo hacer con husky o cosas de ese tipo, pero no hay algo que me esté literalmente zafando de no cumplir con estas reglas de forma automatizada. Ahora, realmente, para ser honestos, uno no hace un build local. Normalmente esto pasa en un sistema de integración continua. Cuando yo hago un match a main, se hace un build, se conecta con nuestros servidores. Si estás utilizando single application, se conecta con tu CDN, Cloudflare, Netlify, Amplify de Amazon. Si ya estás haciendo servers de rendering, lo conectas a tu servidor de node y lo mandas. Bien, pero fíjate que si mandaras este código a producción y lo mergearas, no hay ningún problema, se puede hacer build. Tu sistema de integración continua enviaría esto a producción y no hay problema. Y realmente tampoco hay problema. O sea, la página funciona, solo que estamos incurriendo en malas prácticas. Y por las malas prácticas, pues no están bien. Bueno, para eso pusimos todas estas señales para que lo notifiquen. Ahora, lo que sí tenemos es un comando llamado ng-lint que sí me alerta y me dice todas estas malas prácticas, que es lo que me, que es lo que tendríamos aquí en el editor con el plugin, no? Aquí sí me está diciendo, como alertando en rojo, cuáles son las malas prácticas que yo estoy incurriendo. Pero también tengo un comando que si yo lo corro, me dice las malas prácticas. Este es el comando que yo quiero correr en github actions, ng-lint, para que no me deje pasar ese pull request. Si él detecta que hay una mala práctica, no me lo deje pasar. De nuevo, aquí en el pull request, inocentemente uno podría revisarlo y alguien que diga que no tenga mucho contexto en Angular simplemente dice no, pues esto está bien. Y no se dio cuenta que de pronto acá había una mala práctica, que esto no estaba cumpliendo con el formato que ya tiene el equipo de ingeniería y que este get tiene una mala práctica per se. Entonces cualquiera lo podría, como alguien que de pronto no sea tan fuerte en Angular o en TypeScript, podría aprobar ese pull request. Queremos que no, queremos que el comando ng-lint corra ya en ese pull request y me lo notifique y le ayude al code reviewer a no aprobarlo porque se están incumpliendo estas reglas. ¿Cómo hacemos eso? Pues simplemente agregamos un getadaction. Yo tengo aquí un getadaction para hacer deploy y como esto es un monorepo, pues de acuerdo a la carpeta que se esté tocando, se hace deploy de una aplicación diferente. Sin embargo, si tú estás manejando solo un proyecto, no hay problema. Simplemente es cambiarle de folder. Voy a crear un nuevo flujo. En este caso es el proyecto website y digamos que voy a utilizar check. Bien, o lint, si, el website lint. Así como tengo uno para deploy, voy a tener uno para linter. Ok, ¿qué tenemos acá? Normalmente le ponemos un nombre. Entonces este es el formato de de un linter. Entonces acá le ponemos website linter checker. Y aquí ya me podría ir, literalmente me podría ir a lo más sencillo, que sería decirle a Cursor que me genere generate, generame, generate, ahora hacemos el búsqueda, generate, generate, un GitHub check, some action to check the engine lint common. Vamos a ver, vamos a ver qué me da. Ahí más o menos me propuso una idea y realmente no está tan fuera de lo que es. Y porque se funciona. Literalmente primero tenemos que decirle. Cuando se corra este GIF of action. Esto lo vamos a correr cada vez que haya un pull request. Ahora me va a decir cuando que pase. En este caso yo tengo un mono repo, entonces pues tengo que colocarle el path a cuál proyecto de todos los proyectos que tengo en este repositorio va a ejecutar. Si tú simplemente tienes un repositorio, pues no pones path, porque al final, pues simplemente es el proyecto por defecto que está en tu repositorio. Así que lo dejas así. No, no te va a dar ningún error. Si tienes un pad, pues lo colocas. Ahora normalmente esto funciona. Haz de cuenta que correr un GIF of action es como si le indicaras a alguien corre el engine lint. ¿Qué necesitas para correr el engine lint? Si yo pienso, necesito Angular y Angular. ¿Qué necesita? Necesita las dependencias. Necesito instalar dependencias. ¿Y qué necesito para instalar dependencias? Necesito el proyecto per se, instalar el proyecto. ¿Y qué necesito para instalar el proyecto? Necesito, si me voy mucho más atrás, pues una computadora con Linux. Y si me voy mucho más atrás, necesito electricidad y ese tipo de cosas. Hay que ver qué necesito. Y ese es el ambiente que yo necesito configurarlo para poder correr el engine lint. Y es lo que es lo que vamos a checar acá. Literalmente le estoy diciendo mira, necesito una máquina. En este caso le estoy pidiendo una Ubuntu. Luego este checkout lo que hace es de acuerdo al pull request me trae todo el código, literalmente hace como un JIT clon, pero con base al pull request, porque recordemos que le dijimos que esto es pull request. Entonces se va a hacer un JIT clon, pero de los archivos asociados al pull request. Luego, ¿qué necesitamos para correr? Necesitamos Node. Bien. Entonces él va a decir OK, necesitamos Node. Instala una versión de Node dentro de esa máquina en Ubuntu. Luego necesita instalar dependencias, entonces normalmente va y separa en este proyecto. De nuevo, si no tienes un mono repositorio, simplemente no le das Work in Directory. Yo sí tengo que hacerlo, pero si no, pues simplemente instala dependencias. Porque cómo? Cómo vas a correr en Jilin? Tienes que instalar las dependencias y eso lo haces con NPM. Normalmente puedes correr NPM install. Pero hay un comando o NPI, pero hay un comando específico como para instalar dependencias en un sistema de integración continua que es SI. Por eso es instalar dependencias en un sistema de integración continua, como el que ahorita estamos desarrollando. Y luego finalmente cortamos el comando. Lo podemos, lo podríamos correr así en Jilin. Sin embargo, recordemos que este es un paquete global que no lo estamos instalando de forma global porque estas dependencias son locales. Entonces vamos a correr simplemente en el primer run link, que también lo podemos hacer en local, si nosotros corremos eso local. NPM run link. Va a funcionar, también corre en Jilin y tiene lo mismo. Bien, entonces ahí está. Ahora qué va a pasar? Hasta ahí queda. Si esto da bien, simplemente le va a dar un check. Si hay algo mal, pues le va a decir que no al pull request. Listo? Y voy a verificar un par de cosas. Voy a compararlo con mi deploy. No estoy seguro si se colocó bien Work in Directory. Sí, a veces simplemente. Yo puedo alucinar colocando malas parámetros, pero creo que se fijó en los otros actions que ya tenía por acá. Work in Directory. Creo que está bien, probémoslo. Entonces vamos a enviar un commit de este, de este action, que lo que me va a asegurar es correr el inter en un entorno de integración continua. Vamos a agregarlo. Vamos a hacer el commit. Vamos a hacer el. El. Push. Y ahora vamos a mirar el pull request. Entonces si yo lo vuelvo a correr. Acá fíjate que ahora está corriendo algo y es bueno, que corre algo que creo que es automatizado, que yo lo habilité en mis repositorios, que es un check de seguridad, pero este es el de nosotros, se está corriendo un website link check, que es el nombre que le pusimos acá. Website link check. Se corrió en el contexto de un pull request. Perfecto. Y si nosotros podríamos ver el detalle de qué es lo que está corriendo. Vamos a ver. Que está corriendo. Ahí está. Acá podemos ver literalmente los pasos que él sigue. Entonces, qué está haciendo? Está seteando el de la máquina literalmente. Acá. Aquí es donde corre un sistema operativo. En este caso está corriendo un Ubuntu 24.04 con un con la versión de largos. El que está en el portafolio de la máquina. El check out es literalmente el clon con base al pull request. Luego está el useNode que es simplemente que esta máquina tenga Node en la versión 20. Luego instaló dependencias. Fíjate que acá está la instalación de dependencias. Se instalaron dependencias y acá ya corre el inter. Y aquí es donde acá falla todos los errores que tenemos, que estábamos corriendo localmente, fallan. Y qué va a pasar cuando esto falle? Pues ya tiene como una una equis y yo puedo configurar acá que si no pasa el inter no me deje hacer pull request. Obviamente yo soy el administrador de este repositorio, pero yo puedo en GitHub Actions se pueden configurar cosas como que sólo un cierto tipo de personas hagan la proof o que obviamente la misma persona que envió el pull request no puede hacer el match en fin, pero fíjate que acá ya tengo algo interesante. Es más. Creo que no sé, no sé si acá él tiene algo muy interesante y es que cuando yo hago code review, como como él saca las líneas y sabe en dónde, qué archivo y en qué líneas, porque así es el formato. Fíjate que el formato me dice en la línea tal, en el archivo tal estás cometiendo ese error, entonces él lo lee y lo pone directamente en la revisión de código. Entonces cuando uno está haciendo code review dice mira, mira, entonces esto está bien. Está bien. Uy, acá hay un error. Acá me dice que el selector bla bla bla. Oye, estás incumpliendo en una regla que está en el style code de Angular. Y acá sigo bajando y es acá. Bueno, este no está tan chévere porque este insert no deja nada. No, no me dice que es un error de printer, pero pues es un error. Y ahí simplemente estás rompiendo alguna de las convenciones. Cuando aparece esto es que normalmente es por formato. Y acá si te da el error te dice lo literal. Deberían ser expuestos usando un filter, etc. Acá si me está diciendo que es un error de lindt de lindt de lindt. Acá también lo puedo ver un poquito. Acá yo puedo ver pues porque falla y si ya puedo ver un poco más a detalle. A esto se es de printer. Esto es una regla de tal. Pero entonces claro, entonces cuando alguien hace el code review ya es más. Ni siquiera el que hace el code review, el ingeniero que mandó esta contribución. Ya sabe que acá tiene una X. O sea, ya sería raro mandar. Oye, me apruebas esto sabiendo que ya tiene una X acá. Nadie te lo va a probar si tiene una X. Porque sería raro. Entonces aquí es donde ya empiezas a decir. Bueno, así haga un no verify o no corre el ng-lint en mi local. Pues el sistema de integración continua no me va a dejar. Y literalmente ya tengo una X aquí en este PR. Vamos a solucionarlo. Vamos a solucionar los errores. Entonces acá le coloco el app locate. Acá formateo. También podría. Vamos a intentar arreglar a utilizar el automatizador que arregla. Vamos a ver si lo arregla bien. Entonces voy a correr en el PMLint fix. Ahí es donde este que arregla en automático. Hay que tener cuidado porque a veces puede que cambie alguna lógica. Pero pues para eso está. Tú para que verifiques que lo haga bien. Vamos a ver fix y si logra hacerlo en automático. Fíjate que no me arregló este problema y este no me lo arregló. Me arregló solo los problemas de formato. Ok, creo que sí se puede automatizar la que arregla también. Los de linter. Pero bueno, los que no, pues ya nos toca a nosotros ir acá. Estos location esto es debería ser una variable. Por ejemplo, yo podría ir a punto location. De por si está aquí eterno hace nada, solo es un ejemplo, pero al menos no rompe. Y bueno, este esto me gusta este map que me está proponiendo acá. Listo, ya tengo arreglado. Al menos no rompo con el estándar, no rompo con el formato. Aquí ya es bueno, ahorita te digo que otra cosa ya habría que revisar, pero ya entonces voy a hacer un commit. Y bueno, ya, ya, ya, ya sé que rompí algunas reglas. Sé que ya no me puedo. Puedo saltar el linter con husky o con no verificó en el commit. No me lo puedo saltar porque ya está como una regla dentro del repositorio de integración continua. Así que no me puedo saltar esa regla, a menos que vaya aquí y lo deshabilite. Pero eso ya sería. Ya sería muy raro que un desarrollador vaya y modifique los acciones. Ya se vería mal dentro del pool. Recuerde por si entonces entonces ya envía otro commit. Ahí está. Y correo súper rápido, correo muy rápido. Vamos a ver acá. A no mentira, todavía está corriendo. Aquí creo que es un falso positivo o es simplemente la interfaz de. De GitHub que no se ha actualizado, pero acá está instalando dependencias con los cambios y va a correr el linter. Bien, y ahí ya debería decirme que todo bien y que ya entonces alguien puede hacer marcha. Entonces, claro, vamos a esperar a que termine. Ahí ya está. Ahora sí me dio bien. Normalmente, después que hace el action, hace un proceso de limpiado, pues tiene que literalmente, así como creó una instancia en Ubuntu para poder correr esto, la tiene que volver a desbaratar y apagar. Entonces es un proceso bastante. Es muy interesante que Github Actions pueda hacer esto rápido, no? Levantar una máquina en Ubuntu, instalar Node, clonar el repositorio, correr el linter y luego apagarlo y ya. No? Por eso es que ahí también a veces los tiempos son importantes. Hay a veces que ahorita en Github Actions y depende del plan que tenga tu empresa o lo que sea, puede haber un tiempo. Entonces si tú por ahora tenemos un proyecto muy chiquito y cuando corras unit testing, que normalmente también corren en Github Actions, los tests se tardan más y a veces hay un budget de tiempo. A veces te cobran los servicios como GitLab o como Bitbucket. Te cobran. Creo que cierto dólar por tiempo. No sé ahorita cómo serán los precios de Github Actions. Creo que hay una gran capa gratuita, gran capa gratuita gracias a Microsoft. Pero creo que si hay unos tiempos en donde claro, si ya te demoras mucho tiempo, ya te cobran un poco el costo de lo que cuesta tener esa máquina prendida para que automatices esto, lo corras y que en integración. Y ahí es donde hablo de los tiempos, porque por ejemplo, si tenemos herramientas que corren rápido, pues al final vamos a reducir ese tiempo dentro de estas máquinas y por ende nos podríamos ahorrar dinero. Entonces cosas como utilizar el nuevo compilador que está escrito en Go, pues en el Angular, el nuevo Builder que está escrito en ESBuild, ESBuild está hecho en Go. Eso hace que la transpilación corra muy rápido. De pronto explorar cosas como formateadores, como PYOM, JS, que corren mucho más rápido que Pure. Aquí tenemos que corren 35 más rápido que Pure. Ahí es donde podríamos ayudar, porque analizaría cuáles son los problemas en menos tiempo de lo que lo hace Pure, porque cobran Rust. En fin, el tiempo aquí sí importa cuando corremos en ciclos de integración continua y cuando nos cobran por ese tiempo. De nuevo, JetAdaction tiene una capa gratuita muy, muy amplia. Entonces no me preocuparía, pero sí es muy interesante que se estén creando herramientas que siempre minifican ese tiempo, sobre todo ahorita con esta nueva ola de Go, de Rust, de construir transpiladores, compiladores, todos basados en Rust, por ejemplo, Rollup, esta nueva Void del del creador de Vue, Void.js, creo que se llama. Void, Void. Vamos a ver, Void. Vue.js. Ya no me acuerdo cómo se llama, pero es de una empresa que creó uno de los creadores de Vue, que es un nuevo parser que está escrito en Rust y mejor dicho, es súper, súper rápido. En fin, entonces fíjate que acá ya vamos a. Acá ya tengo un check, ya tengo un bonito check. Entonces yo sé que, y esto también facilita mucho al control viewer, porque él no está perdiendo tiempo en, no, aquí te faltó un espacio, aquí estás rompiendo la regla número no sé qué, en JavaScript, no, eso ya debería estar automatizado, automatizado con ESLint, con Printer, con lo que quieras, debería estar estar automatizado. Entonces el tiempo del control viewer, pues simplemente ya analizando un poco más crítico el código, no, como y aquí para qué tienes este getName si ni siquiera lo estás utilizando. Ahí sí no hay forma un poco de detectar automáticamente por qué un getName si ni siquiera lo estás utilizando en el template y hay un .map. Esto ya es algo que, un control viewer puede hacer, un humano puede hacer. O herramientas de AI si analizarían un poquito más el código, tratarían como de entenderlo y ya dejarían feedback acá. Es como, y este getName no sé por qué lo estás haciendo. O me podrían decir acá, oye, y aquí me dan un comentario. Por qué estás utilizando, porque no tienes un servicio para esto, porque estás utilizando HTTP client dentro de un componente, porque no tienes eso en un servicio, que es normalmente la buena práctica. Esa es la buena práctica en Angular. Esa no está automatizada dentro de las reglas. Esto sí ya le toca al control viewer, le toca analizar. Pero si tú ves, ya está analizar otro tipo de prácticas más de arquitectura, más de cómo deberías, cómo se mantiene organizada la aplicación. Se puede automatizar si hay algunos otros como Sonar. Igual ya hay algunos con AI que pueden empezar a utilizar. Y pues un poco más de debes seguir esta arquitectura. No debería haber un HTTP client dentro de un componente, cosas así. Y te lo añade. Entonces cada vez el control viewer tiene menos trabajo en cuanto a que puede gastar ese tiempo en analizar cosas más profundas que un espacio y cosas de ese tipo. Pero listo, acá ya quedó. Entonces digamos que yo ya quiero. Bueno, obviamente le dejaría el comentario a esta persona de What the fuck con él. Con esto, no? Porque tienes un GetName si no lo utilizas, bla, bla. Pero dejando eso de lado, digamos que yo ya hago un Merge, confirmo y esta contribución se fue a producción. Ya quedó Merge. Normalmente hay otro ciclo cuando ya algo pasa main, que es hacer el deployment. Si ya pasó y pasó con los estándares, con el inter, con el Brewer y con el check del control viewer, pues ya va, se construye y se manda a producción. Y de esta manera entonces ya tienes la configuración para crear tus reglas en Jifad Actions y automatizar el inter y Brewer y literalmente te van a salir como parte de tus Pull Requests, como parte de las contribuciones que te envíen a tu proyecto. Ahora vas a tener estos checkers para asegurar la calidad de tu código, de tu proyecto y que se mantenga. Y ya el control viewer entonces lo que hace es analizar mucho más a fondo o más temas de arquitectura que simplemente averiguar espacios o alguna regla tricky que por allá estemos incumpliendo de TypeScript o Angular.