 En este video te voy a explicar cómo llevar un proyecto de la versión 15 de Angular hacia la versión más reciente, que es la versión 16. Vamos a ver qué pasos tenemos que seguir en una aplicación que se conecta con una API y utiliza Angular Material. Así que, vamos a empezar. La aplicación que vamos a migrar es esta que vemos en pantalla, de por sí le creé un dominio en Fiber Hosting. Aquí es ng-ecommerce-admin.webpack. Y pues es una aplicación que está renderizada desde el lado del cliente, todavía no hemos implementado nada de server-side rendering, pero vamos a ir incrementándole cosas a esta aplicación. Ahora, esta aplicación se conecta a una API, a la API de Platzi, la Platzi Fake Store API, en la cual nos dan una API de productos, con precios, con categorías, usuarios. Y aparte de eso, pues tenemos todo un sistema de autentificación para, pues, precisamente emular todo lo que sería un sistema de seguridad basado en una Web API. Así que igual aquí te dejo la documentación para que puedas, pues, implementarla o también utilizarla en tus proyectos. En este caso, mi proyecto hace un login. Fíjate que acá de por sí, este es el usuario y contraseña del usuario administrador. Vamos a hacer login. Ahí nos dejan esta pantalla inicial. Este es un proyecto base que voy a ir incrementándole, pues, cosas a medida del tiempo. Y también vamos a crear la landing de este e-commerce. Solo que lo vamos a crear como un proyecto aparte. En este, en esta migración, lo que voy a hacer es migrar el CMS o el gestor de contenidos, que sería este proyecto, en el cual por ahora, pues, tenemos varias rutas y tenemos acá el listado de los productos, es decir, aquí estamos haciendo un request al endpoint de productos. En este caso, por ejemplo, estamos haciendo un request a este endpoint y estamos obteniendo todos los productos y los estamos listando. Igual con las categorías, tenemos cinco categorías e igual con los usuarios, que por defecto hay tres usuarios. Ok. Es una aplicación, como te digo, bastante sencilla. Es simplemente una aplicación que se encarga de administrar como un e-commerce basado en esta API. Entonces, vamos a hacer la migración de esta aplicación en particular, que como vemos, utiliza Angular Material y utiliza, pues, un sistema de tablas y demás. Además de esto, tiene una protección, un sistema basado en login, es decir, si yo hago logout e intento ingresar, es más, voy a ingresar de nuevo, por ejemplo, fijémonos que esto es admin products, entonces voy a hacer logout y voy a intentar ingresar a admin products. Admin products. Como no tengo sesión, él me devuelve precisamente a mi aplicación o al routing inicial. Acá, por ejemplo, tenemos un pequeño book en el cual debería, nos está mostrando en blanco, entonces debe haber un error en el routing, que también lo podemos solucionar en la migración. Pero vamos a ver que debería ir a slash out login. Al parecer no está redireccionando de la forma correcta, pero eso lo podemos solucionar precisamente en la migración. Pero fijémonos que no me dejó ingresar directamente a admin products porque ya tenía una sesión. Entonces, por ejemplo, si yo le hago login, pues ya me deja ingresar, entonces tiene un sistema de protección por la sesión y un sistema de autentificación por JWT, que también si quieres mirar cómo funciona, pues aquí está todo el sistema de autentificación y la documentación correspondiente. Podemos también mirar que si yo escribo la contraseña mal, entonces él me dice que las credenciales están inválidas porque precisamente no corresponde a las que tiene la API en su base de datos de memoria. Entonces, bien, ese es el proyecto base. Vamos a revisar el código y vamos a ver cómo migrar esta aplicación que está en una versión 15 de Angular hasta la versión 16. El código de esta aplicación lo puedes encontrar en mi GitHub, o en mi cuenta de GitHub personal, nicobytes ecommerce admin. Allí voy a estar haciendo las modificaciones, agregándole más cosas a esta aplicación y vamos a crear otra aplicación en otro futuro video. En este caso es para el administrador, pero futuramente crearemos la landing page de esta aplicación, pero sobre todo utilizando servers de rendimiento para ganar rendimiento desde el lado de... renderizado desde nuestro sitio web. Entonces, vamos a hacer que el sitio administrativo siga siendo renderizado por el lado del cliente, pero el sitio ya que va hacia los usuarios, vamos a utilizar Angular Universal para hacer el renderizado del lado del servidor. Así que está muy atento y suscríbete al canal para ver también esos videos. Por ahora entonces vamos a encargarnos de esta aplicación y vamos a ver cómo es la arquitectura inicial de esta aplicación. Veamos un poco el código. Si yo abro el código, básicamente me encuentro con una aplicación como cotidiana de Angular y la gracia es que esta aplicación, como la vamos a llevar a la versión 16, en su momento también hagamos una migración a utilizar una aplicación sin módulos, que es parte de lo que nos está proponiendo Angular en las nuevas versiones, que ya no tengamos, pues, módulos. Entonces, fijémonos que acá tenemos el app module correspondiente, tenemos un interceptor para toda la parte de seguridad, vamos a ver que tenemos, pues, unos guardianes, acá tenemos interceptores, tenemos el módulo de material, de lo que utilizamos de material, luego tenemos unos modelos bases, como por ejemplo el del usuario, el producto, etc. Tenemos servicios que básicamente son los que se conectan hacia la API, sin embargo hay unos que se encargan más de la parte de el estado de la interfaz gráfica, por ejemplo, esto es para el drag and drop del menú, es decir, este que vemos por acá, este que vemos por acá, es el que se encarga de saber cuál es el estado para saber, pues, que cada una de las páginas que estamos renderizando o rutas que estamos renderizando, pueda tener esa comunicación con el otro componente del menú, y eso lo hago por medio de un servicio, ¿ok? Pero vamos a ver los módulos, ¿cómo están los módulos? Los módulos, básicamente, tienen un módulo de admin, un módulo de administración, y utilizamos, pues, las ventajas de Angular, en el cual hacemos lazy logging por módulos. ¿Qué quiere decir esto? Pues que básicamente este módulo admin, que por si tiene el layout, es decir, el menú, el menú que está a este costado, este que está acá, admin, user, etcétera, pues, tiene todo el menú y tiene su routing para luego cargar los demás módulos, es decir, el dashboard, que allí espero en algún momento implementar algunas librerías de gráficas en Angular y mostrar también cómo hacer gráficas en Angular, luego productos, categorías y usuarios. También tenemos el módulo de autentificación, que al final tiene una página, que es la del login, entonces vemos aquí, por ejemplo, que estamos utilizando, pues, el OpenSnackBar, que es de Angular Material, para mostrar, por ejemplo, esos mensajes que vienen como credenciales inválidas, y si todo va bien, pues voy y lo redirijo al admin, que pues ya vimos que era un módulo que se encarga de cargar otros módulos en cada uno de sus routes. ¿Ok? Entonces también tenemos categorías, que básicamente también es la renderización de una tabla de datos. También tenemos el dashboard, que pues al final si te fijas en el dashboard, no hay nada, está en vacío. Productos, pues renderiza su tabla con su información. Acá está la tabla con su información. Y igual con los usuarios. La gracia es que luego esté alimentando este repositorio y completándolo, por ejemplo, los formularios de crear producto, crear usuario, crear categoría, etc. Por ahora lo que tengo es la tabla de listado. Luego ya vamos a ir haciendo más formularios más complejos, pero por ahora el estado actual de la aplicación es la que la quiero migrar hacia la versión 16. Entonces empecemos a preparar este ambiente, este proyecto, maneja la versión, vamos a ver el angular, el package.json, vemos que estamos en la versión 15.1.3. Entonces vamos a llevar esta aplicación, lo que hay de esta aplicación, hacia una versión número 16. Entonces vamos a la terminal y vamos a seguir los siguientes pasos. Aquí voy a trabajar en una rama P16 para ir llevando ese versionamiento. Lo primero que tenemos que hacer es actualizar nuestro CLI global. Recuerda que nosotros tenemos un CLI global que lo podemos ejecutar con ng-version y saber qué versión del CLI tenemos instalado. Recuerda que este ng-funciona de forma global, pero también de forma local por proyecto. Entonces si quieres saber cuál es el que tienes de forma global, puedes ir a cualquier parte de tu sistema y no estar parado dentro del proyecto, sino en cualquier parte del sistema para ver cuál es tu versión global de angular. Creo que de por sí con ng-version debería funcionar. Ahí está. Entonces tengo una versión global que es la 15.2.5 y tengo una versión de Node, tengo un sistema operativo, tengo una versión de npm, etc. Que también lo puedes correr el ng-version dentro de tu proyecto. Acá debería ser algo similar. Entonces fíjate que acá es diferente el CLI local del proyecto al CLI global. Eso es muy interesante y muy importante que lo tengas en cuenta. Cuando corres el comando ng-version dentro del contexto de un proyecto, pues te va a sacar las versiones dentro del contexto de ese proyecto. Pero si lo haces afuera, pues entonces te va a decir la versión que sería la que tienes de forma global. Entonces lo primero que vamos a hacer es actualizar el CLI global. Entonces simplemente corremos npi de install, vamos a decirle angular y vamos a darle CLI. Vamos a darle nuestro arroba y que nos instale la última versión de forma global. Entonces vamos a instalarlo de esta manera. También te recomiendo que las versiones de angular las puedes checar con tu versión de Node. Entonces por aquí vamos a ir a la documentación y vamos a ver por ejemplo las referencias y releases. Entonces por aquí vamos a ver, este máscara por acá, acá, version compatibilidad. Por ejemplo nos dice que la versión 16 o la 16. Fíjate que acá ya hay otra versión, una versión 16.1 y una 16.0 y nos dice con qué versión de TypeScript, de RxJS y de Node es compatible. Entonces por ejemplo la versión 16 me dice que es compatible con la versión 16 y 18 en adelante. Entonces también tienes que tener en cuenta eso en tu entorno en el cual estás trabajando. Entonces pues vamos a la terminal. Acá por ejemplo ya instaló la versión última del CLI global. Entonces vamos a correr otra vez el comando y fíjate que entonces ya la global quedó en la 16. 16.1.8. Sin embargo si yo voy y lo corro aquí en mi proyecto, en el contexto del proyecto. Bueno, digité mal el código. Aquí me va a decir este proyecto eCommerceAdmin sigue estando en una versión 15 y también sus paquetes como el Angular CLI, los Schematics, TypeScript, en fin, todo todavía está apuntando hacia la 15.1. Pero nuestro CLI global ya está en la 16.1 que es el primer paso de nuestra actualización. Ok, ya tenemos entonces actualizado nuestro CLI global. Entonces ahora vamos a mover este proyecto y utilizando el CLI global pues lo vamos a como migrar hacia la versión 16 siguiendo pues los siguientes pasos. Entonces lo primero que vamos a hacer es lo siguiente. Vamos a correr el comando ngUpdate y luego vamos a decirle que queremos actualizar. Es más, si yo le doy solo ngUpdate él normalmente me da unas sugerencias de qué es lo que yo tendría que actualizar en mi proyecto. Pero luego vamos a ser específicos de acuerdo a lo que realmente queremos actualizar. Por ejemplo, aquí me dice, oye, deberías actualizar el ESLint, deberías actualizar el CDK, el CLI, el Core, el Material, etc. Vamos a hacer esto por pasos. Vamos a primero a migrar el Core y el CLI. Son los primeros que se migran. Entonces vamos a ir y vamos a decirle precisamente que quiero hacer esta actualización. ngUpdate Angular, el Core, entonces vamos a llamar al Core y le vamos a decir que nos queremos traer la versión 16 del Core. Y luego también vamos a irnos hacia el CLI de este proyecto en específico. Acá está haciendo actualizaciones en el contexto del proyecto en específico. Entonces también le decimos que actualice sea la 16. Vamos a ver si hay algún inconveniente. Si hay alguno lo podemos forzar con el comando force. Pero vamos a ver si todo sale bien o si nos toca forzar. Así que corramos el comando. Fíjate que por aquí ya me dio un problema y me dice que yo debería primero migrar el Angular ESLint porque dice que es incompatible. Y algo de lo que vamos a hablar aquí es de que este ESLint no es un paquete como oficial de Angular, sino es un paquete de la comunidad para incorporar el linter de Angular. Entonces parece que este proyecto está como teniendo conflictos y no me deja hacer la actualización. Sin embargo, voy a forzarlo y este paquete en específico luego lo voy a actualizar, digamos, de forma manual. Entonces, precisamente aquí voy a incluir el force. Y normalmente pasa mucho con este paquete. Entonces, si tú tienes este paquete y es el único que te presenta error, simplemente lo puedes forzar y puedes hacer ya la actualización manual de ese paquete. También funciona como la misma estrategia con otros, pero pues vamos a hacerlo precisamente aplicando un force y luego actualizando manualmente el Angular ESLint esquemados. ¿Ok? Entonces allí nos dice que está actualizando hacia la versión. Normalmente él instala, actualiza las dependencias. Y algo muy interesante es que ngUpdate no solo actualiza como, hey, voy a instalarte esta versión, sino que normalmente también va y revisa tu proyecto y mira si hay algún cambio. Recuerda que puedes ver el video de qué novedades trae la versión 16 de Angular. Y si él puede, va a hacer la migración hacia ciertos elementos que ya se utilizarían en la versión 16. Entonces vamos a ver si hace alguna actualización en el código como tal del proyecto. Hasta ahora sé que me está haciendo la actualización de dependencias de sus paquetes. Y por acá me dice cuáles son los archivos que está como modificando. Entonces esperemos que pase este proceso. Aquí ya terminó el proceso y me dice que actualizó o modificó el archivo package.json. Y por aquí me dice como algunas cosas que está tratando de ejecutar o de optimizar, pero dice que no hizo ningún cambio, que digamos que mi proyecto estaba como actualizado desde ese punto. Entonces aquí me dice que no ejecutó ningún cambio. Me dice por sí que... Bueno, me da como algunas notas. Por ejemplo, me dice que en la versión 15.2 los guardianes van a ya hacer replicados en cuanto a una función de programación unitaria de objetos y no van a ser más como programación funcional. Pero eso ya lo habíamos explorado. Recuerda que ya habíamos explorado cómo cambiar los guardianes hacia funciones en vez de clases. Y ahí te dejo el video respecto a realmente cómo utilizar ahora los nuevos guardianes de Angular que son funciones. Y casi que desde la versión 16 ya te obliga a que sean funciones en vez de clases. Sigue soportándolos, pero como que te muestra ciertas alertas diciéndote hey, recuerda migrar este guardián a una función en vez de una clase. Recuerda que ese video te lo dejo en la descripción o en alguna carta aquí de YouTube que te va a aparecer hablando de qué significa los guardianes y cómo cambiarlos de funciones a clases. Así que por ahora no me dice ningún cambio más en el proyecto. Simplemente tenemos aquí esto de esta manera. Así que vamos a proceder a hacer la actualización que me faltaba que sería la de el ESLint. Ahora, fíjate que cada vez que yo corro un comando él me obliga a hacer un commit. Entonces voy a hacer un ngadd y voy a hacer un commit. Y voy a decirle que update deps. Listo. Entonces vuelvo a ejecutar el comando ngupdate y ahora vamos a actualizar el ESLint. Y de por sí para no cometer errores voy a copiar y pegar el nombre del paquete que debe estar por acá. Vamos a verlo. En teoría es este paquete. Entonces vamos a copiarlo y vamos a llevarlo a la terminal. Y aquí no le voy a decir hacia qué versión. Él ya tendría que saber que como ya estoy en la 16 pues busque la versión compatible y pues simplemente actualízala. Vamos a ver. Fijémonos que de por sí en el package.json ya hizo algunos cambios. Por ejemplo, todo esto del core lo pasó a la 16. Esto de common ya lo tenemos en la 16. Animation lo tenemos en la 16. Y fíjate que ya con el Angular ESLint actualizando este pues básicamente también actualizó los paquetes que dependen o utiliza. Por ejemplo, el ESLint builder, ESLint plugin, ESLint plugin template y este template parser y todos los puso en la versión 16. Entonces fíjate que por acá pues está haciendo esas actualizaciones. Acá también me está avisando algo. Me dice que está haciendo cambios en el archivo package.json pero que también hizo una actualización en las reglas de ESLint que es este archivo ESLint.json. Vamos a ver por ejemplo que hizo allí. Entonces vamos a buscar ese archivo. Vamos a ver ESLint. Creo que es este que está por acá. Aunque no veo cambios parser o a menos que lo haya básicamente simplemente como haciendo un touch o creado del cero. Pero pues vamos a ver. Aquí básicamente estas son las reglas y por ejemplo aquí me puso un template recomendado de Angular y ESLint. Entonces pues vamos a ver si hay otra actualización. Al parecer no. Realmente solo hizo los cambios del versionado. Del resto pues todo está funcionando bien por ese lado. Ok, entonces ya migramos los dos nuevos paquetes. En teoría el core y el CLI pero recuerda que este proyecto utiliza material. Entonces también vamos a alinearnos hacia material. Entonces aquí vamos a ver que nos faltaría el CDK y material que estamos ahorita en la versión 15. Vamos a migrar hacia la versión número 16. Entonces, ¿cómo se haría esa migración? Vamos a correrlo. Entonces también vamos a hacer un commit. git ad git commit. Vamos a decirle que también hicimos otra actualización de dependencias del ESLint. Y listo. Entonces ya hicimos ese otro commit. Ahora vamos a hacer la última actualización que sería acerca de Angular Material. Entonces vamos a decirle Angular Material. Material. Y en teoría no tendríamos que darle el paquete. O sea, como la versión. Aquí le vamos a decir CDK. Fíjate que en la primera migración yo sí le puse aquí como arroba 16. Pero como ya estamos bajo el contexto de la versión 16, él ya entiende que tiene que buscar un match con el core. Entonces él automáticamente me va a decir cuál es la mejor versión para la versión de Angular que tengo del core. En este caso la 16.1.8. Entonces me va a buscar una versión de material que haga match con esta versión sin tener problemas o desconfigurar mi aplicación. Entonces fíjate que acá lo está llevando de la versión 15.1.3 hacia la versión 16.1.7. Así que vamos a esperar a esta actualización más. Listo. Aquí ya también terminó de hacer esta última actualización y me dice que no hay ningún ajuste o daño más. Eso también tiene que ver porque yo he mantenido este proyecto actualizado. ¿Qué quiere decir? Esto quiere decir que desde la versión 15 yo he hecho las actualizaciones necesarias. Entonces normalmente si tú lo mantienes actualizado con la versión previa, hacer la migración de la 15 a la 16 va a ser bastante sencillo. Recuerda que hacer las migraciones en Angular se hace paso a paso. Es decir, tú no puedes actualizar una aplicación de la versión 12 hasta la 16, sino que tendrías que correr casi estos mismos pasos, pero yendo versión por versión. Quiere decir que si estás en la 12, primero migras hacia la 13. Una vez ya la tengas en la 13 funcionando, entonces haces la migración hacia la 14 y así sucesivamente, luego hacia la 15 y finalmente de la 15 a la 16. No puedes saltarte entre versiones, sino vas haciendo las migraciones de forma por pasos, por versión por versión. Y casi que puedes seguir este mismo formato. Simplemente es empezar a actualizarlo y tagueando la versión que necesitas. Y eso lo hicimos en el primer comando. Ahora simplemente vamos a ver si nuestra aplicación funciona sin ningún inconveniente. Entonces aquí vamos a colocar un ngString y ver si todo funciona como debería. Aquí ya acabó nuestro proyecto, ya hizo la actualización. Es más, podemos, por si acaso, correr una gversion y ya me dice que esta aplicación, en su paquete o en su forma local, pues está apuntando hacia la 16.1.8. Y si de nuevo corremos a ngServe, pues vamos a ver si algo se rompió en la aplicación. Realmente no debió haber ningún daño haciendo la migración. La aplicación debería funcionar tal cual. Entonces vamos a ver. Vamos a hacer el login. Acá está nuestro formulario funcionando sin ningún inconveniente. Ahí está. Tenemos el dashboard ahí en vacío. Tenemos aquí los productos, que literalmente hace un render de la aplicación. Acá están las categorías, los usuarios. Por ejemplo, aquí voy a hacer logout. Entonces no debería poder ingresar a admin product o admin dashboard. Fíjense que ahí me devuelve. Y aquí podríamos corregir el bug de una vez. Parece que cuando estoy haciendo la protección de rutas, lo mando hacia un lugar que no corresponde. Debería enviarlo hacia el login. En este caso, hacia autologin. Aquí hay dos formas de solucionar este bug. Una es enviarlo explícitamente a la ruta, autoslash login, o decirle que la ruta por defecto, o sea que igual cuando no tengamos algún routing, pues lo llevemos hacia ese path. Por ahora voy a colocarlo directo. Vamos a ver cómo sería esa solución. Entonces vamos a ir por acá. Acá están los guardianes. Fíjate que aquí es donde yo tengo una redirección hacia autologin. Y esto no existe. Ese no existe. Es más, aquí nos faltaría un routing para cuando hay una ruta que no existe, que es precisamente la que no tenemos. Cuando no existe nada, él se queda en blanco. Aquí mirábamos que cuando hacemos logout, íbamos por acá. Aquí, por ejemplo, si va al autologin por esta regla que yo tengo en el routing. Está aquí. Cuando no tiene nada, está yendo a autologin. Pero cuando le estamos dando una ruta que no existe, como esta, login, fíjate que se queda en vacío. Y eso es porque no tenemos programada una ruta, por ejemplo, para un 404. Debe decirle, hey, 404 no found, por favor, ve y pues, intenta ir hacia algún lado. O por defecto, por ejemplo, decirle que cuando no hay una ruta, igual, forzarlo y enviarlo a, o redirigirlo al login. Entonces, por ahora aquí voy a corregir el book de forma sencilla. Y después el guardian debería ir a autologin. Y luego podríamos igual agregar como una página más para las rutas que no están identificadas. Y en ese caso, pues, deberíamos diseñar una ruta de 404. Recordemos que esas rutas son de este tipo. Son como cuando colocamos estas imágenes en donde nuestro sitio no identifica que está esa URL. Y normalmente tenemos una página diseñada para un 404 no found. Por ejemplo, en Platzi. En Platzi, si yo coloco una URL que no existe, como esta, normalmente me sale como un astronauta diciendo, hey, pues, esa ruta no existe. Y eso es lo que nos faltaría en nuestra aplicación. Por ahora, simplemente vamos a, luego vamos a diseñar esta ruta, pero, pues, al menos vamos a corregir el book del redirect. Entonces, vamos a ir aquí a mi aplicación en local. Entonces, voy a hacer login. Ahí está, cuando hago logout. Ahí está, vamos a hacer login. Voy a hacer logout otra vez y voy a intentar ingresar así a una ruta que no existe. Y como no tengo sesión, fíjate que aquí nuestro guardián, cuando él no tiene un token, va a ir a autologin. Y nuestro error era precisamente que lo estábamos enviando solo hacia login. Entonces, corregimos ese book. Recuerda que tienes el módulo de autentificación, ya está, aut, que tiene su página, que al final es, pues, un formulario, ¿no? Un formulario en el cual, pues, tenemos la validación y tengo aquí a este usuario por defecto, etc. Entonces, ahí está esa lógica. Vamos a ver precisamente aquí hacer el login. Ah, bueno, no, ahí vamos a ir al dashboard, intentar ingresar al dashboard. Entonces, ahora sí me hacen redirect hacia autologin. Entonces, ese book ya debería estar corregido. Listo. Entonces, fíjate también que en la versión de producción, si yo voy y hago una inspección, normalmente las aplicaciones en Angular tienen aquí este tag, ng-version. Significa que la versión que está ahorita en producción está en la versión 15.1.3. Entonces, pues, con estos ajustes debería quedar en la versión 16 y funcionar sin mayor inconveniente. Entonces, aquí ya podríamos enviar un commit. commit-m. Y básicamente arreglamos un book. Book and update hacia la versión 16. Listo. Entonces, aquí básicamente estoy enviando un push. Básicamente aquí este, cuando yo utilizo estos comandos como git aa, eso es igual a un git add, solo que tengo atajos en mi terminal. También puedes ver mi video de cómo tengo el setup de mi terminal para tener, si quieres, estos comandos o estas abreviaciones o hacer un git push origin master o origin, la versión en la que estoy trabajando, pues, básicamente se resume a este comando. Pero esas son abreviaturas y puedes ver mi video acerca del setup que tengo en mi terminal. Es más como las condiciones y el ambiente en el cual ya tengo configurado mi terminal para trabajar con estas abreviaturas. Ok. Hay algo que yo ya tengo configurado en esta versión. Y vamos a ver que aquí debe haber una rama, la rama 16, a la cual le acabo de hacer un commit, que es este que está acá hace un minuto. Sin embargo, cada vez que yo haga merge hacia la rama main, automáticamente va a hacer deployment hacia Fiber Hosting. Luego podemos ver cómo se hace esa configuración y automatizar, por ejemplo, que cuando vayamos a la rama main, pues, automáticamente vaya y haga un deployment a Fiber Hosting. Realmente eso es casi automático con la configuración cuando uno agrega Fibers a su proyecto. Entonces, como ya tengo esa rama, la rama 16, voy a pasarme a la rama main y vamos a hacer un merge de la rama número 16. También podría hacerlo por medio de como un pull request, ¿no? Que es más fácil como la forma oficial. Si yo tengo una rama, pues hago un pull request. Normalmente esto pasa por un proceso de revisión, sobre todo si estás trabajando ya en equipo, pues haces una rama, envías un pull request, tu equipo de ingeniería lo revisa y si todo está bien, lo suben a producción. En este caso voy a hacer el merge, pues, aquí, Manuel. Entonces, desde main voy a traerme la versión 16. Ahí está. Realmente no hay muchos cambios. Fíjate que el código no cambió mucho. Solo cambió, literalmente, solo cambiaron las versiones y, pues, el bug que tenemos del warrant, en donde hacía mal el redirect. Pero si nosotros miramos dentro del repositorio, realmente los cambios no son muchos. Y eso hace ver que realmente, cuando nosotros hacemos una actualización en Angular, de versión a versión, no es que cambie drásticamente o que tengamos que cambiar toda nuestra base de código. Realmente toda la base de código sigue estando, pero simplemente tenemos o mejoras de rendimiento o nuevas características que luego, pues, ya podemos ir implementando. Y de por sí, precisamente necesitábamos migrar este proyecto a la versión 16 para luego utilizar ahora sí nuevas características. Por ejemplo, en los siguientes videos que voy a sacar, ya actualizando hacia la versión 16, ya teniendo este proyecto con la versión 16, es utilizarlo nuevo. Pero tú puedes hacer la migración y seguir utilizando la aplicación y actualizarlo hacia la versión 16 sin fricción y sin romper la aplicación. Aquí, por ejemplo, ya se está haciendo el deploy a Fiber Hosting. Vamos a esperar a que termine. Pero básicamente aquí actualiza dependencias. Y fíjate que no se rompió nada, la aplicación sigue funcionando. Ahorita vamos a ver si en producción todo sigue funcionando bien, pero ya tengo mi deploy. En los siguientes videos vamos a utilizar esas nuevas características, porque si bien no tuvimos ningún problema a la hora de migrar, pues sí hay unas nuevas características en la versión 16 que podemos sacarle ventaja, pero allí tendríamos que hacer un par de configuraciones. Entonces, por ejemplo, voy a utilizar la forma de solo módulos, utilizar routers como parámetros, un montón de actualizaciones que se vinieron en la versión 16 y que ya podríamos sacarle provecho, pero que tenemos que estar montados en la versión 16 para poder utilizar esas características. Entonces, pues simplemente ya hicimos ese primer paso, pues hacer al menos la actualización de dependencias. Fíjate que acá ya terminó el deployment hacia Fiber Hosting. Entonces, aquí ya debería funcionar Vamos a ver si todo está bien. Fíjate que si yo inspecciono, ahora aquí tenemos la versión 16.1.8. Quiere decir que ya desplegó la nueva aplicación, la nueva versión, en la cual solo hicimos upgrade de dependencias. No hicimos cambios bruscos en el código, solo corregimos un bug. Y ya en los siguientes videos, ya estando en la versión 16, vamos a utilizar algunas características muy interesantes que nos trae la versión 16. Pero recuerda, por favor, que tenemos que al menos estar parados en esa versión para poder utilizar esas características. Entonces, aquí vamos a ver si todo funciona. Vamos a hacerle un login. Entonces, aquí me trae el dashboard que está vacío, los productos, ahí es donde funciona la renderización de los productos, la renderización de las categorías, la renderización de los usuarios. Es más, como está la API de Platz, es una API abierta, podemos ver que hay algunos estudiantes que están haciendo pruebas con esta API, creando sus usuarios para crear sus propios sistemas de administración. Ahora veamos el bug. Entonces, por ejemplo, si yo me lo veo con algo que no es la contraseña, me debería decir que hay credenciales inválidas, correcto, pero vamos a tratar de ingresar a una ruta que está protegida y como no tengo sesión, pues debería redirigirme hacia auto. Pues, al parecer no está funcionando. Vamos a ver por qué no funciona. O si es algo de caché. También podríamos ver si es algo de caché, y lo redirig, a veces pasa, y como por si esta aplicación está al lado del cliente, entonces puede que haya un caché allí que no esté recordando eso. Entonces vamos a ir a Application, vamos a limpiar toda la data que haya de caché y vamos a intentar otra vez. Entonces, ingresemos a estas rutas prohibidas y fijémonos que todavía sigue fallando y vamos a inspeccionar y ver por qué. Fíjate que acá hay un error y nos dice que no está haciendo match, no está haciendo match con alguna de las rutas. También podemos tratar de googlear, por ejemplo, este error y ver por qué está fallando, pero vamos a analizar nuestro error. Este es nuestro guardián y fíjate que acá estoy cometiendo un error, por ejemplo, esto normalmente retorna una promesa y yo lo estoy ejecutando directa, puede que no esté terminando de hacer el proceso y aquí deba ejecutar una web. Pero eso significaría que mi función debería ser assigned. Esa podría ser una solución, sin embargo me gusta más una, que es más limpia y más del estilo angular y es directamente no hacer la navegación aquí, sino si tú miras un canactivate, tanto en su forma de clases o en su forma de funciones, puede retornar un booleano o también podría retornar un url3 y es mejor directamente retornar ese url3 o ese árbol. Entonces en vez de hacer esta navegación, vamos a retornar directamente ese ese routing o esa url3 hacia donde queremos que le dirija. Entonces aquí podemos router service, punto, vamos a create url3 y le decimos outlogin, entonces este debería ser el que nos corrija el error. Quiere decir que si no hay token, entonces va a devolverlo de esta manera y no utilizamos navigate, sino simplemente lo retornamos de la manera correcta. Entonces vamos a ver si funciona, vamos a hacer este commit y pues agregar aquí en la terminal, vamos a hacer nuestro commit, le voy a decirle use url3 y vamos a hacer un push y hacer que el como estoy haciendo el commit en la rama main, pues eso despierta el proceso de SLI de Fiverr y debería desplegarlo. Aunque también debemos probar en local, por si cualquier cosa, pues vamos a ver si en local también igual funciona en lo que despliega nuestro servidor de Fiverr, pues vamos a ver que igual en local funciona nuestro redirect, entonces vamos a intentar ingresar a una url y al parecer aquí funciona igual sin problema, ahí está, lo redirecciona, entonces vamos a ver si en nuestro commit que hicimos en la rama main, vamos a ver, vamos a buscar los repositorios, acá está, y aquí en la rama main, pues deberíamos tener precisamente pues ese bug corregido, debería corregir eso y de una vez pues eliminamos una mala práctica que teníamos en nuestro WAN, que también lo pueden eliminar ustedes y se tienen un navigation así directo, pues aquí la buena práctica sería hacer el retune directamente creando esta forma para hacer la redirección, entonces pues observamos que termina el proceso y volvemos a verificar. Entonces aquí vamos a probar de nuevo la aplicación, vamos a ingresar a una de esas rutas que no existen, entonces vamos a ir a admin products y fíjate que aquí en admin products, como ya no tengo y está haciendo el redirect, pues automáticamente me envía automáticamente me envía donde es, vamos a hacer nuestro login, por ejemplo si yo voy a productos, ahí me deja ingresar porque tengo sesión, es más, puedo abrir otra ventana y fíjate que puedo ingresar, es más, puedo ingresar aquí directamente a categorías, categories, y ingresar directamente a la sección, sin embargo si hago login y me des a esa sección, bueno me des bloqueo hago un logout y me voy a esa sección de products, fíjate que me como que me bota a autologin, aquí también si refresco por ejemplo, como ya no tengo sesión, me bota a autologin si refresco aquí, también ya me bota a autologin, entonces corregimos nuestro bug y además de eso nuestra aplicación ya está, recordemos que ya está en la versión 9.16.1.8 Así que en este video logramos migrar una aplicación sin menor conflicto, simplemente el bug que ya teníamos, este no fue un bug por la migración sino fue un bug que ya teníamos heredado en nuestro sistema simplemente lo corregimos, pero ya hicimos la actualización desde la versión 15 hacia la 16, ahora ya estando sobre la 16 vamos a hacer actualizaciones y utilizar ciertas características que solo vienen de la 16 en adelante, y pues utilizar esas nuevas características dentro de esta aplicación en Angular Así que te espero en los otros videos, recuerda suscribirte al canal y también pues seguirme en mis redes sociales así que recuerda compartir este video si quieres apoyarme y nos vemos en la próxima.