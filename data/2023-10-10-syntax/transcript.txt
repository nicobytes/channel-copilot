 Angular está proponiendo una nueva sintaxis basada en Svelte, y vamos a aprender de qué trata en este video. Así que, ¡vamos a empezar! Todo empieza desde este RFC en donde Angular propone cambiar el modelo de sintaxis para que sea más sencillo de aprender y controlar el flujo dentro de nuestro HTML. Dicho, en este mismo RFC dice que se inspiran en la sintaxis de Svelte, que es un framework bastante interesante y también bastante rápido en su rendimiento. Pero también su sintaxis es bastante interesante para poder controlar el flujo en el HTML. Ahora, veamos un poco cómo es la sintaxis de Svelte. Por ejemplo, si tú tuvieras un if y quieres representar algún elemento con base a alguna condicional, te vas a encontrar con algo como lo siguiente. Tienes algunas instrucciones y el if lo tienes directamente como en un statement allí para poderlo declarar, muy diferente a lo que tenemos en Angular que son directivas como ng-if o ng-for. Y esto es lo que se propone, cambiar a un modelo de sintaxis muy parecida a esta. Veamos por ejemplo cómo Svelte hace un for. Básicamente también tiene un elemento en la cual itera, y nosotros ya no haríamos un ng-for desde un li o con la directiva ng-for, asterix con g4, sino tendríamos como este tipo de statements para poder hacer este tipo de flujo. Ahora, Angular ha estado precisamente inspirándose en frameworks como Solid en su modelo de reactividad, y ahora vemos que se inspira en frameworks como Svelte para su sintaxis. Entonces, mantengamos en mente precisamente cómo es esta sintaxis y veamos cuál es la que Angular va a proponer y qué va a salir en la luz en la versión 17. Así que vamos a un demo en vivo y veamos cuál es esta sintaxis, porque ya se puede probar desde una versión beta de la versión 17. Vamos al código. Aquí tengo una aplicación súper sencilla, pero que nos va a permitir ver cómo es esta nueva sintaxis. Entonces, nos vamos a fijar mucho en el template, que es lo que va a cambiar, porque al final nada cambia en la lógica. Aquí es un administrador de tareas, entonces vas a ver que aquí ya lo hago con el modelo de reactividad de Signals, pero básicamente tengo unos métodos para agregar tareas, limpiar las tareas, cargar algunas tareas, actualizar alguna tarea, y por ejemplo tengo una variable show que simplemente cambia de true o false. Entonces, esto se va a mantener tal cual, solo que ahorita ya utiliza Signals y es un standalone component. Pero veamos y fijémonos mucho en el HTML, que es lo que va a cambiar. Entonces, aquí tenemos un botón que va a ser toggle del estado de show, y por eso aquí muestro ese estado, y con base a ese estado, entonces vamos a mostrar un elemento, y aquí normalmente tenemos un main, y para saber si muestro o no ese elemento, utilizamos un ng-if. Pero si no, si digamos la condicional es falsa, entonces yo quiero mostrar algo, algo que no sea ese elemento. Entonces, normalmente lo que haríamos es un ng-template con ese bloque, con ese else block, con ese elemento, y lo podemos ver funcionando acá. Por ejemplo, como están false por defecto, entonces se muestra este bloque que es true h1, pero si yo ya lo cambio a true, entonces se me muestra todo este bloque, incluido el main. Ok, y luego pues aquí dentro tengo una iteración, entonces tengo una lista de tareas, además tengo unos botones para agregar tareas y limpiar tareas, pero básicamente es un ng-for, y también tengo un ng-container, el cual se va a mostrar si no hay tareas, es decir, si la lista de tareas está en vacío, y acá tenemos un ng-if, en el cual muestro un mensaje de la lista de tareas y luego un botón. Entonces, básicamente se ve algo así, entonces como la lista está vacía, me dice que no hay tareas, y le digo que cargue las tareas, ahí cargo algunas tareas por defecto, también puedo agregar unas, puedo empezar a editar el estado de alguna otra, o limpiarlas y dejarlo en vacío. Es una aplicación súper sencilla, pero que tiene estos elementos ng-if, ng-for, ng-container, ng-template, y vamos a ver cómo quedaría con la nueva sintaxis. Para probar la nueva sintaxis, básicamente lo que hice fue probar la versión que está todavía en desarrollo, la 17.next.7, que es donde ya se puede probar esta nueva sintaxis, y fui al ts-config para habilitar estos nuevos bloques, que es if, forth, también va a haber un cambio en el switch y differ, que ahorita vamos a hablar un poco más de ello. Pero entonces empecemos a hacer este cambio, vamos a ver. Entonces primero lo que vamos a hacer es cambiar nuestro main o esta sintaxis para mostrar un elemento u otro, normalmente entonces lo que abríamos es algo como esto, Angular escogió el arroba, si vemos Svelte tiene como un hashtag, pero Angular escogió el arroba para poder cerrar o abrir una sintaxis, o pues el condicional, y luego tenemos el else. Esto sería básicamente si quiero o no mostrar algo, y aquí entonces estaría nuestro condicional, y nuestro condicional podríamos suscribirnos a nuestra señal de show, entonces si esto es verdadero, muestro todo este elemento, entonces básicamente mostraríamos este elemento de acá, y si no, ya no tengo que encerrar esto en un ng-template, sino simplemente muestro el h1, aquí está, déjame lo copio, acá está nuestro main, nuestro main y nuestro h1 lo copiamos en la sección del else. Entonces ya borramos nuestro ng-template, y obviamente este ng-if ya no sería necesario, sino directamente queda de forma más explícita. En este momento nos va a dar algunas alertas de que estamos teniendo una sintaxis rara, y esto es precisamente porque el Angular Language Service, que es como nuestro complemento en Angular que nos dice si estamos haciendo bien o mal código, todavía no se ha actualizado soportando esta nueva sintaxis, entonces es normal que ahorita nos esté dando error, pero pues ya cuando, recuerden que estamos probando una versión apenas alfa de lo que propone la versión 17, entonces vamos a ver estos errores, pero ya cuando esté estable y lo prueben ustedes en producción, seguramente solo hay que actualizar nuestro plugin y ya con eso está todo bien. Pero bueno, entonces aquí tenemos el primer cambio, en el cual tenemos esta sintaxis y ya no utilizaríamos el ng-if, veamos por ejemplo si funciona, y veamos que también podemos seguir utilizando, y Angular siempre ha sido retrocompatible, es decir, podemos utilizar la sintaxis nueva, pero por ejemplo aquí dentro seguir utilizando ng-for o ng-if, él es retrocompatible, podemos utilizar las dos sintaxis, entonces veamos aquí que según el estado muestra un bloque o el otro, y tenemos ya el soporte con esta sintaxis, ahora veamos cómo sería nuestro for, si nuestro for ya no es con esta directiva, veamos cómo sería ahora nuestro for, entonces tenemos un arroba, luego tenemos aquí la forma de iterar, y pues básicamente así iteraríamos, acá sería el elemento que vamos a iterar, entonces tenemos un li, el ng-for ya no estaría acá, y fíjate que esta parte se mantiene, entonces aquí lo que ya no haríamos es crear como let, directamente aquí podemos crear como tags, y off tags, y directamente eso sería la iteración, y aquí nos agregan, como buena práctica, nos agregan una forma de hacer un track, para el rendimiento de los elementos, sobre todo cuando realizamos una lista, y le decimos que el track sea por el id, entonces aquí ya no necesitaríamos este ng-for, sino que directamente la iteración sería con esta sintaxis, que es nuestro for, y el for queda de esta manera, recuerda que acá tenemos una lista, y esta lista es una señal, un signal, por eso la estamos ejecutando, para obtener el valor de esa señal, de ese valor, entonces aquí quedaría esa nueva sintaxis, veamos si funciona, ahí está, entonces vamos a cargar tareas, fíjate que ahí vamos agregando tareas, y pues la aplicación sigue funcionando sin problema, estamos haciendo una iteración, y igual sigue funcionando la iteración, la sintaxis anterior, por ejemplo, sigue funcionando lo que es un ng-if, pero fíjate que acá hay algo interesante del for, y es que yo puedo decir, precisamente teníamos estos elementos, de saber si la lista está vacía, entonces yo muestro el cierto elemento, también está como directiva, o esta palabra reservada, para por ejemplo saber si la lista está vacía, entonces podríamos mostrar este elemento de acá, y ya tampoco tendríamos este ng-container, con este ng-if, entonces vamos a ver, aquí así quedaría básicamente, o ese ajuste con la nueva sintaxis, y veamos si nuestra aplicación sigue funcionando, entonces aquí agregamos tareas, limpiamos todas las tareas, cargamos algunas tareas, vamos a agregar alguna, estoy editando en específico alguna, la limpiamos, y precisamente los elementos, que manejan o controlan el flujo, ahora tendrían esta sintaxis, dime qué te parece esta sintaxis, básicamente entonces estos elementos, como el ng-if y el ng-for, ya se verían diferente, y elementos que de pronto eran un poco complejos, de saber cuándo utilizar, como un ng-container o un ng-template, ya no serían necesarios, porque la nueva sintaxis, básicamente es súper explícita, en saber cuándo mostrar un elemento o no, sin necesidad de utilizar como estos contenedores, que teníamos en Angular, que de pronto hacen que las personas, se confundan a la hora de aprender Angular, entonces por ejemplo, ya no tendríamos estas cosas como ng-container, o esto de el ng-template con el else block, sino que directamente tenemos la sintaxis nueva, que es un if, y directamente si quiero no mostrar algo, no tengo que hacer referencia ni ng-template, sino directamente el else, o por ejemplo, si quiero tener un estado en vacío, precisamente de la iteración del for, utilizo el arroba-entry, que sería pues nuestro estado de vacío, y muestro ese estado, y tampoco tendríamos que mostrar un ng-container como tal, esto es simplemente con el if y el for, pero también se plantea cambiar el ng-switch, y no solo eso, Angular también está proponiendo, unas formas de mejorar la sintaxis, para hacer lazy loading de componentes, por ejemplo, parte de ese RFC y la nueva sintaxis, es tener un loading o un lazy loading, en el template con esta nueva sintaxis, por ejemplo, utilizar algo como defer, en el cual cuando se cumple alguna condicional, por ejemplo, cuando sea una vista en específica, por ejemplo, mobile, tablet o lo que sea, o cuando se cumple una condición, por ejemplo, si nuestro usuario está logueado o no, cargo ese componente, y si no muestro algún otro componente, en lo que carga, esto básicamente sería un lazy loading de componentes, y eso haría que nuestra aplicación gane rendimiento, ¿qué quiere decir? normalmente nosotros hacemos lazy loading a nivel de rutas, pero nunca hemos hecho lazy loading, de forma nativa con Angular, de componentes, y esto es interesante, porque lo haríamos ahora bajo esta nueva sintaxis, déjame en los comentarios, ¿qué tal te parece esta nueva sintaxis? si te gusta, si no te gusta, déjame ver tu reacción, recuerda compartir este vídeo, suscribirte y nos vemos en la próxima.