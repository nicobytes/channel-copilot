 Angular propone declarar variables de una nueva forma dentro del template, a esta la llamamos Let Syntax y si bien todavía está en preview, hoy vamos a ver precisamente y echarle un vistazo de cómo funciona, qué cosas se pueden hacer, cuáles serían las malas prácticas, porque recordemos que un gran poder conlleva una gran responsabilidad así que precisamente vamos a ver este nuevo mundo de posibilidades que se abre precisamente con esta Let Syntax así que veamos de qué trata y empecemos. Y esa nueva sintaxis o esa nueva forma de declarar variables es esta que estás viendo en pantalla precisamente. Ahora tendríamos una nueva forma de por ejemplo declarar, crear una variable no desde dentro de la lógica de negocio como venimos acostumbrados como por ejemplo en el TypeScript, sino así literalmente con arroba let podemos asignarle un valor y luego podemos usar ese valor con el string interpolation que nos tiene acostumbrados Angular. Veamos cómo funciona. Aquí tenemos precisamente la forma normal. La forma normal en la que nosotros renderizaríamos una variable como por ejemplo acá name y utilizando string interpolation pues es una variable que vive dentro de nuestra lógica. Acá podemos ver que tenemos nombre Nicolás, acá le puedo poner Nicobites por ejemplo y esta variable pues la estamos imprimiendo ahí. Entonces aquí pues simplemente tenemos la impresión precisamente de esa variable. Ahora, ¿cómo probaríamos la nueva sintaxis? Veamos, en la nueva sintaxis por ejemplo podría ser algo muy similar a esto. Acá pongamos saludo y por ejemplo yo podría poner un hola y le puedo concatenar la variable que si bien es de la lógica de negocio en este caso es name y poner este saludo. Entonces si vamos otra vez acá por ejemplo me quedó pegado hola Nicobites, entonces vamos a ponerle un espacio y ahí ya está el espacio, pero podemos ver precisamente que esta es una forma que antes no teníamos. Declarar esta variable de esta manera y vamos a ver precisamente qué otras cosas podemos hacer. Vamos a tener con esta nueva sintaxis. Una de las cosas que más nos ayuda esta sintaxis es evitar estos if que antes teníamos, sobre todo si teníamos un pipe o un observable que resolvíamos con un assign. Algo normal que hacíamos por ejemplo era precisamente un if para encerrarlo y declarar o ponerle un nombre a esa variable después del if y poder reutilizarla dentro de ese bloque. Es algo muy común que hacíamos, pero ahorita con el let podríamos evitar como este hack, este truco que utilizábamos precisamente en Angular por algo mucho más limpio como esto. Por ejemplo, tendríamos un let, literalmente tendríamos nuestro observable product assign y luego ya podríamos usarlo. Veamos cómo es el ejemplo y por qué esto es importante. Para que esto funcione entonces voy a crear un observable. Por ejemplo voy a tener un observable que vamos a simular que al final es un request hacia una API. Entonces acá tengo http, entonces yo puedo decir .htpp.get. Acá de por sí ya tengo como el typing de ese producto, entonces le puedo decir, mira yo esperaría que tú me devuelvas un producto y luego le pongo la URL en donde estaba el producto. Entonces podría poner http y aquí básicamente yo tengo una API que la pueden usar, también pueden usar la de Platzi, cualquiera de las dos. De por sí esta API es una que estoy haciendo es más para probar la API en el let, pero funciona igual. Entonces aquí vamos a API versión 1. Product, voy a traer un product, sé que hay uno con un ID creo que 51. Entonces aquí literalmente tendría un observable que va y pues hace un request, me obtiene un producto. Y si yo básicamente pudiera tener esta forma de suscribirnos a este producto, a la información de este producto, pues sería de la siguiente manera. Entonces digamos que nosotros vamos a borrar esto y digamos que yo quería imprimir el nombre del producto. Entonces podríamos hacer algo como esto. Tenemos product y por acá tendríamos nuestro assignPank, ¿verdad? Acá, esa sería la forma, ¿no? Y básicamente tendríamos que encerrar esto por acá y ponerle alguna expresión como esta para luego obtener, ¿qué? El título del producto. Entonces podríamos tener title y tendríamos que hacer pues como para obtener la respuesta después de la suscripción, pues obtendríamos como el title. Lo mismo pasa por ejemplo si quisiéramos. La. Descripción. Entonces tendríamos que poner description. Description. Listo. Vamos a ver si funciona. Algo está pasando acá. Vamos a ver qué error tengo. Si es un error como de algún request. Ah, por acá dice que no llega. Y algo tengo mal. Ah, claro. Acá es en plural products. Y vamos a ver si ahí está. Podríamos agregar también el precio. Entonces por acá por ejemplo pondríamos el precio. Vamos a utilizar exactamente esto. Acá. Y ponemos el. Precio. Price. Y es más, le vamos a poner un que es el de concurrencia. Que por si está ya lo tengo aquí importado. Es este concurrencia. Entonces lo para no tener errores de tipo. Ahí lo tenemos. Y por acá deberíamos tener el valor. Pero fíjate que literalmente hizo tres request a la API. Entonces, si bien podemos resolverlo de esta manera al hacer una casi que estamos haciendo tres request por cada una de las variables. Entonces, ¿qué es lo que hacíamos? Nuestro clásico. Y la técnica que les mencionaba. Live. Para no tener que suscribirnos a cada uno. Y de por sí es una buena práctica utilizar el asign. Porque él automáticamente quita esa suscripción una vez el componente ya no se esté usando. Entonces básicamente lo que hacíamos es decir. Bueno, no quiero estar declarando el asign tres veces. Ni mucho menos hacer el request tres veces. Entonces lo que hacíamos es algo como. Oiga, esto. Resuélvalo como product. Dentro del bloque if. Y entonces ya podríamos pasar esto por acá. Entonces una vez teniendo eso. Ya podríamos estar seguros. De utilizar product. Sin ningún problema. Sin embargo, quedó como este alias. Como esta forma de tener el producto. Y en este caso ya no estamos llamando el request tres veces. Lo estamos llamando simplemente una vez. La vez que necesitamos pues el producto. Y lo encerramos en el bloque. Y ahora tenemos sus variables. Vamos a ver si funciona. Fíjate que ahí ya tenemos solo una vez. Y tenemos una vez el precio. Aquí podemos ver que se hace el request solo una vez. Perfecto. Pero al final esto. Esto del if. Había sido como un tipo de hack. Que en Angular utilizamos mucho. Precisamente para evitar. Primero tener la suscripción tantas veces. Y poder literalmente ya estar. Teniendo este alias. Para poder utilizar el producto. Ahora con let. No sería necesario hacer como este hack. De el if. Sino que precisamente. Vamos a ponerle. Vamos a copiar esta parte. Sino que no necesitamos encerrarlo en un bloque. Vamos a tenerlo así. Y podemos declarar la variable de esta manera. Entonces tenemos let. Product. Eso va a ser igual a resolver el async. Y debería funcionar sin mayor problema. Ahí está. Y también tenemos. Deberíamos tener solo un request. Vamos a ver. Acá tenemos solo un request. Entonces fíjate que nos ahorramos como un poco. Esta sintaxis estorbosa del if. Que era realmente un hack. Que todos utilizábamos para evitar. Tener que correr la async varias veces. Y utilizar esa variable. Y utilizarla. A través de nuestro template. Ahora ya entiendes mucho más de qué trata esa sintaxis. Y ya lo podríamos dejar. Un poco más plano. Simplemente sin tener que encerrarlo en un if. Sino directamente deducir o. Crear una variable de acuerdo a una expresión. En este caso. Podemos ejecutar el async. Lo mismo pasaba con los observables. Nosotros si teníamos. En vez de los observables. Teníamos un signal. Que básicamente también podría comportarse como un observable. Teníamos que para obtener el valor de un signal. Tenemos que ejecutarlo. Y para no tener que precisamente. Correr varias veces el signer. O la suscripción al signal. Lo encerramos de nuevo en un if como este. Esto también ya podría ser sencillo. Con el let. Sin necesidad de hacer este tipo de sintaxis. Veamos rápido con un signer. A ver cómo sería. Aquí entonces tienes la forma de hacerlo con una suscripción. Utilizando un observable. Pero entonces cómo lo haríamos con un signer. Entonces básicamente. Voy a crear un signer con base a esa suscripción. Normalmente para los observables. Tenemos como este signo pesos. Y para los signers. Estoy viendo que la convención es tener el signo pesos al inicio. Con eso se sabe que es un signo. Y este hash aquí en el. En este inject. Es otra cosa que no tiene nada que ver con convención. Tiene que ver algo más como con manejar. La forma nativa de JavaScript para manejar variables privadas. Pero otro video hablaré de esto. Pero bueno. Entonces cómo haríamos para convertir eso en un signer. Pues vamos a ver. Precisamente desde el paquete core de RxJS. Hay una función para convertir un observable a señal. Entonces voy a tener tu signo. Y básicamente le mando el observable. En este caso sería product. Y vamos a ver. Ahora no sería product como observable. Que es el signo pesos. Acá. Perfecto. Y listo. Y eso ya sería nuestro signo. Entonces cómo lo resolver. Pues al final sería muy sencillo. Utilizaríamos nuestro led. Esto es una señal. Entonces sería product. Nos suscribimos al valor de esa señal para obtener su valor. La guardamos en product y ahí obtendríamos el mismo resultado. Solo que con una señal. Veamos. Y acá está. Literalmente tenemos exactamente el título, la descripción, el precio. Un solo request, pero pues ya ejecutada desde un signer y no un observable. Entonces, al igual que en el ejemplo de la sign, me ahorro como tener el bloque de un if para suscribirme a la señal, obtener los valores y luego ponerle como un alias para luego llamarlo dentro de ese bloque. Ahorita podríamos tenerlo mucho más lineal, que simplemente es lo que te mostraba. Tenemos un led con el nombre de product. Ese sería como el alias que estábamos utilizando y luego la suscripción a la señal. Algo también que puedes hacer con esta nueva sintaxis, con esta nueva forma de declarar estas variables dentro del template, es que se pueden utilizar con pipes. De por sí ya lo vimos porque utilizábamos el assign, el assign pipe dentro de la sintaxis de un led. Pero échame un ojo un poco más de cerca. Veamos, por ejemplo, la fecha de actualización de un producto. Yo podría tener algo como esto. My date. Resulta que product tiene una variable llamado updateDate. La suscribo o bueno, la obtengo, la proceso con un pipe, obtengo la respuesta y luego la puedo asignar. Hagámoslo. Entonces rápidamente aquí voy a poner un strong. Listo. Y acá entonces voy a poner, por ejemplo, aclaro mi variable a este nivel. Entonces acá tengo my date. Y eso podría ser igual a esta sintaxis me ayudaría. Acá puedo utilizar el pipe date que por sí también ya lo tengo aquí importado. Y entonces podría poner updated at. Esa es como la parte y acá entonces ya la puedo usar. My date. Vamos a ver si funciona. Listo. Acá literalmente entonces ya tienes la impresión de esa fecha. Ahora, si te soy sincero, precisamente esto no es tan complejo. Yo realmente me evitaría crear como un led solo para esto. Realmente solo quiero mostrarte que se puede, pero casi que esto. Pues igual podríamos utilizarlo como antes lo utilizábamos, que simplemente era pues el valor y obtener el pipe o pues el formato que me va a dar como impresión. Pero es válido. Precisamente es válido ahora con la nueva sintaxis también tenerlo de esta manera. Ahora hagamos algo más complejo y es hacer operaciones de por sí. Ya lo hacíamos porque ejecutar un pipe es una forma de procesar algo, de mandárselo a un país, procesar algo y devolverlo en el formato de Angular. Pero podemos ejecutar procesos, por ejemplo este que está acá y este es un poquito delicado, pero vamos a empezar a introducir también algunas. Creo yo malas prácticas que pueden surgir con el led. Pero para esto necesitamos el ejemplo. Entonces aquí, por ejemplo, tenemos el cálculo de los impuestos. Entonces digamos que quiero el precio del producto y calcular cuántos impuestos estoy debería pagar por ese producto. Supongamos. Digamos que acá estoy haciendo la multiplicación por el 0.19, que sería el 19 por ciento. Entonces acá estoy creando una variable llamada impuestos y luego estoy tomando el precio, lo multiplico por el valor, el porcentaje o lo que sea, y luego lo puedo imprimir. Entonces yo puedo ejecutar también operaciones con esta como con esta nueva forma. Veamos también este ejemplo. Y esto nos conduce a ciertas cosas que deberíamos tratar también con rigor. Pero veamos. Ok. Entonces, teniendo en cuenta ese ejemplo, me va a copiar como esta sintaxis. Acá le voy a poner listo. Estos son sus impuestos. Acá tengo el precio y hago una operación, lo multiplico por el 0.19. Imprimo y a esto como es un valor, entonces un valor en precio que pongo el par de currency y debería funcionar. Veamos. Bueno, acá, por ejemplo, me está dando un error. Y esta es una de las reglas que también van como pegadas y tienen sentido en cuanto a que acá al multiplicar esto, este valor del producto. Por eso estoy utilizando como este signo de pregunta. Puede venir, o sea, puede no venir porque puedo yo darle un producto que no existe. Entonces una vez le doy un producto por defecto o le digo bueno, esto puede venir nulo porque no encontró el producto del producto 51 no existe. Entonces aquí para dejar de utilizar esto y para no tener este error de que, por ejemplo, pues como producto no existe, pues Price tampoco y estaría multiplicando por algo que es un de un de fine. Podríamos hacer algo y es igual cerciorarnos con el IF. Es decir, si producto existe aquí es donde normalmente tú puedes hacer cosas como el else y decir no, pues esto no existe y producto no, no, no existe, existe. Y luego entonces ya puedo meter todo esto otra vez acá. Y ya no tendría que preocuparme por el signo de pregunta porque ya estoy dentro de la cláusula que me dice que si un producto si existe. Lo bueno de esto. Fíjate que se parece un poco a lo que teníamos y acá podríamos volver a ponerle como un alias, pero lo bueno es que si yo quisiera podría utilizar el producto fuera de ese o este este led fuera del bloque IF antes como que estábamos atados a que solo eso lo podíamos utilizar solo dentro del IF. Porque la realidad solo tenía contexto dentro del IF, dentro del IF. Pero acá con el led, pues ya lo podemos utilizar, no sé, en alguna variable más abajo que quisiéramos, por ejemplo. Entonces acá yo ya podría quitarle este como todos estos signos de pregunta, porque ya esto me valida que realmente existe un producto y tranquilamente ya puedo empezar a hacer la pregunta. Entonces vamos a ver. Ahí está. Es más, le voy a hacer un producto que no existe. No sé si me devuelva nulo. Vamos a ver. Acá no existe. Entonces, como no existe, me devuelve como un de fine. Y por defecto, entonces se corre la siguiente instrucción, que sería el else. Pero vamos entendiendo un poco cómo funciona el IF y acá entonces ya tenemos el cálculo. Entonces aquí te quiero hablar de que esta nueva sintaxis, si bien es muy poderosa y un gran poder conlleva una gran responsabilidad, porque eso nos enseña Spider-Man, pues aquí se introduce como algo que podría considerarse una mala práctica y también algo que puede perjudicar el rendimiento de tu aplicación. Por ejemplo, este cálculo inocente, digámoslo, que calcular el precio directamente en el template tiene algunas cosas que yo le trataría con cuidado. La número uno es que lógica de negocio está viviendo en el template y normalmente esto se lo dejamos al servicio, al componente y de por si no estaba en el template o no teníamos tanta lógica de negocio en el template, porque el template sólo se debería hacer para renderizar los datos que ya fueron procesados por el componente, por el servicio, por un resolver, quizás, pero no en el template. Entonces aquí se pone un poco complejo porque ya podríamos introducir reglas de negocio poderosas dentro del template. Yo trataría de evitar esas reglas de negocio dentro del template, pero sin embargo, con el LED se podrían, como el cálculo del impuesto. Vamos a ver unos ejemplos más para que veamos dónde podría estar. Varias cosas. Acá, por ejemplo, tenemos una lista de productos muy similar a la que yo tengo. Tenemos una lista de productos y acá también están haciendo un cálculo. Entonces digamos que acá tenemos el valor y la cantidad. Yo tengo un carrito de compras y he agregado 10 productos y esos 10 y cada producto me vale 100, entonces hago la multiplicación 100 por 10 y acá tengo el total. Este también es muy un cálculo muy inocente de por si aquí está corriendo dentro de un for, entonces estoy teniendo toda una lista de productos y estoy creando una variable directamente en el template haciendo este cálculo. Esto puede ser un poquito perjudicial para el performance, porque al final la instrucción LED dentro del compilador de Angular también agrega un poco de proceso en el render. Yo trataría de renderizar o de mandarle esto ya listo como este cálculo ya listo antes de que llegue al template ya procesado por algún método en el componente, ya procesado en el servicio tal vez y ya sólo se procesa una vez y el render o el template sólo le toca imprimir esos datos ya procesados, pero no procesarlos en el template. Veamos otro. Por ejemplo, fíjate en este. Este lo que hacen es el formato de una fecha. Hacerlo directamente también en el template. Entonces tengo, no sé, una lista de eventos y luego entonces tengo New Date y llamo a True Locale Data String. En este caso, por ejemplo, estamos haciendo el formateo de una fecha, colocarlo en el formato correcto para nuestros usuarios. Estoy haciendo el cálculo ya en el template. En este caso, por ejemplo, creo que aquí sería mucho mejor utilizar un pipe como el pipe de fechas de Angular o que crees el propio tuyo, pero aquí como que ejecutar esto tan directo. No me parece una buena práctica, sino que directamente para eso están los pipes. Además, en los pipes podemos hacer algo que se llama Memoization y como son métodos que pueden guardar el valor de su ejecución anterior, entonces no estaríamos ejecutándolo, sino que si ya nos mandan la misma fecha o varias veces la misma fecha, él como que lo recuerda y ya manda la respuesta que ya fue calculada anteriormente. Entonces como que podemos hacer esas técnicas de por si hay un video. Si lo quieres ver acerca de Memoization en pipes en mi canal, te lo voy a dejar por aquí por YouTube. Aplicar esa técnica en los pipes, pero por ejemplo, para dar formato de algo, creo que ya teníamos los pipes, si bien con la nueva sintaxis ahora se abre la posibilidad de hacerlo directamente en el template, creo que deberíamos guiarnos por si quiero formatear algo, el pipe precisamente cumple esa función. Entonces yo lo haría por un pipe y no lo haría el cálculo directamente en el template. Además, que es más reusable, también es más mantenible. Al igual que, por ejemplo, calcular los impuestos. Tal vez. No sólo necesito calcular los impuestos en ese componente, en ese render, sino lo necesito en otro lado, entonces mejor, por ejemplo, que esté ya en el servicio procesado o un pipe que pueda reutilizar, que pueda reutilizar para dar formato de fechas en general. Y miren este, este también me parece interesante. Este, por ejemplo, yo sí lo usaría, aunque cumple con la misma problema de hacer cálculos en el template. Si de pronto nos gusta mucho el rendimiento, yo igual lo haría no antes de que llegue y no lo haga en el template, pero es válido, por ejemplo, esta esta forma. Fíjate que acá tenemos un Ford de nuevo y tenemos si el usuario está activo, entonces muestra como un string o otro y fíjate que algo muy interesante del let es que soporta los if abreviados, estos if que de acuerdo a si es true o false, entonces pongo como ese signo de pregunta. Si responde sí, pues me da active y si no inactive. Y ese sería el mensaje que luego imprimo. Entonces podría como hacer ese cálculo directamente dentro del Ford, dentro del let y directamente, pues ponerlo ahí y no tener que procesarlo antes del template. Sin embargo, pues tienes que tener mucha delicadeza con esto. Yo creo que igual la buena práctica seguiría siendo dejarlo procesado antes de que llegue al template y no hacer ese tipo de cálculos en el template. Y este si de por sí ya lo evitaría porque este cálculo si ya es más pesado y estar haciéndolo en el template, yo lo evitaría por temor. Y si no, pues no lo haría. Entonces, si yo quiero hacer un cálculo de rendimiento, entonces yo tengo que hacer un cálculo de rendimiento. Fíjate que por acá tenemos una lista de estudiantes que supongamos que esos estudiantes tienen como unas notas, entonces luego corren un reduce para sumar como todas las notas de ese alumno y luego pues tienen un total, la suma total. Y luego quieren sacar el promedio de ese estudiante. Entonces toman el total y lo dividen por el número de notas que tengan. Y ahí tienen el average, que sería como el promedio de notas de ese estudiante. Y si se quedan pesados al template, yo lo evitaría totalmente. Yo este cálculo si ya lo haría en el servicio, en el componente, antes de enviarle la data y no se la dejaría procesar al template. Si bien con el nuevo LED se puede, lo evitaría. Entonces volvemos a nuestro inocente cálculo del impuesto. Entonces, ¿cómo lo podríamos hacerlo? ¿Y a qué me refiero con procesarlo antes? Pues precisamente con procesarlo antes se supone que entonces yo podría tener algo como esto. O sea, obtengo la respuesta del producto y una vez tengo la respuesta, lo proceso como en la lógica de negocio y luego ya le envío esa variable. Veamos cómo sería la buena práctica en teoría. Entonces, para hacer la buena práctica, lo que vamos a hacer es primero un for. Vamos a básicamente iterar una lista de productos. Para eso necesito, pues casi como esta misma patrón. Tengo como los productos, tengo la API. Entonces acá podría tener products. Acá ya directamente la API va a ser products. En vez de un producto en específico, va a ser una lista de productos. Entonces acá ya el observable y acá podría cambiar esto a pues realmente yo no quiero un solo producto. Quiero una lista de productos. Perfecto. Y acá también ya tendría un signal que son los productos. Acá una buena técnica es como esto es un array. Voy a darle un valor inicial que sería un array en vacío. Es decir, si no hay productos significa que déjenmelo como un array en vacío. Perfecto. Ahora, como iteramos esto, fíjate que acá ya no sería necesario el let, porque cuando usamos un for, acá cuando usamos un for, entonces ya se crea esa variable como es el let intrínseco. Ya está ahí. Acá es que nosotros ya hacemos products y pues aquí voy a suscribirme a mi señal, ponerla y luego hacerle el track. Acá creo que es punto y coma, si no estoy mal. Track y le digo product, que es por cuál va a ser el índice para iterar. Track. Listo. Y ahora ya podría poner como esto adentro. Realmente este let ya, ya no lo tenemos que hacer porque ya está como por cada uno ya nos está generando el product, entonces no hay problema. Y este if tampoco, porque realmente ya la iteración me asegura que hay un producto. Entonces ya este if también lo podríamos quitar y simplemente se queda de forma plana. De pronto lo que podríamos utilizar es como nuestro empty. Que es cuando de pronto hay un array en vacío, decir pues como no hay, no hay productos, no hay. Que sería la forma de decirle a un array que si está, que ha creado un vacío, pues que es nuestro valor inicial por si la petición no se resuelve de forma correcta, pues queda como un array en vacío y o realmente tal vez no haya productos y le decimos que no hay productos. Fíjate que tenemos todavía el let por acá, el cálculo de los impuestos, veamos si funciona. Ok. Ah, por aquí tengo un error y es que nuestro signal yo estoy obteniendo del producto y obviamente esto no se itera, el que se itera es products, que es el signal que tiene la lista de productos. Vamos a ver, ahora sí. Entonces tenemos nuestra lista de productos y pues el let y eso sigue funcionando. Ok, entonces, ¿cómo sería la buena práctica para calcular este tipo de cosas? Recuerdamos este, este no es un cálculo tan pesado, pero igual yo trataría de evitarlo. O si tenemos cálculos ya más complicados, como el que vimos de los estudiantes que saca un promedio, no sé qué. Eso sí debería estar en la lógica y tratar de evitar o tener tanta la lógica de negocio en el template. El template para mí debería ser simplemente muestro datos y si quiero formatear algo, utilizo un pipe, pero no lo utilizaría para hacer cálculos, por ejemplo. Si bien se puede, vamos a ver cuál sería la buena práctica. Ahora, realmente yo también entiendo esta parte, porque para alguien que está aprendiendo Angular, pues quiero calcular el impuesto, pues lo calculo aquí dentro del for y ya no hay problema, porque la buena práctica básicamente requiere que sepas un poquito de, por ejemplo, RQG es procesar la data antes de que llegue al componente que normalmente lo vas adquiriendo. Una vez vas como subiendo tu nivel de seniority o experiencia en el framework, pero pues vamos a verlo, pues precisamente acá, por ejemplo, tengo la interfaz de lo que es un producto, no? Entonces tengo un producto ahí está, pero los impuestos no me los da el backend. De por sí, entonces sería bueno que el backend me lo diera, pero por alguna razón el backend no me lo da. Entonces tenemos lo primero, como no hace parte de un atributo que me lo entrega el backend, yo debería agregárselo. Entonces aquí, y esto va a ser un número. Entonces acá ya tenemos varios pasos para hacer la buena práctica. Primero agregar ese atributo, porque normalmente no está dentro del modelo de nuestros datos. Ahora, si bien está el backend no nos lo da, entonces nos toca a nosotros procesarlo. ¿Cómo yo podría procesarlo? Normalmente se utiliza un pipe y entonces utilizando los operadores de RxJS, por ejemplo, puedo tener un mapa, acá tengo la respuesta que es básicamente la lista de productos, response, ahí está, response, response, ahí está y obtengo esto. Entonces acá tengo acá este map me está dando algo, así quiero importarlo de este map viene de los operadores de RxJS, que es como transformar el response. Entonces acá tengo la lista de productos, literalmente está la lista de productos, como es la lista de productos y podríamos ponerle products, o sea, literalmente es la lista de productos. Este map es transformar lo que ya viene, no per se la lista de productos, sino lo que viene. Entonces acá como tengo los productos, puedo ya hacerle un map nativo de JavaScript y decirle pues acá tengo un producto y quiero devolver ese cálculo, quiero devolver ese mismo objeto, por eso entonces utilizando el SpiritOperator, copio todos los atributos y ahora voy a agregar el de impuestos. Entonces podría ser productos, price por un 0.19, no? Y esta sería la forma de que entonces yo le agrego a esos datos un valor que no me venía calculado y lo calculo desde cuando se resolvió la, pues el request hacia nuestra API y ya le entrego esos datos procesados. Entonces aquí ya no tendríamos que hacer como este cálculo desde dentro del template, sino que básicamente podríamos tratarlo como si fuera una variable más que ya viene calculada, ya viene procesada. Vamos a ver si funciona. Acá literalmente funciona, sigue funcionando, sigue calculando los impuestos, pero ya no estoy teniendo esa operación dentro del template. Aquí estoy poniendo esa operación dentro de mi lógica de negocio y si nosotros miramos código un poco más real, más mantenible, esto de por sí tampoco debería venir aquí en un componente, normalmente viene en un servicio. En un resolver en algún lado que normalmente se encarga de transformar o operar o comunicarse con datos y ya debería venir esto procesado y simplemente el componente usa ese servicio y para él es transparente, pues obtener o calcular esos datos. Simplemente él ya sabe que tiene un atributo con los impuestos. Ahora entonces el LED viene dentro de estas posibilidades, pero recuerda que te estoy diciendo como algunas cosas de pronto que podríamos caer en malas prácticas o también unos buenos usos. Por ejemplo, esto de la Sank, esto de suscripción para evitarnos como ese IF, pero uno que me parece muy interesante, por ejemplo, también es este. Este otro uso que he visto que le dan category. Digamos que yo tengo la categoría, que por si la categoría de este producto es viene dentro de viene como algo agregado dentro del producto, viene como un subobjeto. Entonces, si bien nosotros podríamos hacer algo como esto, por ejemplo, el nombre de la categoría. Entonces acá podríamos poner acá product. Punto category. Punto e name, por ejemplo, si no estoy mal. Y acá, por ejemplo, puedo poner también la imagen de la categoría. Hagamos la imagen de la categoría. Entonces imagen. Por ejemplo, product. Punto category. Punto e image. Y esta sería. Vamos a ver. Y le pongo un. WIDTH de un 80. A ver cómo funciona. Vamos a ver si funciona acá. Por ejemplo, tengo la imagen de las categorías que yo creí que tenía todas la misma imagen, pero no aquí ya vemos que cambia. Pero entonces ahí está de por si lo a poner un poquito más. Creo que la puse muy chiquita. 150. Entonces ahí está la imagen. Algo que he visto es que cuando un cuando algo tiene mucho anidamiento, uno se puede como ahorrar ese anidamiento o al menos no tener que en todo lado tener producto punto categoría y producto punto categoría y recuerda que esto es sólo un nivel de anidamiento, pero a veces puede haber más pronto categoría y punto no sé qué. Digamos que este tax y tax es un for y entonces no sé. Tengo que ir e ir e ir. Digamos entonces de pronto se vuelve un poco complicado estar repitiendo esto para obtener los valores de algo que tiene un anidamiento profundo, entonces lo que he visto que es que también el let lo utilizan para evitar como o hacer ese anidamiento sólo una vez. Entonces acá crean un categoría y le digo Mira, esto es producto punto categoría. Ya tengo ahí la información de la categoría. Entonces a partir de ahí, pues simplemente voy y me ahorro como el anidamiento de productos, sino ya tengo categoría, punto, en categoría, punto y me. Entonces si vemos funciona tal cual, sigue funcionando sin problema, pero he visto que también podemos como dejar la sintaxis un poco más clara y evitar tanto anidamiento. Entonces, pero otra vez, si ven, yo lo utilizo no para operar datos, sino literalmente como para mejorar la lectura del código, para evitarme el hack del if para, por ejemplo, tener un el de por ejemplo, si quiero realmente operar algo, yo utilizaría un pipe porque son cuestiones de formato, pero para operar o para calcular algo, procesar datos, yo lo haría directamente en la lógica de negocio. Entonces así ya quedaría nuestro cálculo de los impuestos. Entonces simplemente pues ya es un valor que viene porque ya lo procesamos en la lógica de negocio. Normalmente eso es un servicio o puede ser el componente, pero ya está procesado y no le dejamos ese peso del cálculo al render o al template. Ahora bien, por qué digo que es que este led pues puede llegar a tener problemas de rendimiento si no lo usamos adecuadamente? Porque se pueden hacer cosas como estas. Fíjate, literalmente acá tenemos un led que literalmente es un observable que al final se va a dar un error. Entonces, si yo quiero hacer algo, pues se suscriba una información con la sign, tenemos la data y luego fíjate que puedo crear un led para procesar la data. Y si existe ese data existe, entonces hago un map porque algo estoy haciendo ahí con ese map, estoy obteniendo el value de cada uno de los elementos de ese array. Y si no, pues es un array en vacío y luego pues por ahí como que hago el for y demás. Esto, por ejemplo, yo si bien podría ser posible con el led. Yo podría procesar datos en el template porque ahora con led podría ser posible. Yo trataría de evitar este tipo de de digamos de malas prácticas y todo eso debería ocurrir en el componente, en el servicio. Procesar la data debería venir ya lista el template. No debería preocuparse por calcular, procesar, sino ya simplemente renderizar bien. Entonces, por eso tenemos como estos ejemplos que si bien son muy interesantes, yo trataría de todo lo que es procesar datos, hacerlo antes de que llegue al template. Por ejemplo, este también me parece delicado porque, por ejemplo, también lo estamos utilizando para filtrar para, por ejemplo, acá estamos teniendo una lista de productos y acá están haciendo un filtro sencillo. Si el stock, que es como la cantidad que hay en el almacén, es como lo que tú tienes en inventario, si el stock es mayor a cero, significa que ese producto está disponible. Por ende lo muestro. Entonces utilizo un if para mostrarlo y si bien se puede con el led, porque de nuevo el led nos abre este mundo de posibilidades. Entonces, esto básicamente debería ser un filtro que ya debería venir procesado antes de yo entregárselo al template. El servicio lo puede hacer, la lógica del negocio del componente lo puede hacer. En este caso es filtrar todos los productos que no tengan un stock hábil. No? Entonces yo trataría de, por ejemplo, de en vez de mandarle toda la lista y filtrarlo directamente en el template, pues si ya lo ve lo tenemos o teníamos unas prácticas de procesamiento, pues básicamente lo podríamos hacer también desde la lógica de negocio. Veamos un ejemplo sencillo. Digamos, si realmente yo quisiera filtrar estos productos por algo en específico, pues podría poner acá un filtro y decir mira, sólo quiero los productos. Entonces acá tengo Product. En mi caso, digamos que quiero los productos. Product punto que tengan un precio mayor a no sé, a 10 dólares. Entonces vamos a ver si tengo productos mayor a 10 dólares. Entonces aquí ya estoy haciendo y de nuevo al renderizado al HTML le llega un un array que ya tiene los productos que ya debe mostrar que ya están procesados, ya están filtrados, ya están tratados, el template sólo renderiza la información. Entonces vamos a ver si hace ese filtro. Entonces por acá tenemos sólo productos que tienen que son mayores a 10 dólares. Por ejemplo, acá este es 44 dólares, 79, 25, pero nunca vamos a llegar a uno mayor porque ya está en el filtro. Es más, hagámoslo menor. No sé si tenga productos menores a a 10 dólares. Veamos, vamos a ver si lo tengo por aquí. Cuál es mi pantalla? Es esta. Fíjate que no, que no hay productos. Literalmente no hay productos que sean, pues que cumplan con esta condición. Como ya le apliqué un patrón, le apliqué como todo un filtro, pues no hay productos que cumplan con este, pues con ese procesamiento que le acabo de aplicar. Entonces precisamente lo que haríamos es eso. Volver a utilizar la técnica de procesar los datos antes de que lleguen al template, filtrarlos en vez de calcularlo directamente en el template y bien de nuevo. Entiendo que, por ejemplo, con este LED sea mucho, por ejemplo, más fácil a personas que están enseñando, aprendiendo Angular o personas que enseñan Angular, yo enseño mucho Angular, entonces es más fácil empezar a decirle a las personas mira y puedes calcular. Lo impuesto directamente y empezar rápido a moverse dentro del framework. Luego obviamente uno empezaría a tener estos más detallitos de rendimiento y de decir ok, si bien se puede, operemos esto mejor en el servicio. Entonces ya uno enseña estas nuevas técnicas de ok, procesemos esto antes de que llegue al template. Me parece muy bueno para la curva de aprendizaje. Luego, si uno ya se preocupa por rendimiento, empieza. Pero eso normalmente ya lo haces cuando tienes más experiencia en el framework, no desde el día cero. Desde el día cero estás aprendiendo Angular, no aprendiendo como los trucos y cosas de rendimiento que normalmente uno tiene ya después de tener experiencia en el framework. Y listo. Eso ha sido la introducción a la LED, a esta variable LED dentro de la nueva sintaxis de Angular. Déjame en los comentarios saber si la vas a aplicar, si te parece útil, si no, si ya te alivia no tener ese hack de Leaf para resolver o colocar un alias a una sign, a un signal, sino literalmente es súper sencillo. LED súper declarativo también me parece que es una forma interesante ya de leer código, realmente leer código y que sea fácil de entender para otro desarrollador que esté leyendo nuestra lógica en el template, nuestra lógica en nuestro TypeScript. Es fácil de entender que de pronto con el if y como con ese alias la gente no se sabía o no sabe este truco a veces, entonces simplemente como que era difícil de entender. Ahorita creo que con un LED literalmente puesto y súper fácil de leer código, saber que estamos procesando algo, saber que estoy teniendo esa variable y que ya la puedo utilizar a través de todo el template. Así que bueno, déjame tus comentarios y eso ha sido todo por hoy. Esas son. Recuerda que este LED sólo viene desde la avenida porque todavía está en preview, todavía pueden haber cosas que de pronto ajusten, aunque yo he visto que ya casi está para lanzarse así como lo vimos. Pero básicamente eso está desde va a lanzarse desde la 18.1. Desde la versión 18.1 de Angular hacia adelante. Si quieres utilizar esta nueva variable, tendrías que estar bajo esa versión 18.1 en adelante, si no te tocaría empezar a actualizar para utilizar esta nueva LED syntax. Así que bueno, nos vemos hasta la próxima.