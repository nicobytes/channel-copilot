 Ha salido una nueva versión de TypeScript, la 5.5, y en este video te voy a mostrar 5 características o features muy interesantes que vi en esta versión y que no te la puedes perder y que de pronto te animen a actualizar. Así que vamos por ello, vamos a mostrar estas 5 características del grandioso TypeScript. Empecemos de una vez por una de las primeras y aquí tengo una configuración base, esta va a ser un proyecto, este como en gris va a ser un proyecto que tiene la versión anterior, la 5.4, que es la que tengo acá, la 5.4, pero por acá tengo otro proyecto, exacto, que es este azulito, o bueno, con el borde azulito de Visual Studio Code, que tiene la 5.5, es decir, la nueva versión. Y vamos a ir comparando precisamente algunas características que TypeScript ha sacado en la siguiente versión. Vamos por la primera característica muy interesante y es lo siguiente, fíjate en esto, nosotros tenemos un array, de números, pero fíjate que por acá tenemos a alguien que es un nulo, entonces la inferencia de TypeScript nos dice, ok, fíjate, esto puede ser un array de números y nulos. Luego, en una siguiente línea, hacemos un filter y casi que limpiamos todos esos valores nulos. A nivel de lógica de JavaScript, básicamente lo que va a pasar cuando ejecutemos este código, es que si ese array tiene un nulo, lo va a limpiar y solo va a quedar, pues, numeritos, tipos number. Pero fíjate que aún así, de acuerdo a este, digamos, a esta ejecución o a este predicado, básicamente aquí TypeScript es incapaz de decir, ok, después de ese filtro, yo solo voy a obtener números. Realmente aquí todavía la inferencia de TypeScript me está diciendo que todavía podría obtener un array de numbers y de nulos. Y eso no es lógico de acuerdo, pues, a realmente cómo esto va a correr ya en un runtime, sea de Node.js o cualquier runtime que utilices de JavaScript. Realmente aquí ya tendríamos solo un array de números. Entonces aquí la inferencia de TypeScript no alcanza y esto es bastante interesante porque TypeScript eventualmente está no solo dando type checking o feedback loop temprano de como errores de typing sencillos, sino que también está teniendo en cuenta la ejecución, cómo esto ejecutaría realmente en un runtime de JavaScript y por ende también nos puede prevenir errores. En este caso, por ejemplo, no está tomando la inferencia de que realmente... Esto debería ser un array solo de números porque yo ya lo limpie, yo ya limpie todos los nulos y por ende aquí me deja hacer un push de un nuevo nulo. O sea, sigue respetando básicamente que este number o este array nuevo puede ser números y nulos sabiendo que yo ya lo limpie. Ahora, si yo tomo este mismo pedazo de código y lo mando a un TypeScript 5.5, que es la nueva versión, ahí está, lo copio y lo pego, fíjate que acá la inferencia sí me dice, ok, realmente una vez eso pase por un filter y limpie todos los nulos, ahora esto va a ser solo un array de números. Por ende, como esto queda con esa inferencia y ese array solo de números, cuando yo le haga un push de un nulo no me va a dejar, previniendo pues errores tempranos, previniendo que si al final yo ya limpie esto, a menos que realmente sea mi caso de uso en el cual realmente yo quiera insertar un nulo después de ya haberle... limpiado todos los nulos, que igual sería un poquito raro, pero puede darse el caso. Pero en este caso, el caso más sencillo es si yo ya limpie todos los nulos de ese array de números, pues la inferencia aquí ya sí me dice que es un array de números, solo de números, no de nulos, por ende, pues ya no me deja insertar un push, lo cual puede prevenir bastantes errores y ya lo está infiriendo. No tengo que ejecutar este código, sino que ya lo infiere y me previene ese tipo de errores. Fíjate que, por ejemplo, si yo le pongo, oye, digamos que yo quiera hacer lo contrario. Quiero hacer que de un array de números solo quiero obtener los valores nulo. Entonces fíjate que acá este filter ahora solo es un array de nulos. Si realmente tuviera varios elementos nulos dentro de ese array, solo me lo deja y pues como es un array de nulos me permite seguir insertando nulos. Pero si yo le inserto un número, pues no me deja porque pues se supone que ese array solo es de nulos porque pues para eso hice el filter anterior. Entonces fíjate que ahora TypeScript alcanza a inferir hasta ese tipo... de predicados, ese tipo como de lógica que normalmente solo la vamos a ver cuando corra JavaScript, cuando ejecutemos este archivo en un runtime como Node o cualquier otro. Realmente solo veríamos estos errores hasta que se ejecute, pero TypeScript ya está alcanzando a inferir estos tipos de errores y a tener un feedback temprano antes de la ejecución. Por eso es que TypeScript ayuda un montón y reduce un montón de bugs porque ya aquí sin necesidad de ejecutarlo. Estoy teniendo feedback temprano. De este tipo de... pues de... de inferencia de acuerdo a la lógica que yo tenga en el código. Veamos la segunda característica. Esta se trata un poco más de cómo tratan los objetos TypeScript. Y acá hay como un error que en teoría con base a la lógica que tenemos en el código, él debería ser capaz de inferirlo. No lo logra y por eso aquí nos da un error. Este que está acá. Pero evaluamos un poquito el código que hace esta función. Esta función básicamente si yo copio... por acá un ejemplo que tengo de código como para que entendamos qué es lo que hace esta función. Lo que va a hacer es que esta función recibe un objeto, la cual va a ser pues un... todas las llaves de ese objeto van a ser un string, esto es normal. Pero lo que no vamos a saber es el... qué tipo de valor tiene. Entonces básicamente le digo que el typing va a ser un no, desconocido. Entonces aquí básicamente yo le puedo poner un objeto con cualquier valor. Digamos que acá tengo nombre, edad y... digamos... que tengo por acá un array de algo, no sé, de notas. Entonces yo dinámicamente podría decirle que ahora tengo un array de números. Y no hay problema. Lo único que debo respetar es que la llave sea un string y el valor un no pues puede ser cualquiera. En este caso pues tengo un... la llave name, la llave age, la llave notes y aquí tengo el valor. En este caso es un string, un number y un array. Listo. Entonces básicamente ¿qué hace esta función? Yo le mando ese objeto y con base a el key entonces me devuelve el valor. Entonces en este caso por ejemplo si yo le mando el objeto y le digo oiga tráigame lo que está en el key name. Pues lo que hay dentro, el valor que hay dentro del key name es nicolás entonces me lo trae. Si yo le dijera oiga tráigame lo que está en notes. Pues me debería traer el digamos que la función me debería traer el valor que sería el array. Perfecto. Hasta ahí eso es como lo que cumple esta función. Pero digamos que por alguna lógica de negocio yo quiero hacer que no solo devuelva el valor. Sino que cuando el valor sea un string como que lo transforme y haga un uppercase y me lo devuelva todo en mayúscula. Quiere decir que por ejemplo si yo le dijera oiga devuélvame lo que hay en name que es nicolás. Yo debería esperar que esto me retorne todo en mayúscula porque le estoy haciendo esa transformación. Ahora lo que pasa aquí o el bug sencillo raro aquí en 5.4. Es que si yo le digo que me devuelva el valor que está en notes. Que aún así yo ya como que le pregunte por el valor o me asegure de que el valor es un string con este if. Debería yo ya sin ningún problema como yo ya hice esta validación poder hacer un uppercase de ese valor sin ningún problema. Pero acá como que no alcanza no agarra aquí la onda de que yo ya le había hecho un if y había validado que eso es un string. Y acá me dice oiga yo no puedo hacer un uppercase de algo que es desconocido. Como que aquí básicamente empezamos también a mejorar como esa inferencia de TypeScript. Sin necesidad de ejecutar el código sino solo leyendo como las condicionales la estructura de nuestro código. Pero aquí no lo alcanza a agarrar. Ahora si yo muevo esto a la TypeScript 5.5. Fíjate que aquí no me da un error aquí simplemente me dice ok esto esto literalmente esto es un string. ¿Por qué? Porque yo ya le pasa por un if que me asegura que ese valor es un string. Y yo puedo hacer un toUpperCase. Entonces como que en este no lo alcanzaba como agarrar ese if o esa lógica anterior. Y me decía eso sigue siendo un no. Pero pues en la 5.4 ya empieza a agarrar esa lógica. Ahora si igual estás trabajando en la versión 5.4 o estás enfrentando este tipo de error. Hay una forma como fácil de solucionarlo que es simplemente guardar el valor en una constante. En este caso voy a por ejemplo aquí guardarlo en una constante. Tomo el value. Y ese value me aseguro. De que sea string. Por ende ese value si le puedo hacer un toUpperCase. Y aquí no falla. Pero tengo que como que guardar el value en una variable antes. Y luego si empezar a hacer transformaciones se puede hacer una pregunta. Esta sería una forma de solucionarlo en la 5.4. Pero no era como. Si yo no utilizaba como este hack. Pues había un error. En este caso pues ya simplemente lo infiere sin ningún problema. Sin tener que guardarlo en una constante. Y aquí voy a. Hacer una pausa sencilla porque está la número tres. El fichero número tres me parece muy interesante. Y son que ahora TypeScript puede también inferir o ayudarnos sin necesidad de ejecutar el código. Si no sólo infiriendo el código que tenemos ahí. Espresiones regulares. Si ahora dentro de TypeScript nos va a detectar errores en expresiones regulares. Normalmente nosotros declaramos una expresión regular y esto no lo toma TypeScript. Simplemente dice ok es una expresión regular y ya. Pero ahora puede detectar errores. Dentro de la expresión regular sin necesidad de ejecutar el código. Recuerda de nuevo TypeScript es el feedback lo más temprano posible. En directamente en el editor nos va infiriendo y entregando. Oye aquí puede haber un bug. Cuidado con ello. Cuidado porque acá estás haciendo algo indebido y puede darte un error. Ya el momento de ejecutarlo y ahora las expresiones regulares entran dentro de ese combo de inferencia. Vamos a verlo. Acá tenemos una expresión regular y las expresiones regulares siempre son complejas. Siempre son difíciles de aprender. Y digamos que nosotros creamos o copiamos esta expresión regular de cualquier lugar. Aquí literalmente en la versión 5.4 nos dice listo. Esa es una expresión regular y eso es todo. Pero no me chequea si realmente esa expresión regular está bien o no. Pero si yo copio ahora esta expresión regular. En la 5.4 me va a detectar un errorcillo que hay precisamente con esta expresión regular. Y por acá dice que yo no cerré. Pues como uno de esos grupos. Normalmente en expresión regulares. Fíjate que por acá yo estoy haciendo como ciertos grupos que se pueden hacer en una expresión regular. Pero aquí hay un como un paréntesis que me sobra o que me falta. Entonces aquí él ya me está diciendo. Oye esta expresión regular tiene un problemilla. No lo estás haciendo correctamente y ya me lo infiere. Cosa que por ejemplo en la 5.4 pues simplemente pasa de largo y hasta que ejecutemos esto ya en algún runtime. En Node en el browser. Pues hasta ahí nos daríamos cuenta de. Uy esta expresión regular tiene un error. Pero aquí ahora ya no la detecta. Y pues simplemente o lo solucionamos o pues vemos que está pasando. Pero realmente ya detecta las expresiones regulares como parte del checking. De lo que estás escribiendo. Ahora vamos por la número 4. La número 4 es acerca de que en JavaScript normalmente siempre está evolucionando. Siempre está pues sacando ciertos métodos nuevos etc. Ahora hay nuevos métodos. Hay unos nuevos métodos dentro de un nuevo tipo de dato que se ha venido trabajando. Que son los set que son conjuntos. Haz de cuenta literalmente conjuntos de datos. Esto que nos enseñaron un poco en la escuela en donde yo tengo el conjunto A y tengo el conjunto B. Y a eso dentro de teoría de conjuntos puedo hacer varias cosas. Puedo hacer unión de conjuntos. Puedo hacer una diferencia de conjuntos. Puedo en fin todo lo que yo puedo hacer en conjuntos. Como saber cuál tiene este y no tiene este. Bueno toda esa matemática de conjuntos. Que se puede hacer en JavaScript. Este nuevo como tipo de datos se está empujando y JavaScript soportaba como unos métodos sencillos para manejar uniones para manejar como marcha entre varios conjuntos. Pero ahora ha declarado unas nuevas funciones y ya son válidas y soportadas dentro de TypeScript. Veamos si me va la documentación de Mozilla. Aquí vamos a tener cuáles son esos nuevos métodos. Ahora JavaScript en las versiones recientes. Ahora tenemos. Que a estos nuevos conjuntos que aquí se conoce como set. Básicamente tenemos nuevos métodos para poder hacer la inserción o intersección de conjuntos y unión diferentes. Sin matriz diferentes. Bueno si es un subset de algún conjunto etcétera. Estos son nuevos métodos que llegan a JavaScript que son soportados en los runtimes. Pero que la versión 5.4 de TypeScript. Pues todavía como que estos métodos comunes son nuevos. A ellos les toca mapear estas nuevas cosas de JavaScript. Y todavía no son soportadas en las 5.4 y ya vienen en las 5.5. Veamos un ejemplo sencillo. Digamos que yo tengo estos dos conjuntos. Tengo como un conjunto de frutas y por acá otro conjunto de otra cosa que son Apple más Oranges. Y si yo aquí en la versión acá que suena 5.5 me va a pasar a las 5.4. Si yo quiero hacer un y unión porque pues ahora quiero utilizar esos nuevos métodos y quiero hacer una unión. Fíjate que aquí no me detecta. Literalmente me dice ok quiero hacer la unión de esos dos conjuntos. Por ende recuerda que en teoría de conjuntos pues no hay ninguno que se repita. Aquí ya tengo Apple acá ya tengo Apple. Entonces acá tengo Oranges. Así que realmente quedaría Apple, Bananas, Pears y Oranges. Todo normal. Voy a poner aquí una diferente. Alguno que no esté aquí. Apple, Bananas. Acá pongamos Tomatoes. No sé. Tomatoes. Acá Tomatoes. Listo. Entonces si vamos a ver si yo corro otra vez el yunión. Fruits. Punto yunión. Vamos a ver punto. Bueno ese de por sí directamente es el error. Acá yo no puedo correr yunión porque simplemente pues este método no está mapeado todavía dentro de que se puede. Como esto es nuevo en JavaScript pues simplemente no tenemos ese nuevo método. Ahora si yo lo corro en las 5.5. Acá. Ahora aquí no me da error. Literalmente dice sí. Listo. Yo puedo. Pues literalmente puedo. Y acá me da como un ejemplo. Esto sí ya es mi autocompletador de IA. También que él como que analiza el código y me dice pues probablemente eso sea la respuesta. Que yo utilizo Jifaco Pilot. Por eso me auto comenta y me dice pues esta podría ser la respuesta según el código que hay ahí. Pero bueno. Aquí literalmente lo que me dice TypeScript es. Oye. Y unión ya es válido. O sea eso lo puedes ejecutar. Cosa que en la versión 5.4. Pues no podrías como empezar a utilizar estos nuevos métodos porque no están mapeados dentro de que existen en JavaScript. Ya para finalizar una de las cosas que no quiero dejar de pasar es que TypeScript sigue trabajando en el tamaño de lo que pesa TypeScript en NPM. Lo que pesa normalmente traerlo y por ejemplo esto ya viene de un release anterior. Por ejemplo de TypeScript 4.9 a las 5.5. Literalmente reducirán el tamaño un montón de 63 que pesaba el paquete en NPM a de 63 a 37 y de por si en estas 5.5 siguen haciendo algunas mejores para para reducir el tamaño. Pero esto de este cambio desde la 5.0 viene reduciendo el tamaño de forma muy significativa realmente para nosotros en tiempo de desarrollo o dentro de nuestras máquinas no significa mucho porque. Cuando nosotros ejecutamos esto. Cuando nosotros corremos esto. Y al final lo transpilamos a JavaScript no es que nuestras aplicaciones pues carguen con TypeScript porque pues al final se transpilan y todo pasa JavaScript plano. Pero igual es muy interesante que están reduciendo ciertos paquetes o también igual si realmente estás corriendo sistemas vas con TypeScript que realmente ya se pueden hacer en el backend. O sea sin transpilarlo sino realmente correr JavaScript en algún runtime que ya viene siendo soportado cada vez mucho más. Dino, Bungie es ya de forma nativa hasta Node está pensando en soportar. Ya TypeScript de forma nativa cada vez se va corriendo de forma más nativa. Entonces esta reducción de pesos es bastante importante y listo. Esas fueron las 5 características de la versión de TypeScript 5.5 que más llamaron la atención en la comunidad. Realmente esta 5.5 tiene muchas más cosas que han trabajado. Eh performance ciertas cosas para librerías, pero al menos las más notables dentro de la comunidad o la que más nos sirve a nosotros como en el día a día cuando estamos desarrollando código basado en TypeScript. O la que más nos sirve a nosotros como en el día a día cuando estamos desarrollando código basado en TypeScript. Que TypeScript ya casi es usado por todos los frameworks. Eh Vue, React, Angular para el backend con Hono, Ness, etc. Pues casi que todos utilizamos TypeScript. Así que estas son las 5 características que son como las que más te van a ayudar a ti en ser más productivo si estás utilizando TypeScript para desarrollar. Así que si te gustaron por favor déjame en los comentarios cuál fue esa que más te gustó. Y pues espero verte suscrito en el canal, compártelo y nos vemos en la próxima.