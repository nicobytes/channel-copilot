 Hola, hoy te voy a enseñar cómo manejar el estado global o local de tus componentes utilizando un paquete que es bastante ligero pero que utiliza todo el potencial de la nueva reactividad en Angular basado en Signals, que es un paquete llamado ngRx Signals que viene de la familia de los paquetes de ngRx para manejar el estado, solo que este en especial es ligero, no tiene tanto boilerplate como por ejemplo aplicar Redux dentro de Angular, es bastante declarativo y utiliza Signals como su modelo de reactividad así que vamos a verlo, vamos a ver si esto puede cambiar la forma también en la que organizamos y pensamos nuestros componentes así que empecemos y todo esto de manejo del estado nos hace pensar en uno de los patrones más famosos en Frontend que es Redux y si bien este paquete o este paquete de Signals también nos ayudaría a atacar o manejar este problema hay que recordar un poco cuál es este problema, lo voy a describir de forma muy rápida y es que normalmente como nosotros hacemos aplicaciones para la web nosotros tenemos como este tipo de árbol al final es un mycket y el community de Init dann es un árbol entonces yo tengo un componente y ese componente tiene un hijo y ese otro hijo y así se va formando todo un árbol, ese tiene hermanos, etc cuando nosotros utilizamos la estrategia de dividir nuestra aplicación en componentes tenemos varios de estos nodos y el problema es cuando ya queremos comunicar nuestros nodos con otros cuando nosotros hacemos muchos componentes y eso no está mal de por si está muy bien como dividirlo en muchos componentes pequeños, entonces estamos no está mal de, o sea, está muy bien como dividirlo en muchos componentes pequeños, pequeños para tener responsabilidades más específicas, el problema es cuando necesitamos comunicarlo y si ustedes piensan básicamente cómo nosotros comunicamos esos datos, pues nos tocaría pensar en la forma de cómo recorrer un árbol, bien, entonces si yo quiero ir por ejemplo a este nodo que está como medio morado, quiere comunicarse con algún nodo, tiene que ir a su padre y este a su vez a su padre para luego encontrar a su hermano y luego bajar al nodo que realmente necesito comunicar algún estado, ese problema se conoce como Prop Drilling, normalmente en React se conoce también, en Angular en cualquier framework de frontend pasa porque al final nosotros estamos desarrollando aplicaciones basadas en la web que son un árbol, nosotros podemos hacer comunicación padre e hijo, en Angular esto se le conoce como Input y Output, bien, el problema es cuando ya tenemos algo tan complejo estaríamos por ejemplo de nuevo, si tenemos ese componente a ese nivel, ese nivel, tendríamos que enviar una señal tipo Output a su padre y ese a su vez un Output a su padre para que luego este otra vez lo vuelva a enviar a su padre y luego lo desencadene como un Input que sería la forma de ya enviar información, recordemos que la forma de recibir o de enviar información de un hijo a un padre es un Output y viceversa de padre a hijo sería Input, entonces como que nos da un desencadenar un montón de acciones que cuando ya tenemos un árbol bastante complejo se vuelve un árbol, entonces, ¿qué es lo que se puede hacer? Logramos un componente así que eso es un William otro, ese permite y si tenemos una señal de arguably general, y que es muy legal, si ya tenemos algo tipo Output aquí principios de reactividad y otros componentes se suscriben a cierta parte del store a la que le importe y de forma reactiva cuando haya un cambio, cuando un componente deje un cambio, el otro lo recibe de forma reactiva sin tener que recorrer todo el árbol. Básicamente ese es como el principio de Redux y lo que nos soluciona. Si quieren un video mucho más específico acerca de esto y como sus patrones, yo hice un video hace seis años en mi canal acerca de cómo funciona Redux. Ahí no hablo de framework sino del patrón como tal y luego como pues normalmente todos los frameworks lo han incorporado. Pero si resumimos un poco ese patrón, normalmente tenemos una acción, un reducer, que es el que recibe la acción y bajo a eso hace modificaciones en el estado y lo deja en el store. Y luego la interfaz gráfica o nuestros componentes se van alimentando de ese store y así se vuelve un flujo de una sola dirección. Uno de los patrones o uno de los principios de Redux es que todo va en una sola dirección. Tenemos un store como fuente de la verdad. Eso también es uno de los patrones que Signals o este nuevo paquete que te voy a enseñar hoy de pronto rompe ese patrón. Tener solo un store es uno de los patrones de Redux. Con el nuevo paquete podríamos tener más de un store. Vamos a hablar de eso más adelante. Pero todo este como patrón hace que tengamos algo complejo de implementar para estados sencillos, para estados que no sean tan complejos. Para un solo un componente, por ejemplo, el estado local de un componente se vuelve algo como sobresaliente. Por ingeniería o a veces para algunas aplicaciones que igual son complejas, se vuelve raro que solo por tener que agregar un nuevo feature, agregar como todo este boilerplate. Y si hablamos de ngRx en específico, ngRx agrega mucho más boilerplate del que normalmente tenemos en Redux. Por ejemplo, tiene los selectores, que es una forma más específica de seleccionar ciertas partes del estado. Y también agrega todo lo de los effects, efectos secundarios que realmente son un buen patrón de arquitectura, pero es más código. Y precisamente es lo que hoy vamos a ver. Hoy vamos a romper este, como todo este esquema que propone ngRx. Y ellos mismos proponen manejar este estado de pronto sin como todo está sobre ingeniería, pero basado en Signals y teniendo igual el o solucionando igual el problema inicial, que es tener un store general que nos podamos suscribir y reaccionar a él. Así que dejando de hablar, pues entramos en el código. Vamos a entrar a ngRx.io. Vamos a ir a la documentación. Acá. Literalmente tenemos varios paquetes para manejar el estado. Tenemos el Store, que es como el clásico, el que te comentaba que cumple como con todo el patrón de Redux, el que tiene mucho boilerplate, mucho código y que por eso muchos de pronto no les gusta y se vuelve sobre ingeniería. Y este incluye a su vez paquetes como el Effect, el RouterStore, casi que estos vienen juntos, el ComponentStore. Pero hay uno nuevo, uno nuevo en la familia que se llama Singles, ngRxSingles, que precisamente es simple, intuitivo. Es pequeño. No es tan grande. No es tan grande como... Porque al final tú cuando instalas el Store, casi que necesitas instalar luego el paquete de los Effects, luego el RouterStore, como que al final vas instalando más de una cosa. Aquí podrías sólo instalar uno, el que es basado en Singles y tener el mismo potencial sin tanto código. Entonces vamos a ver precisamente cómo es la instalación y a implementarlo. Ahora, realmente para poder implementar, también nosotros necesitamos cambiar un poco nuestro modelo. Y es fundamental de cómo nosotros organizamos el estado de nuestros componentes. Sea que utilices ngRxSingles o no, y sólo utilices Singles o ni siquiera utilices Singles, sino utilices RxG, es como patrón de reactividad. Una cosa que debes tener muy en cuenta es cómo organizas el estado de tus componentes. Entonces antes de entrarnos directamente a ver cómo los beneficios de manejarlo con este paquete, vamos a hacer unas pequeñas refactorizaciones en este componente que es súper sencillo. Bien. Pensando en cómo nosotros podemos crear el modelo. Nosotros podemos crear en mejores estados y poder manipularlos mejor y aprovechar paquetes como el de ngRxSingles. Entonces veamos, acá realmente tenemos una aplicación súper sencilla y por si acaso estoy utilizando, este es un editor IDX, que es este editor en la web. Literalmente esto es un browser, edxgoogle.com. Voy a ir otra vez al full screen. Que está bastante chévere y lo estoy probando, así que sólo por si se preguntan qué navegador es. Pero básicamente es una base de Visual Studio Code. Pero en la web por Google o potenciado por Google. Bien. Listo. Entonces pensamos un poco en este estado. Nosotros tenemos tareas, ¿no? La clásica, el ejemplo más hello world de los estados, pero que nos va a ayudar a reconocer este patrón. Entonces tenemos unas tareas y esas tareas pues tienen un ID, un título, un estado de si son completados o no. De por sí ese estado es como puesto en una interfaz en donde cada tarea debe tener sus tres atributos. Entonces tengo un array. Y utilizando el patrón ya reactivo de signals, pues al final tengo un array que tiene un signal que su valor es un array de estas tareas. Y ya, ¿no? Entonces tengo esas tres tareas. Luego fíjate que hay algo interesante. Acá tengo otro signal que se llama visible tags. Pero al final su valor inicial, porque todos los signals tienen que tener un valor inicial, como que viene derivado de las tareas. Bien. Ahora, ¿por qué hago esto? Porque nosotros normalmente yo necesito filtrar. Aquí en la interfaz gráfica. Pues tareas pendientes, tareas, todas las tareas, tareas que están completadas. Y para eso, pues no voy a borrar estas tags, porque si no se me iría toda la información. Entonces mejor las filtro y de acuerdo a lo que el usuario elija, pues van a ir quedando en visible tags, que son como esas tareas visibles para el usuario. Entonces básicamente ¿qué tenemos? Tenemos acá nuestro hello. Acá tengo una suscripción a visible tags con el tamaño. Luego tengo un for sencillo. Para iterar esas tareas. Entonces tengo la tarea 1, 2 y 3. Y tengo unos métodos pending, all y done. Perfecto. Todo hasta ahí como lo más clásico. Y de por sí tenemos unos métodos en donde se hace el filtro. Ok. Entonces tomo todas las tareas y pending tags va a coger todas las tareas que no estén completadas. Las filtra. Y una vez obtenga ese valor, pues entonces hace un set a visible tags. Entonces si yo voy a pending tags. Recuerda que acá pending tags serían estas. Las dos, la 1 y la 3. Entonces yo voy a pending tags. Y acá tengo pues que tengo estas tareas. Deberíamos llamarle tareas en vez de todos. Acá tags. Listo tags, ahí están. Tengo tres tareas. Si yo filtro por pending, entonces la 1 y la 3 están pendientes. Si yo voy a all, pues básicamente quedan todas. Que all básicamente lo que hace es volver a restablecer pues ese estado. Y done serían solo las que estén en true. Entonces si yo voy a done, pues acá tengo una sola tareita que es la tarea número 2. Hasta aquí todo bien, todo sencillo, nada del otro mundo. Sin embargo, nosotros podríamos mejorar esto con un estado más. Y no dejar visible tags como con todos estos filtros, sino crear un estado especial para el filtro. Es más, lo podríamos empezar a tipear por acá. Yo le puedo decir, mira, va a haber un filter. Y ese filter, por aquí ya la inteligencia artificial ya lo tiene. Me está como proponiendo un typing y me dice, mira, tú puedes tener un estado para el filtro, para guardar cuál es el estado de esa aplicación. Recordemos que estado no son solo los datos, también estado es la interfaz, es el estado general de la aplicación. Y un estado podría ser, bueno, cuál es el filtro del usuario. Está en todo, está en pending o está en done. Entonces esto se vuelve un estado más. Y entonces podría manejar aquí. Que, bueno, que filter es un sign out. Vamos a ver si me autocompleta algo. Ah, mira, sí, me dice sign out. Es de tipo filter y por defecto va a estar en old. Lo que quiere decir que yo no tengo que hacer todos estos métodos. Podría entonces visible tags ser un estado derivado, que realmente lo es. O sea, deriva de tags, pero también va a derivar del estado de filter. Entonces esto lo convierto en computed. O computed sign out. Vamos a ver acá, computed sign out. Vamos a ponerlo por acá. Listo. Y vamos a ver si detecta algo de lo que quiero hacer. A ver, dime. Aunque por aquí, ah, bueno, listo. Acá me dice, bueno, más o menos me dice, claro, si el filter está en old, entonces retorno todas las tareas. Vamos a ver si infiero lo demás. Si está en pending, no está mal. No está mal este autocompletado. Acá tengo un error porque todo computer debería retornar. No está mal. No está mal este autocompletado. Yo debería retornar sí o sí algo. Y acá básicamente si no entra en ninguna de estas condicionales, no está retornando nada. Casi que me quedaría con esto. Me quedaría con, si necesitaría refactorizarlo como por mayor lectura. Si no cumple con pending o ton, pues retorno todas las tareas y listo. Este podría ser un buen código. Una forma de organizarlo mejor es que acá tengo como, que no está mal realmente. Solo estoy mejorando. Acá no va a mejorar performance. Sino la legibilidad del código. Realmente aquí yo ya leí tareas, entonces para qué leerlo dos veces. Entonces realmente podría crear aquí un array con las tareas. Y evitarme ejecutar como varias veces la suscripción al signups. Y lo mismo con el filter. Para aquí estoy leyendo dos veces filter. Eso también me ayuda un poco a leer. Como que estoy viendo cuáles son las tareas que van a estar, que yo voy a estar. Cuáles son los estados derivados. Que voy a tener en cuenta en este computed. Entonces como que es fácil de leer y no tengo que escanear el código más abajo. Para saber cuáles son los signos que están derivando este estado. Sino que aquí rápido en las primeras dos líneas sé cuáles son. Y acá simplemente pues filter, filter y listo. Entonces esa sería como mi pequeña mejora. Sobre todo para mejorar la legibilidad de este código. Qué quiere decir que ahora yo ya no tengo que hacer este filtro. Porque este filtro va a estar en computed. Entonces lo que tendría que hacer es como un método llamado shinkfilter. Vamos a ver si sabe qué es lo que quiero hacer con ese método. Si me sugiere algo. Y ya, sí ahí está. Me dice yo voy a recibir un filtro y lo voy a modificar. Entonces cada vez que esto cambie como acá es computado. Pues va a volver a hacer el recálculo. Acá pues obviamente tendríamos que cambiar esto. Shingfilter. Vamos a cambiarlo por acá. Y podría enviar el estado. Entonces aquí tengo pending. Quiero que me filtre todas las tareas que están pendientes. Sí pending, pending. Ahí está. En all pues sería el filtro all. Y finalmente en done pues todos los que estén en ese estado. En el estado de done. Vamos a ver aquí done. Listo. Entonces esto fue un pequeño refactor. Para lograr exactamente lo mismo. Pero con un approach más de manejar estados. Y no literalmente crear otros signals. Sino confiar en el estado de la aplicación. Por eso derivamos. Creamos un estado más solo para el estado del filtro. Y visible tags se vuelve un estado que es derivado. ¿Derivado de quién? De dos signals. Que es las tareas y filter. Entonces si yo voy acá a all. Pues bueno tengo todas. Si voy a pending. Pues solo la 1 y la 3. Si voy a done. Pues tengo solo la tarea 2. O sea funciona exactamente igual. Solo que esto en cuestión de estado. Es mucho más fácil de mantener. Y nos va a dar ciertas ventajas que vamos a ir viendo. Ahora solo como plus. Si uno no está tan seguro de cuál es el estado de una aplicación. Ustedes pueden enviarle el boceto a GPT, Cloud, Gemini. Lo que sea. Y por ejemplo yo le envío una foto de esta interfaz. Que es una aplicación también como de tareas. Que tiene el filter. Tiene un botón de clear. Y yo le puedo escribir. Oye. Basado en esta imagen créame el estado de esta interfaz. Y fíjate que él dice. Ah bueno pues hay un array de tareas. Y este sería el array. Fíjate que aquí él detectó que hay como un input. Para pues escribir la nueva tarea. Y él me dijo que eso podría ser un estado de la aplicación. Y literalmente me dijo que pues un estado sería filter. Entonces. De pronto fue muy complicado. Entonces con base a la imagen por favor. Denle una interfaz en TypeScript. Para representar el estado de esta aplicación. Entonces si a veces tendríamos alguna duda. De como qué cosa podría estar en el estado o no. Podríamos enviarle como un screenshot de nuestra aplicación. O de nuestro prototipo. O de nuestro Figma. Y eso nos podría ayudar. Es más. Yo por aquí hice como el fake de. Ponerle como paginación. O sea la imagen la inserté como una paginación. Para saber qué hacía con esta imagen. Y por acá el estado resultante es este. Entonces me dice ok. El estado de la aplicación. Si acá está tags. Está new tags. Está filter. Pero me creó un estado segregado. Que es pagination. Y acá me dice bueno. Si vas a manejar paginación. Deberías tener tres estados. Cual es la página. El current page. El total page. Y el page size. Que es el número de ítems que tendría la paginación. Entonces igual nos da una explicación. Y hasta nos dice un poco. Como deberíamos empezar a manejar el estado. Etcétera. Etcétera. Bueno aquí por ejemplo. Lo hizo en base a react. Yo ya podría decirle. Bueno hazme esto en términos de angular. Con signals. Pero si solo es para representar el estado. Y tienen dudas de cómo hacerlo. Pueden utilizar IA. Y enviarle el screenshot. Y que les describa el estado. Ahora sí. Volviendo a nuestro ejemplo. Pues vamos a ver. Qué necesitamos para utilizar. Ya aprendimos un poco mejor. Cómo describir nuestro estado. Si de por dentro tenemos alguna duda. Pues podríamos igual. Tener una confirmación más. Un check más por AI. Pero quedémonos con este estado. Vamos a diseñarlo ahora sí. Utilizando la herramienta de ngRx. Porque ese es el título del video. Así que vamos a ver cómo se utiliza. Si ya me voy a la documentación. Pues acá tenemos un overview. El que ya habíamos visto. Y vamos a ir a la instalación. Fíjate que acá. Me pide un ngADD. Pero a diferencia del Store. Cuando tú haces la instalación. De un ngADD. Del Store. Del Store este grande. Y con mucho ball plate. El si hace bastantes modificaciones. O sea aparte de que agregan. El package de dependencia. Como que te crea una carpeta. O sea como que te hace muchas modificaciones. En el código para listar. Como de esa arquitectura. Realmente el design no. Simplemente lo que te hace es actualizar. Pues una nueva dependencia. Es decir no habría mucha diferencia. Entre simplemente hacer un npm install. Y ya. Porque no necesita de ball plate inicial. Bien simplemente que tengamos la dependencia. Y ya. Que tengamos la dependencia. Entonces voy a ir acá. Y instalar esa dependencia. En pues mi proyecto. Aquí estando. Pues en la terminal del proyecto. Voy a hacer la instalación. De este nuevo paquete. Vamos a ver. Normalmente aquí deberíamos tener. Nuestro package. Y ver si. Si lo dejo o no. Acá está. En yearwedge-signs. Ahí está. Lo acabo de instalar. Entonces ya podríamos. Cerrar este terminal. Y continuar con. Nuestro proyecto. Y empezar a trabajar. Con esto. Bien. Bueno. Bueno. Bueno. Bueno. Bueno. Vamos a empezar a trabajar. Con él. Bien. A veces cuando. Se instala una. Nueva. Dependencia. Sobre todo. Dentro de este entorno. De edi. Y dx. Hay que hacer como que. Un hard restart. Para que tome. La nueva dependencia. Y como que. Vuelve a lanzar. El proyecto. Con esa nueva dependencia. Por si acaso. Y listo. Basados en esto. Entonces vamos a. Ver que. Lo que nos dice. Es que deberíamos. Diseñar algo llamado. Un store. Un archivo. Que se va a encargar. De hacer. Como este ejemplo. Realmente. Yo lo hacen. Con books. O sea. Con libros. Yo lo estoy haciendo. Con tareas. Pero. Básicamente. Me va a servir. Gran parte. Del código. Así que. Puedo copiar. Y pagar. Ir cambiando. Y ir ajustando. Las partes. Que me sirven. Y las que no. Entonces. Vamos a crear. Aquí. Un componente. Bueno. No. El componente. Ya está creado. Este es un. Que. Esto va a ser. Para administrar. El estado local. De un componente. Si yo. Quisiera. Que esto fuera. Global. Vamos a ver. Cómo guardarlo. Pero realmente. Es cuestión. De naming. Del archivo. Y luego. De alguna configuración. Más. Que hay que hacer. En el store. Pero. No nos adelantemos. Todavía. Listo. Entonces. Tengo esto. Ok. Quiero. Aquí nos dicen. Para nuestros. Por ahora. No lo voy a hacer. Voy a dejarlo. Aquí mismo. Y ya. Listo. Está la tarea. También. Voy a pasar. Este. Como. Este estado. Acá. Filtro. Listo. Vamos a ver. Perfecto. Ahora. Acá. Quedamos. Un nuevo tipo. Que describe. El estado. De este componente. En este caso. Voy a llamarlo. Taxes. Y. Tiene. Un. Tareas. Y. Tiene. Un. Filter. Y. Mi. Filter. Es. Pues. De este. Tipo. No. Que. Es. Un poco. Lo que ya teníamos. Acá. Es decir. Tenemos. Dos. Estados. Un estado. Derivado. Vamos a ver. Cómo se manejan. Un. La descripción. Del estado. A nivel de. Type. Entonces. Acá. Tenemos. Un estado. Inicial. Que debe. Cumplir. Con. Ese. Type. Entonces. Como es. Un estado. Inicial. Le voy. A decir. Que las tareas. Inician. En. Una. Radio. En. Vacío. Y. En. Un estado. Que. Sería. Perfecto. Hasta ahí. Eso fue. Clarar. Un estado. Y fíjate. Que al final. Estos son. Funciones. Que vienen. Del paquete. Entonces. Ya tenemos. Nuestro estado. Este estado. Se comporta. Como. Un servicio. O sea. Se puede. Inyectar. Entonces. Es lo que vamos. A hacer. Entonces. Vamos a ir. Pues. Reescribiendo. Esto. No. Acá. Tenemos ya. Unas. Unas. Errores. Pero vamos. A ir. Solucionando. Lo primero. Que vamos. A hacer. Es lo siguiente. Pues. Vamos. A inyectar. Ese estado. No. Lo vamos. A crear. Como. Podría. Ser. State. No. Acá. Literalmente. El que. Va. A manejar. El estado. De. De. Nuestro componente. Pues. Es. Store. Porque. Es. El que. Tiene. Esa. Responsabilidad. Entonces. Casi. Que. Podríamos. Volarnos. Todo. Este código. Todo. Este código. Se va. A. En. Nuestro. Estadio. Podemos. Empezar. A solucionarlo. Bueno. Empecemos con el. Visible. Tax. Al final. Dijimos. Que era un estado. Que era derivado. Bien. Cómo. Se manejan los estados derivados. O computados. Con este paquete. Veamos la documentación. Si. Vuelve. De nuevo aquí. Pues acá me dice. Bueno. Mira acá. Inyecta. Lo. Eso fue lo que ya hicimos. todavía no me voy a ir hacia ese lado, por ahora solo quiero un estado local, no un estado global, pero acá me dice cómo puedo ir leyendo ese estado, etcétera, pero acá nos dice la parte que me importa, los computed signals, bien, entonces acá nos dice que si yo quiero un estado que es derivado de otro, necesito otra función llamada withComputed, ok, y ese vamos a tener los estados derivados, entonces vamos a ir a nuestro código y vamos a utilizar esa función, with, vamos a ver si la, ahí está, withComputed, acá básicamente esto es lo que recibe, es el estado actual del componente, que pues al final el estado son dos tareas, el array de tareas y el estado del filter, entonces ese va a ser nuestro estado y luego podemos devolver un, literalmente como un objeto literal, es decir, de esta manera, con todos los estados derivados, entonces aquí voy a devolver eso, le voy a decir, uno de esos estados derivados es visibleTags, las tareas visibles, que también se definen como computed, entonces casi que podemos copiarnos el código que teníamos anteriormente, o sea, el de acá, déjame que lo borré, quiero volver a copiar esta lógica, esto, esta lógica la puedo volver a copiar acá, déjame ver si está, es bien cerrado, creo que no está bien cerrado, chun chun, eso, y computed, al parecer no lo ha importado, vamos a importarlo, listo, entonces toda la lógica la pasamos acá, perfecto, y ahora sí ya me puedo volar todo esto, creo que el otro sí me lo sé, el chainFilter, bien, entonces vamos a dejarlo por acá, esto lo dejamos como readOnly, readOnly, readOnly, perfecto, listo, entonces este estado derivado, aquí lo que tenemos es que teníamos una clase, por eso teníamos this, pero acá pues tenemos el estado, entonces podríamos decirle, oye, del estado yo quiero las tareas, del estado yo quiero el filter, ah, y fíjate que por acá tenía un this, y realmente ya tengo las tareas antes, entonces devuelvo las tareas, perfecto, entonces esta es la declaración de un estado computado o derivado, utilizando este paquete, entonces ya tengo visibleTags, es un estado derivado, entonces ahora yo puedo hacer lo siguiente, podría ir a store y llamar a esas tareas, o a ese estado más, ¿no? acá está, ahí está visibleTags, ahora, hay un problema, el chainFilter, chainFilter era un método, ¿cómo manejamos estos métodos dentro de ese estado? pues resulta que básicamente así como hay un withComputed, hay un withMethods, que es el que nos permitiría crear métodos para modificar ese estado, entonces fíjate que acá ya todo está cohesionado, de pronto si tú has trabajado con Redux, o ya habías trabajado con NGRX, Store, ahí mismo está el estado, la forma en que derivamos otros estados, que esto casi que podría ser como un selector, también están los métodos, o sea, cómo nosotros modificamos ese estado, serían como el reducer, pero sin tener que crear un action, y no tenemos varios archivos, como que un archivo para los selectors, un archivo para el reducer, un archivo para el estado, un archivo para los selectors, todo queda aquí como cohesionado, lo cual también hace que sea más fácil mantenerlo, y el voidPlate de nuevo no es tan grande, tan complicado como al menos el que nos propone NGRXStore, bien, acá es como todo aquí, literalmente aquí voy a definir el método, entonces acá lo que voy a recibir es el Store, y también pues retorno, si no estoy mal, retorno, un objeto con los métodos que van a cambiar ese estado, ese Store, en este caso pues es ChainFilter, y ChainFilter que es lo que hace realmente, acá ya me está como adivinando, creo que igual no es la forma, no es con update, aquí la IA falló en autocompletarme este código, pero básicamente sí, es algo que recibe un filter, podríamos decir que esto no va, todo esto no va, déjenme ver dónde cierra, sí acá, entonces acá lo que podríamos hacer es, ok, ah, pero creo que igual tengo un error ahí de cerrado, ese es el problema, a veces con este autocompletado, que a veces uno no ve muy bien dónde, se cierra donde se va, creo que es acá, a ver, acá debería cerrarse, y luego tener un return, ah, si no, veamos cómo lo modificamos, a ver, porque acá yo podría devolver un auto, y no, sigo teniendo un problema, vamos a ver, voy a hacerlo sin el autocompletado, porque algo me está pasando acá, listo, entonces quiero definir un simple método, y ya, listo, esto es lo que necesitaba, acá voy a recibir, el nuevo filtro, new filter, new filter, que qué tipo va a ser, pues va a ser de tipo filter, y cómo cambio ese estado, pues realmente, aquí no tengo una forma como de store update, hay un método en especial de ngRex para modificar el store, que se llama patch state, si nosotros vemos ese método, viene específicamente del paquete de ngRex signals, entonces, ¿qué le necesitamos enviar? Necesitamos enviarle el store actual, como el, el estado actual, y luego simplemente nosotros necesitamos enviarle el nuevo estado, entonces si yo quiero manejar, cambiar filter, pues lo cambio por new filter, o sea, simplemente es como, cambiar una variable por la otra, ahora, si yo quisiera, tener un estado, o sea, como saber el estado anterior, para con eso hacer algún cálculo, igual, como tengo acceso al store, entonces yo podría, por ejemplo, acá al store, igual tengo las tareas, es más, tengo acceso también a las, a los estados computados, como visible tags, ¿no? entonces, podría decir, en base a las tareas actuales, no sé, acá hago un const, estas son las current tags, ¿no? y listo, acá tengo el valor y ya hago algo, ¿no? hago algo con él, y luego ya modifico el estado, o sea, se puede obtener los valores del estado, en cada uno de los métodos, ¿bien? no hay ningún problema con eso, listo. Entonces, ahora, si tenemos, entonces, también, simplemente, ahora tenemos un store.chainfilter, y listo, tenemos store, tenemos store, y ahora todo, todo, literalmente todo, está en nuestro estado, vamos a ver este, porque dice que no existe, creo que acá está fallando, ahí ya, ya listo, ahí ya lo actualizo, entonces, fíjate que todo el estado de mi aplicación, literalmente no es manipulado por el app de component, está declarado, aquí en, en este archivo app component store, utilizando este paquete, que no tiene tanto boilerplate, que puedo definir todo el estado de mi aplicación, y lo definiré de esta manera, un estado inicial, luego, cuáles son los estados que son derivados, y luego cuáles son los métodos para modificar ese estado, y mi aplicación funciona, vamos a ver si funciona bien, vamos a, aunque debería ya mostrarle por defecto las tareas, al menos las tres tareas, porque así estaba nuestra aplicación inicial, vamos a ver, porque no lo está haciendo, a ver, voy a ver, pending, all, no, aquí está pasando algo, porque no está filtrando, vamos a ver qué está pasando, page store, visible tags, ah, bueno, obviamente, obviamente, nosotros teníamos un estado inicial para las tareas, teníamos tres, tres tareitas que estaban puestas acá, pero nuestro estado no tiene ninguna tarea, ¿no?, como que no, no hay ninguna, yo podría ponerlo acá, realmente yo podría poner tres tareitas, por acá, por ejemplo, ah, mira, ahí me las completó, y ahí ya tengo un estado inicial, ¿no?, sin problema, entonces ahí ya funciona, ahora, obviamente, también, ¿cómo yo relleno ese estado?, porque nosotros normalmente, lo que normalmente hacemos, es ir a un servidor, a algún proveedor de data, como una petición, como un local storage local, lo que sea, y llenar ese estado, y eso sí normalmente lo hacemos en el app component, ¿no?, o de alguna manera, utilizamos los componentes, porque normalmente utilizaríamos un ngOnInit, ¿no?, como que, ah, el componente ya está, entonces va, hago un fetch a una API, y con base a ese fetch, pues entonces muestro tareas, ¿cómo sería entonces aquí esa parte?, realmente, también podríamos tener un método que se encargue de eso, yo podría tener algo así como fetch to do's, literalmente puedo tener algo como fetch to do's, o init to do's, o load to do's, como cargar tareas, es más, lo voy a hacer aquí, load to do's, puedo tener un método que la reciba, si lo quiero de esa manera, pero realmente quiero ir un poquito más allá, entonces vamos a ir por acá, por acá, por acá, por acá, listo, y entonces podría cargar esas tareas iniciales, por ejemplo estas, estas voy a cargarlas por acá, entonces podría hacer algo como, ok, tags, voy a poner como tags, tags, eso es igual a una red de tareas, y pues básicamente con un patch state, podría decir, bueno, pues al final las tareas son estas de acá, es más, lo podría dejar así, tags, porque tienen el mismo nombre, entonces pues simplemente las, se las doy, y entonces, ¿quién llama a este método?, pues lo podríamos de nuevo, como mencionaba, hacerlo aquí, con el store, punto, load tags, ¿no?, como cargar las tareas cuando el componente ya esté, y debería funcionar, ahora aquí lo mágico también, es que yo puedo tener una inyección de dependencia, si yo tuviera un servicio, puedo aquí inyectar mi servicio, entonces podría conectarlo a, to do service, ¿no?, que vaya a hacer una llamada a una API, o puedo utilizar, fire store, ¿no?, y aquí literalmente hacer una inyección de dependencia, porque al final recordemos que el inject, o estas funciones inject, ya se podrían llamar dentro de funciones, no solo dentro de programación de entrando objetos, podría inyectar aquí un servicio, digamos, service, no sé, un inject, realmente no tengo ningún servicio ahorita, pero fijamos que tengamos un tag service, y tag service va y tiene un, no sé, un método que se llama service punto, eh, load, ¿no?, de descartar, de descargar tareas, que va y se conecta, y esto es un observable o es una promise, si es una promise, pues, esto lo cambiaríamos a assign, y entonces hacemos un await por acá, y en fin, ¿no?, como que ya vamos a ver un poco cómo es el flujo, pero el store se sigue encargando de cómo manejar el estado, estos servicios siguen manejando como la forma en la que tenemos, obtenemos esos datos, como normalmente estos servicios son CRUD, entonces van, insertan, obtienen, etcétera, pero como que, ¿no?, es que acá toda la lógica en cuanto al estado está aquí, y nuestro componente ya simplemente utiliza el store y empieza a renderizar, bien, es más, acá esto ya lo podríamos, como utiliza solo signups, podríamos cambiar esto en change detection con un on push, para que tenga, pues, todas las ventajas de mucho más reactividad, mucho más potente, por acá podemos ver un poco más específico la parte de los métodos, acá literalmente nos dan como ejemplos de filtros, de entrar, de utilizar el patch state, pero acá nos dicen cómo agregar un libro, pero quería mostrar que aquí, fíjate que en este caso hicieron la inyección de algo llamado book service, dentro de with methods, como si fuera, como si eso viniera como parámetro, que se puede hacer aquí con la inyección, también se puede hacer a nivel de método, pero también está bueno que se haga a este nivel, porque entonces no tienes que en cada método inyectar o declarar esa inyección, sino que ya queda como, global en ese with methods, para que cualquier otro método lo pueda utilizar, entonces esta sería una forma, y fíjate que acá este tiene un método llamado getAll, que según esto tiene un await, entonces como que van y hacen el fetch y luego lo cargan, y algo muy bonito que tiene acá es que fíjate que un estado de loading, entonces acá recuerda que teníamos un estado de loading, como yo no estoy haciendo fetching, pues no me parece el estado de loading, pero por acá en el, como en la definición, del estado hay una isLoading, está cargando, entonces yo puedo agregar como estos estados, como estos pasos, entonces cuando yo le doy loadAll, voy a poner a inTrue ese estado, y por allá hay una interfaz que prende un loading, voy y hago el request, espero hasta que eso pues se obtenga, y una vez obtenido, cargo otra vez los libros al state, al estado de mi componente, y apago el loading, porque pues ya fue cargado, entonces esta es una forma, como de interactuar, pero qué pasa también con los, nosotros estamos acostumbrados a que los servicios son observables, qué quiere decir, que no tenemos promises, puede que sí, pero si al final venimos acogiendo como toda la reactividad dentro de Angular, que venía con RxJS, o al menos con los servicios que utilizan HTTP client, pues todo eso son observables, pues aquí es donde viene un método, como de utensilio que se llama RxMethod, entonces todos los servicios que tú tengas con ese patrón de reactividad con RxJS, pues simplemente utilizas este método y luego ya empiezas a usarlo, entonces por ejemplo estos dos los puedes obviar, simplemente pues tienen un beneficio obvio, pero literalmente es un poco lo que estamos haciendo acá, primero mando el request, pongo el loading en true, luego hago el fetch y luego lo pongo en false, entonces esto está, está pasando acá, utilizo un tab para poner el loading en true, luego un switch map para utilizar mi servicio que está basado en RxJS, o sea observable, y pues acá utilizo un tab response para que esto viene también de, como utensilio de esta librería, y si todo sale bien, pues acá tengo los libros y se quedó todo en false, si algo sale mal, entonces pues lo digo loading en false, y pues por acá estoy imprimiendo un console.error, pero pues dentro de la console, también podría tener un estado para el error, y de acuerdo a eso, pues imprimir algo, pero entonces podemos integrar dentro de este estado servicios directamente a nuestra lógica de los métodos, ahora bien, esto sólo fue para utilizar como el estado local de un componente, que realmente a mí me parece que es un buen patrón mental de pensar en nuestros estados, si bien puedes no utilizar ngRx, no, para no tener como todo este código, que es sin embargo, me parece una librería que es como muy light, o no, no tiene tanto boiplet, pero si nos da un patrón de cómo nosotros deberíamos manejar el estado, como nosotros lo vamos a computar, etcétera, pero si aún así no lo quieres manejar, igual tener el estado o pensar en este estado, y partirlo en diferentes lados y empezar a computarlo, es un gran, básicamente patrón para nuestras aplicaciones, ahora una de las cosas que aquí podemos hacer, es que este estado es sólo local, este estado sólo funciona para este componente, qué pasa si yo quiero tener ya un split y dividir esto en varios componentes, y pues cuando ya tengo un árbol complejo, comunicar eso, básicamente usar esto como estado global, pues si yo quiero utilizarlo como estado global, entonces pues ya no haría esa inyección de esta manera, porque no es para sólo para este estado, sino sería literalmente para, pues un estado global, y acá lo que tengo que hacer es que este store, lo cambio a ProvidingRoot, si no estoy mal, acá está como la documentación, que cuando queremos cambiar ese estado, o ese, si el store no a uno local, sino a uno global, acá está ProvidingRoot, lo cambiamos, al hacer eso, fíjate que nuestra aplicación sigue funcionando, sigue funcionando sin ningún problema, ya no necesitamos inyectarlo, de manera individual para este componente, ya quedó de forma global, quiere decir que si tú tienes un componente, no sé, tienes por acá un log y tienes un side panel, pues tienes la complejidad ya de una aplicación web, con muchos componentes, pues literalmente lo único que tienes que hacer es inyectar, de esta manera el store, no tienes que ponerlos siquiera aquí en los providers, porque ese estado ya está global, y otro componente básicamente podría ser, llamar a un método, o saber cuál es el método, o saber cuál es el estado de las tareas, sin tener que hacer esta comunicación de inputs y outputs, y el problema del Prop Building, entonces cualquier componente a cualquier nivel, podría inyectar el store, y mandar un método, saber cuál es el estado, etcétera, porque ya queda de forma global, entonces aquí tenemos un estado que funciona perfectamente, como estado, un store que funciona como estado global, pero también puede funcionar como estado local, y las dos son válidas, si tú sólo quieres administrar estados locales, utilizando este, esta técnica, está bien, también si quieres empezar a abrir más ese, ese store, y tenerlo pues global, pues esta sería la manera, entonces recuerda aquí el problema que estamos solucionando, estamos teniendo otra vez de forma similar, como algo que nos propone Redux, y es tener un store, en donde se manipule todo el estado, si yo tengo ya un split de componentes, no tengo que empezar a comunicar, padre, hijo, padre, hijo, inputs y outputs, sino que tengo definido el store en un solo lugar, entonces, si yo quiero empezar a comunicar con su estado, sus estados computados, qué métodos pueden hacer, esos métodos pueden tener inyección de servicios, para luego conectarme ya con un crudo, con lo que yo esté haciendo ya a nivel de data, pero como que toda la parte del estado queda allí, puedo tenerlo local, es decir, sólo para administrar esos estados locales con mi componente, o puedo ponerlo global, y cuando lo pongo global, es donde entonces tiene, este patrón se empieza a cumplir, entonces, ok, si yo quiero enviar input y output a un árbol un poco complejo, pues simplemente todo lo estoy comunicando con el store, hago, quiero modificar algo, quiero hacer la carga de algo, pues hago store punto y el método, el método que hace un fetch, el método que hace un load, el método que agrega una tarea, lo que sea, voy y lo agrega al store, en el método, pues tienen las inyecciones o los servicios necesarios para hacer esa acción, y los que estén suscritos a ese store, van a recibir el cambio de forma reactiva, y pueden saber ese estado sin tener que ir por allá a hacer muchas lecturas de input y output, simplemente los componentes que les interese saber el estado de la tarea, cuántas tareas son visibles, cuántas tareas son completadas, inyectan ese store y pues hacen, no sé, un punto visible tags o un punto, lo que sea que quieras darle acceso a esos componentes para que separen el estado, y una cosa muy interesante es que todo es reactivo, entonces, si literalmente haces un cambio aquí, el otro componente de forma reactiva se renderiza y obtienes tus cambios y los puedes leer de forma como súper sencilla, ahora de nuevo, este paquete, pues no tiene todo el bool, que nos tiene el, o sea, si bien utiliza algo del patrón de Redux, que es este patrón de tener un estado común y reactivo, no utiliza, pues el patrón como tal de tengo que tener una acción y el acción, entonces tiene un reducer y el reducer con base a la acción cambia y lo manda a un store, como que todo este patrón no se cumple, simplemente todo lo tenemos allí, de pronto lo cumple a nivel teórico, pero no explícitamente necesitamos definir el acción, definir el reducer y como todo este bool que de pronto en Redux desgasta un poco en aplicaciones, y sobre todo una de las cosas que sí rompe de pronto ya el patrón de Redux, es que en Redux todos pueden o todo se basa en un estado, en un solo store, en una sola fuente de la verdad, pero si tú aplicas sign outs o este nuevo patrón, realmente podrías tener muchos stores, porque al final se vuelve una inyección de dependencias, es más, puedes tener stores que tengan inyectado otros stores, entonces hay que tener un poco de delicadeza en cómo nosotros administramos ya el estado de nuestra aplicación, porque entonces ahora puedes tener stores a nivel de componente estado local, puedes tener un store solo para un feature en específico, y también puedes tener el store de la aplicación, bien, entonces ya no sólo hay una sola fuente de la verdad, podrías ya tener varios stores, lo cual puede ser algo complicado al inicio, pero a mí me parece que es una gran ventaja de tener estos estados locales, o sobre todo para features muy complejos que no quiero llevarlos al store global, pero sí quiero como feature o componentes muy complejos en cuanto a interacción, interfaz gráfica, pues tener ese store ahí que represente toda la complejidad de estado de ese componente, me hace bastante sencillo tener ese store, o al menos que sólo ese componente y los componentes que estén, sean hijos de ese feature, pues tengan ese store para manipular ese estado, así que nada, si te gustó este video dale like, suscríbete, mandale a tus compañeros acerca de este nuevo paquete dentro de la familia ng-rex, que si me preguntan a mí es bastante interesante, lo he utilizado mucho en la compañía en la que estoy trabajando, y todos mis compañeros de trabajo como que estamos empezando a utilizarlo mucho, porque realmente nos ayuda un montón, y además utiliza el nuevo patrón de reactividad de Signals, que ya tiene como bastantes ventajas en cuanto a rendimiento, y Angular también tiene mucho potencial a manejar este patrón de reactividad en Angular, para tener un mejor debugging, mejor reactividad, lectura de código, etc. Entonces ahora tener este nuevo paquete desde la familia ng-rex, me parece bastante interesante, además que no tiene tanto wordplay, eso es de las cosas que más me gusta, es como sencillo, simple, pues es una de las cosas por las cuales lo estoy utilizando y hice este video, así que no siendo más, recuerda suscribirte, compartirlo, y déjame tu feedback o comentarios al respecto en la sección de comentarios. Nos vemos.